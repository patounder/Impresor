/*  Version  FAC_DES_MAS ImpSclFnc.pc  7.000   */
#include <ImpSclFnc.h>
#include <math.h>
#include <utils.h>

EXEC SQL INCLUDE sqlca;

EXEC SQL BEGIN DECLARE SECTION  ;
	long lhNumAbonado;
	long lhCodCilclFact;
	long lhIndOrdentotal;
	char szhStrCodCliente[9];
	long lhCodCliente;
	char szhFecDesde[10];
	char szhFecHasta[10];
	char szhFormato_Fecha[9];
	char szhFormato_Hora [9];
	int  ihZero;
	int  ihUno;
	char szhDesTipValor[14];
	int  gihCodTipDocum;
EXEC SQL END DECLARE SECTION  ;

EXEC SQL DECLARE curMensNoCiclo CURSOR FOR
    SELECT DESC_MENSLIN
      FROM FA_MENSPROCESO A,
           FA_MENSAJES B
     WHERE A.NUM_PROCESO = :lhNumAbonado
       AND A.CORR_MENSAJE = B.CORR_MENSAJE
     ORDER BY A.CORR_MENSAJE,B.NUM_LINEA;

EXEC SQL DECLARE  curArrastre CURSOR FOR
         SELECT   COD_CLIENTE ,
              COD_ABONADO ,
              COD_BOLSA  ,
              VAL_BOLSA,
              IND_UNIDAD,
              VAL_ARRASTRE,
              VAL_EXPIRADO,
              VAL_DISPONIBLE,
              VAL_CONSUMO,
              VAL_RESTO,
              SUBSTR(TO_CHAR(COD_CLIENTE, :szhStrCodCliente),2)||SUBSTR(TO_CHAR(COD_ABONADO, :szhStrCodCliente),2)
         FROM     TOL_HDARRASTRE_TH
         WHERE    COD_CICLFACT = :lhCodCilclFact
         ORDER BY COD_CLIENTE,COD_ABONADO ;

EXEC SQL DECLARE curDocsPeriodo CURSOR FOR
         SELECT A.COD_OPERADORA,
            A.COD_OFICINA,
            A.COD_TIPDOCUM,
            B.DES_TIPDOCUM,
            A.PREF_PLAZA,
            A.NUM_FOLIO,
            TO_CHAR(A.FEC_EMISION,:szhFormato_Fecha),
            A.TOT_FACTURA
         FROM   FA_HISTDOCU A, GE_TIPDOCUMEN B
         WHERE  A.COD_TIPDOCUM = B.COD_TIPDOCUM
           AND  A.COD_CLIENTE = :lhCodCliente
           AND  A.FEC_EMISION >= TO_DATE(:szhFecDesde,:szhFormato_Fecha)
           AND  A.FEC_EMISION <= TO_DATE(:szhFecHasta,:szhFormato_Fecha);

    EXEC SQL DECLARE cRegImpre CURSOR FOR
            SELECT COD_REGISTRO,COD_TIPDOCUM
              FROM FA_REGISIMPRESION_TD
             WHERE COD_TIPDOCUM  = :gihCodTipDocum
               AND IND_IMPRESION = 1
             ORDER BY COD_REGISTRO ;


/* PGG SOPORTE 08-05-2006 Desde Aqui EC-042  */
/*****************************************************************************/
void trim (const char *c, char *result)
{
    char *l;
    char *r;
    for ( l=(char *)c;  *l==' '; l++ );
    for ( r=(char *)c+strlen(c)-1;  *r==' '; r-- );

    strncpy(result, l, (r>=l)?r-l+1:1);
    result[r-l+1]=0;
}

/*****************************************************************************/
int GetParam( int *iNumParam, char *argv[], char *szCadena,int chr)
{
    char    *p, *pant, c;
    int     cont;

    cont = 0;
    *iNumParam = 0;
    pant = p = szCadena;

    while ( 1 )
    {
        p=strchr(pant,chr);
        if ( p==NULL )
        {
            break;
        }
        else
        {
            c = *p;
            *p = 0;
            if ( ( argv[cont]  = malloc(_strlen(pant)+1) ) == NULL )
            {
            printf ("\n\t\t*** Error, No se puede reservar memoria \n");
            return(69);
            }
            strcpy(argv[cont],pant) ;
            pant = p  + 1;
            *p = c;
            cont++;
        }
    }
    if ( p==NULL )
    {
        if ( _strlen(pant)>0 )
        {
            if ( ( argv[cont]  = malloc(_strlen(pant)+1) ) == NULL )
            {
            printf ("\n\t\t*** Error, No se puede reservar memoria \n");
            return(69);
            }
            strcpy(argv[cont],pant) ;
            cont++;
        }
    }

    *iNumParam=cont;
    return(0);
}/************************ Final GetParam ***************************/

int CargaStringSuspension(long  lCodCiclfact)
{
    EXEC SQL BEGIN DECLARE SECTION;
    long lhEN_Cod_ciclfact;
    char szhSV_Categoria[513];
    char szhSD_fecha    [1025];
    EXEC SQL END DECLARE SECTION;

    char *szModulo="CargaStringSuspension";

    vDTrazasLog(szModulo,"\tEntrando a %s con ciclo=%ld\n", LOG04, szModulo,lCodCiclfact);

    lhEN_Cod_ciclfact = lCodCiclfact;

    memset (szhSV_Categoria, 0, sizeof(szhSV_Categoria));
    memset (szhSD_fecha, 0, sizeof(szhSD_fecha));

    EXEC SQL EXECUTE
    BEGIN
    CO_DIAS_SUSP_PG.OBTIENE_FECHA_SUSP(:lhEN_Cod_ciclfact, :szhSV_Categoria, :szhSD_fecha);
    END;
    END-EXEC;

    vDTrazasLog (szModulo,"\t===>>> CO_DIAS_SUSP_PG.OBTIENE_FECHA_SUSP [%d][%s] ",LOG04, SQLCODE, SQLERRM);
    if ( SQLCODE != SQLOK && SQLCODE == SQLNOTFOUND )
    {
        vDTrazasLog (szModulo,"Error en ejecucion de CO_DIAS_SUSP_PG.OBTIENE_FECHA_SUSP\n[%d][%s] ",LOG01, SQLCODE, SQLERRM);
        return(FALSE);
    }

    strcpy(SV_Categoria,szhSV_Categoria);
    strcpy(SD_fecha,szhSD_fecha);

    trim(SV_Categoria, SV_Categoria);
    trim(SD_fecha, SD_fecha);

    return(TRUE);
}
/*****************************************************************************/
int iCargaFechaSuspensionSt()
{
    char Dias_obtenidos[1000];
    char Categoria_obtenida[1000];
    int i=0;
    int  CmpPos,Pos,ARGC_DIR01,ARGC_DIR02;
    char *ARGV_DIR01[20],*ARGV_DIR02[20],CampoFormateado[1000];

    memset (Categoria_obtenida,0, sizeof(Categoria_obtenida));
    memset (Dias_obtenidos,0, sizeof(Dias_obtenidos));

    for ( i=0; i<2 ;i++ )
    {
        if ( i == 0 )
            GetParam(&ARGC_DIR01,ARGV_DIR01, SV_Categoria ,SEPARADOR_01);
        else
            GetParam(&ARGC_DIR01,ARGV_DIR01, SD_fecha ,SEPARADOR_01);

        stDias.iCantidadRegs = 0;
        for ( Pos=0;Pos<ARGC_DIR01;Pos++ )
        {
            GetParam(&ARGC_DIR02,ARGV_DIR02,ARGV_DIR01[Pos],SEPARADOR_02);

            memset (CampoFormateado,0, sizeof(CampoFormateado));
            if ( i == 0 )
            {
            sprintf(CampoFormateado,"%s" ,ARGV_DIR01[Pos]);
            strcat(Dias_obtenidos,CampoFormateado);
            stDias.iDias[Pos] = atoi(CampoFormateado);
            }
            else
            {
            sprintf(CampoFormateado,"%s" ,ARGV_DIR01[Pos]);
            strcat(Categoria_obtenida,CampoFormateado);
            strcpy(stDias.szCategoria[Pos], CampoFormateado);
            }

            for ( CmpPos=0;CmpPos<ARGC_DIR02;CmpPos++ )
            {
            free(ARGV_DIR02[CmpPos]);
            }
            stDias.iCantidadRegs ++;

        }
        for ( Pos=0;Pos<ARGC_DIR01;Pos++ )
        {
            free(ARGV_DIR01[Pos]);
        }
    }
    return(TRUE);
}


/* PGG SOPORTE 08-05-2006 Hasta Aqui EC-042  */

BOOL bfnOrdenaImpresionRC (ST_TABLA_ACUM  *pstTablaAcum, ST_TABLA_ORDEN *pstTablaOrden, int iUltimaPosicion)
{
    int         i,j,x;
    char        szKeyAux[60];
    int         iSocaloAux;

    for ( i=0; i<iUltimaPosicion; i++ )
    {
        strcpy(pstTablaOrden->szKey[i],pstTablaAcum->szKey[i]);
        pstTablaOrden->iSocalo[i]       = i;
    }
    for ( j = iUltimaPosicion; j > 0; j-- )
    {
        for ( i=0; i < j-1; i++ )
        {
            if ( strcmp(pstTablaOrden->szKey[i],pstTablaOrden->szKey[i+1])>0 )
            {
            strcpy(szKeyAux,pstTablaOrden->szKey[i+1]);
            iSocaloAux  = pstTablaOrden->iSocalo[i+1];

            strcpy(pstTablaOrden->szKey[i+1],pstTablaOrden->szKey[i]);
            pstTablaOrden->iSocalo[i+1]    = pstTablaOrden->iSocalo[i];

            strcpy(pstTablaOrden->szKey[i],szKeyAux);
            pstTablaOrden->iSocalo[i]      = iSocaloAux;
            }
        }
    }

    return(TRUE);
}

int CalculaDigVerif (double Inumero, int * DigVerif )
{
    int i       = 0;
    int j       = 2; /* j tomara los valores de 2 a 1 inclusives */
    int iDigito = 0;

    char szAux[2]   = "";
    char szNum[100] = "";
    long IValor;

    div_t stRes         ;

    if ( (long)Inumero != Inumero )
    {
        IValor = (long)Inumero*pow(10,atoi(szNumDecimal));
        if ( IValor<0 )
        {
            IValor*=-1;
        }
        sprintf (szNum ,"%ld",IValor );
    }
    else
    {
        sprintf (szNum,"%.0f",Inumero);
    }

    i = _strlen(szNum)-1;

    while ( i >= 0 )
    {
        if ( j <= 0 )
            j  = 2;

        strncpy (szAux, &szNum [i], 1);
        iDigito += (atoi (szAux) * j);
        j--;
        i--;
    }

    stRes = div (iDigito, 10);

    if ( stRes.rem == 0 )
        *DigVerif = 0;
    else
        *DigVerif = 10 - stRes.rem;

    return(TRUE);

} /**************************** Final CalculaDigVerif **********************/

BOOL bEscribeEnArchivo(FILE *Fd_ArchImp, char * zsBuffImpArch, char * buffer_local)
{
    int rc = 0;

    char *szModulo="bEscribeEnArchivo";


    if ( strncmp(buffer_local,FLUSH,_strlen(FLUSH))==0 )
    {
        if ( _strlen(zsBuffImpArch)>0 )
        {
            rc = fprintf(Fd_ArchImp,"%s",zsBuffImpArch);
            if ( rc<=0 )
            {
            vDTrazasLog(szModulo,"bEscribeEnArchivo RETORNO ERROR",LOG02);
            return(FALSE);
            }
            memset(zsBuffImpArch,0,sizeof(zsBuffImpArch));
        }
    }
    else
    {
        buffer_local[_strlen(buffer_local)]=0;
        if ( (_strlen(buffer_local) + _strlen(zsBuffImpArch)) < MAX_BYTES_BUFFER )
        {
            strcat(zsBuffImpArch,buffer_local);
            zsBuffImpArch[_strlen(zsBuffImpArch)]=0;
        }
        else
        {
            rc = fprintf(Fd_ArchImp,"%s",zsBuffImpArch);
            if ( rc<=0 )
            {
            vDTrazasLog(szModulo,"bEscribeEnArchivo RETORNO ERROR",LOG02);
            return(FALSE);
            }
            memset(zsBuffImpArch,0,sizeof(zsBuffImpArch));
            strcpy(zsBuffImpArch,buffer_local);
            zsBuffImpArch[_strlen(buffer_local)]=0;
        }
    }
    return(1);
}/****************** Final bEscribeEnArchivo *******************/


int FillCodIdioma(char *dat)
{
    int i;
    char aux[5+1];

    sprintf(aux,"%-5.5s\0",dat);
    for ( i=0;i<_strlen(aux);i++ )
    {
        if ( aux[i]==' ' )
        {
            aux[i]='0';
        }
    }
    sprintf(dat,"%5.5s\0",aux);
    return(0);

}

int RetPos(char *Cadena, ST_TABLA  *Tabla)
{
    int i;

    for ( i=0; i<Tabla->iLastPosition; i++ )
    {
        if ( !strcmp (Tabla->szDes[i], Cadena) )
            return(Tabla->iPosition[i]);
    }
    strcpy(Tabla->szDes[i],Cadena);
    Tabla->iPosition[i]  = i;
    Tabla->iLastPosition = i + 1;

    return(i);

}/**************************** Final RetPos **********************/

int FormatoHora(long lNumero, int iLargoNum , char *szFormato)
{
    ldiv_t  division;
    long    lDivisor=60;
    long    lMinutos;
    long    lSegundos;

    if ( lNumero < 0 ) lNumero = 0;
    division = ldiv (lNumero,lDivisor);
    lMinutos = division.quot;
    lSegundos= division.rem;

    sprintf (szFormato, "%*.*ld:%2.2ld",iLargoNum, iLargoNum,lMinutos, lSegundos);

    return(0);
}

int BuscaAbonado(ST_ABONADO *Abonado,int *pos,long NumAbo)
{
    int i;

    for ( i=0;i< Abonado->CantidadAbonados;i++ )
    {
        if ( NumAbo==Abonado->lNumAbonado[i] )
        {
            *pos=i;
            return(0);
        }
    }

    *pos=-1;
    return(0);
}

int FormateaDireccion(char *Direccion,char *dir_noformateada)
{
    int  rc,CmpPos,Pos,ARGC_DIR01,ARGC_DIR02;
    char *ARGV_DIR01[20],*ARGV_DIR02[20],CampoFormateado[2000];
    char *szModulo="FormateaDireccion";

    rc=TRUE;


    /*
    Separacion de campos segun delimitador asignados a arreglos
    */
    dir_noformateada[0]=0;

    RecupParam(&ARGC_DIR01,ARGV_DIR01,Direccion,SEPARADOR_01);

    vDTrazasLog(szModulo,"\tFormateaDireccion:Direccion:(%s)",LOG04,Direccion);
    for ( Pos=0;Pos<ARGC_DIR01;Pos++ )
    {
        /*printf("ARGV_DIR01|%s|\n",ARGV_DIR01[Pos]);*/
        RecupParam(&ARGC_DIR02,ARGV_DIR02,ARGV_DIR01[Pos],SEPARADOR_02);
        if ( ARGC_DIR02 <2 )
        {
            vDTrazasLog(szModulo, "\tFormateaDireccion:error numero regitros (%d):campo(%s)", LOG04, ARGC_DIR02,ARGV_DIR01[Pos]);
            rc=FALSE;
        }
        else
        {
            sprintf(CampoFormateado,"%-*.*s" ,atoi(ARGV_DIR02[1]),atoi(ARGV_DIR02[1]),((ARGC_DIR02<3)? "":ARGV_DIR02[2]));
            vDTrazasLog(szModulo,"\tFormateaDireccion:campo:(%s)",LOG06,CampoFormateado);
            strcat(dir_noformateada,CampoFormateado);
        }
        for ( CmpPos=0;CmpPos<ARGC_DIR02;CmpPos++ )
        {
            free(ARGV_DIR02[CmpPos]);
        }
    }
    for ( Pos=0;Pos<ARGC_DIR01;Pos++ )
    {
        free(ARGV_DIR01[Pos]);
    }

    vDTrazasLog(szModulo,"\tFormateaDireccion:dir_noformateada:(%s)",LOG04,dir_noformateada);

    return(rc);
}/*********************************** Final FormateaDireccion *************************************/


int bfnAcumulaMontos(ST_ACUMMTO      *AcumMto,
             double          dTotFactura,
             double          dTotalCuotas,
             double          dTotalAPagar,
             double          dTotalSaldo)
{
    char *szModulo="bfnAcumulaMontos";

    AcumMto->dTotFactura    =  AcumMto->dTotFactura  + dTotFactura;
    AcumMto->dTotCuotas     =  AcumMto->dTotCuotas   + dTotalCuotas;
    AcumMto->dTotPagar      =  AcumMto->dTotPagar    + dTotalAPagar;
    AcumMto->dTotSaldoAnt   =  AcumMto->dTotSaldoAnt + dTotalSaldo;

    vDTrazasLog (szModulo,"AcumMto->dTotFactura [%.4f] "
             "AcumMto->dTotCuotas  [%.4f] "
             "AcumMto->dTotPagar   [%.4f] "
             "AcumMto->dTotSaldoAnt[%.4f] "
             ,LOG04, AcumMto->dTotFactura
             , AcumMto->dTotCuotas, AcumMto->dTotPagar
             , AcumMto->dTotSaldoAnt);

    return(TRUE);
}/*********************************** Final bfnAcumulaMontos *************************************/

BOOL bfnInsertar_FadCTLImpres(  ST_ACUMMTO      *AcumMto,
                    LINEACOMANDO            *ParEntrada,
                    ST_INFGENERAL           *sthFa_InfGeneral,
                    char            *szNomArch
                 )
{
    EXEC SQL BEGIN DECLARE SECTION  ;
    char   szhCodInforme   [7]  ;
    long   lhNumSecuInfo        ;
    int    ihCodTipImpres       ;
    char   szhCodDespacho  [6]  ;
    char   szhNomArchivo   [255];
    long   lhNumClientes        ;
    double dhTot_Factura         ;
    double dhTot_Cuotas          ;
    double dhTot_Pagar           ;

    double dhTot_SaldoAnt        ;
    EXEC SQL END DECLARE SECTION;
    char *szModulo="bfnInsertar_FadCTLImpres";

    sprintf(szhCodInforme,"%s",szCODINFORME_GENERAR);
    lhNumSecuInfo  = ParEntrada->lNum_SecuInfo;
    ihCodTipImpres = COD_TIP_IMPRE;
    gihCodTipDocum  = ParEntrada->iCodTipDocum;
    sprintf(szhCodDespacho,"%s",ParEntrada->szCodDespacho);
    sprintf(szhNomArchivo,"%s",szNomArch);
    lhNumClientes  = (long) sthFa_InfGeneral->iContClientesProcesados;
    dhTot_Factura   = AcumMto->dTotFactura ;
    dhTot_Cuotas    = AcumMto->dTotCuotas  ;
    dhTot_Pagar     = AcumMto->dTotPagar   ;
    dhTot_SaldoAnt  = AcumMto->dTotSaldoAnt;
    ihZero = 0;

    vDTrazasLog(szModulo,"Proceso de Insercion en la FAD_CTLIMPRES(%s|%ld|%d|%d|%s|%s|%ld|%.4f|%.4f|%.4f|%.4f|)\n",
            LOG04,
            szhCodInforme,
            lhNumSecuInfo,
            ihCodTipImpres,
            gihCodTipDocum,
            szhCodDespacho,
            szhNomArchivo,
            lhNumClientes,
            dhTot_Factura,
            dhTot_Cuotas,
            dhTot_Pagar,
            dhTot_SaldoAnt
               );

    EXEC SQL INSERT
    INTO  FAD_CTLIMPRES (COD_INFORME,
             NUM_SECUINFO,
             COD_TIPIMPRES,
             COD_TIPDOCUM,
             COD_DESPACHO,
             NOM_ARCHIVO,
             NUM_CLIENTES,
             TOT_FACTURAS,
             TOT_CUOTAS,
             TOT_PAGAR,
             TOT_SALDOANT,
             TOT_LOCALES,
             TOT_INTERZONA,
             TOT_ESPECIALES,
             TOT_CARRIER,
             TOT_ROAMING,
             COD_ESTADO)
    VALUES ( :szhCodInforme,
             :lhNumSecuInfo,
             :ihCodTipImpres,
             :gihCodTipDocum,
             :szhCodDespacho,
             :szhNomArchivo,
             :lhNumClientes,
             :dhTot_Factura,
             :dhTot_Cuotas,
             :dhTot_Pagar,
             :dhTot_SaldoAnt,
             :ihZero,
             :ihZero,
             :ihZero,
             :ihZero,
             :ihZero,
             :ihZero);

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog(szModulo, "\tError en INSERT de FAD_CTLIMPRES : %s ", LOG02,  SQLERRM);
        return(FALSE);
    }

    EXEC SQL COMMIT;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog(szModulo, "\tError en COMMIT al INSERT de FAD_CTLIMPRES : %s ", LOG02, SQLERRM);
        return(FALSE);
    }

    memset(AcumMto,0,sizeof(ST_ACUMMTO));
    return(TRUE);
}/************************************ Final bfnInsertar_FadCTLImpres **********************************************/

int bfnElimina_FadCTLImpres(LINEACOMANDO *ParEntrada)
{
    char *szModulo="bfnElimina_FadCTLImpres";

    EXEC SQL DELETE FROM FAD_CTLIMPRES
    WHERE
    NUM_SECUINFO = :ParEntrada->lNum_SecuInfo AND
               COD_TIPDOCUM = :ParEntrada->iCodTipDocum  AND
               COD_DESPACHO = :ParEntrada->szCodDespacho;

    if ( SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND )
    {
        vDTrazasLog(szModulo, "\tError en DELETE de FAD_CTLIMPRES : %s ", LOG01,  SQLERRM);
        return(FALSE);
    }

    EXEC SQL COMMIT;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog(szModulo, "\tError en COMMIT al DELETE de FAD_CTLIMPRES : %s ", LOG01, SQLERRM);
        return(FALSE);
    }

    return(TRUE);
}/************************************ Final bfnElimina_FadCTLImpres **********************************************/



int ifnGetSecReproceso(long lCicloFact,long lNroJob, long lNumProceso)
{
    EXEC SQL BEGIN DECLARE SECTION;
    long lhCicloFact=lCicloFact;
    long lhNroJob=lNroJob;
    long lhNumProceso=lNumProceso;
    long lhSecReProc;
    EXEC SQL END DECLARE SECTION;

    char *szModulo="ifnGetSecReproceso";

    EXEC SQL
    SELECT NVL(MAX(SEC_REPROCESO),0)
      INTO :lhSecReProc
      FROM FA_TRAZAPROC_JOB_TO
     WHERE COD_CICLFACT = :lhCicloFact
       AND NUM_JOB      = :lhNroJob
       AND COD_PROCESO  = :lhNumProceso ;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo,"Error Al Recuperar Secuencia de Proceso Job[%ld] Ciclo[%d] Proceso[%ld]\n[%s]\n",LOG01, lCicloFact, lNroJob, lNumProceso,SQLERRM);
        return(FALSE);
    }

    return(lhSecReProc);
}


BOOL bfnUpdTrazaJob(long lCodCiclo, int iCodEstado )
{
    EXEC SQL BEGIN DECLARE SECTION      ;
    long    lhCodProceso        ;
    long    lhCodCiclo          ;
    int     ihCodEstado     ;
    char    szhGlsProceso   [50]    ;
    long    lhNroJob=lNroJob;
    int     ihSecProceso;
    EXEC SQL END DECLARE SECTION        ;

    char *szModulo="bfnUpdTrazaJob";

    lhCodProceso = COD_PROCESO;
    lhCodCiclo   = lCodCiclo;
    ihSecProceso = iSecProceso ;

    if ( iCodEstado == TRUE )
    {
        ihCodEstado  = iPROC_EST_OK ;
        strcpy(szhGlsProceso, GLS_PROCFINOK);
    }
    else
    {
        ihCodEstado  = iPROC_EST_ERR ;
        strcpy(szhGlsProceso, GLS_PROCFINNOOK);
    }
    vDTrazasLog (szModulo,"Actualizacion de FA_TRAZAPROC_JOB_TO Flag=%d -> Estado=%d [%s]",LOG02, iCodEstado, ihCodEstado, szhGlsProceso);

    EXEC SQL
    UPDATE FA_TRAZAPROC_JOB_TO
       SET COD_ESTAPROC = :ihCodEstado ,
           GLS_PROCESO  = :szhGlsProceso,
           FEC_TERMINO  = SYSDATE
    WHERE NUM_JOB      = :lhNroJob
    AND COD_PROCESO  = :lhCodProceso
    AND COD_CICLFACT = :lhCodCiclo
    AND SEC_REPROCESO= :ihSecProceso;

    vDTrazasLog(szModulo, "bfnUpdTrazaJob "
            "\nUPDATE FA_TRAZAPROC_JOB_TO           "
            "\n   SET COD_ESTAPROC = :ihCodEstado  =[%d], "
            "\n       GLS_PROCESO  = :szhGlsProceso=[%s],"
            "\n       FEC_TERMINO  = SYSDATE        "
            "\n WHERE NUM_JOB      = :lhNroJob    =[%d] "
            "\n   AND COD_PROCESO  = :lhCodProceso=[%d] "
            "\n   AND COD_CICLFACT = :lhCodCiclo  =[%d] "
            "\n   AND SEC_REPROCESO= :ihSecProceso=[%d]; ", LOG04,
            ihCodEstado, szhGlsProceso, lhNroJob, lhCodProceso, lhCodCiclo, ihSecProceso) ;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo,"Error Actualizacion de FA_TRAZAPROC_JOB_TO [%s]",LOG01, SQLERRM);
        return(FALSE);
    }

    EXEC SQL COMMIT;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo,"Error COMMIT de FA_TRAZAPROC_JOB_TO [%s]",LOG01, SQLERRM);
        return(FALSE);
    }
    return(TRUE);
}


BOOL bfnReg_Padre(LINEACOMANDO *ParEntrada)
{
    EXEC SQL BEGIN DECLARE SECTION;
	    long    lhCodProceso        ;
	    long    lhCodCiclo          ;
	    int     ihCodEstado         ;
	    char    szhGlsProceso   [50];
	    long    lhNroJob=lNroJob;
	    int     ihSecProceso;
        char    szhHostId[11]       ;
    EXEC SQL END DECLARE SECTION;

    char *szModulo="bfnReg_Padre";

    strcpy(szhHostId,szgHostId);

    lhCodProceso = COD_PROCESO;
    lhCodCiclo   = ParEntrada->lCodCiclFact;

    strcpy(szhGlsProceso, GLS_PROCINIT);

    if ( !bfnElimina_FadCTLImpres(ParEntrada) )
    {
        vDTrazasLog(szModulo,"Error en ejecucion de bfnElimina_FadCTLImpres ",LOG02);
        return(FALSE);
    }

    if ( lNroJob )
    {
        if ( iFlagSecReProc==FALSE )
        {
            iSecProceso=ifnGetSecReproceso(lhCodCiclo, lNroJob, lhCodProceso);
        }
        ihSecProceso=iSecProceso;
        if ( iSecProceso < 1 )
        {
            ihSecProceso=1;
        }

        vDTrazasLog (szModulo,"Se Recupero Secuencia de Ejecucion [%d] para Job [%ld] Ciclo [%d] Proceso [%ld].\n",LOG04, ihSecProceso, lhCodCiclo, lNroJob, lhCodProceso);

        EXEC SQL
        SELECT COD_ESTAPROC
          INTO :ihCodEstado
          FROM FA_TRAZAPROC_JOB_TO
         WHERE NUM_JOB       = :lhNroJob
           AND COD_PROCESO   = :lhCodProceso
           AND COD_CICLFACT  = :lhCodCiclo
           AND SEC_REPROCESO = :ihSecProceso
		   AND ((HOST_ID =:szhHostId) OR (1 <> :igOpcionRango));

        vDTrazasLog(szModulo, "bfnReg_Padre       "
            "\nSELECT COD_ESTAPROC "
            "\nINTO :ihCodEstado =%d "
            "\nFROM FA_TRAZAPROC_JOB_TO               "
            "\nWHERE NUM_JOB       = :lhNroJob    =%d "
            "\nAND   COD_PROCESO   = :lhCodProceso=%d "
            "\nAND   COD_CICLFACT  = :lhCodCiclo  =%d "
            "\nAND   SEC_REPROCESO = :ihSecProceso=%d;\n",LOG04,
            ihCodEstado, lhNroJob, lhCodProceso, lhCodCiclo, ihSecProceso);
    }
    else
    {
        EXEC SQL SELECT COD_ESTAPROC
        INTO :ihCodEstado
        FROM FA_TRAZAPROC
        WHERE COD_PROCESO = :lhCodProceso
          AND COD_CICLFACT = :lhCodCiclo
          AND ((HOST_ID =:szhHostId) OR (1 <> :igOpcionRango));
    }

    if ( SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND )
    {
        vDTrazasLog (szModulo,"Error en ejecucion de SELECT de bfnReg_Padre [%s]",LOG01, SQLERRM);
        return(FALSE);
    }

    if ( SQLCODE == SQLNOTFOUND )
    {

        ihCodEstado=iPROC_EST_RUN;
        if ( lNroJob )
        {
            if ( iFlagSecReProc==FALSE )
            {
            iSecProceso++;
            }
            ihSecProceso=iSecProceso;

            EXEC SQL INSERT INTO FA_TRAZAPROC_JOB_TO (NUM_JOB, COD_CICLFACT, COD_PROCESO,
                              COD_ESTAPROC, SEC_REPROCESO, FEC_INICIO, GLS_PROCESO, COD_CLIENTE, NUM_ABONADO, NUM_REGISTROS)
            VALUES (:lhNroJob, :lhCodCiclo, :lhCodProceso, :ihCodEstado, :ihSecProceso, SYSDATE,:szhGlsProceso, 0,0,0);

            vDTrazasLog(szModulo, "bfnReg_Padre 1 "
            "\nINSERT INTO FA_TRAZAPROC_JOB_TO (NUM_JOB, COD_CICLFACT, COD_PROCESO,                           "
            "\n        COD_ESTAPROC, SEC_REPROCESO, FEC_INICIO, GLS_PROCESO, COD_CLIENTE, NUM_ABONADO, NUM_REGISTROS)     "
            "\nVALUES (:lhNroJob=[%d], :lhCodCiclo=[%d], :lhCodProceso=[%d], :ihCodEstado=[%d], :ihSecProceso=[%d], SYSDATE,:szhGlsProceso=[%s], 0,0,0);\n", LOG04,
            lhNroJob, lhCodCiclo, lhCodProceso, ihCodEstado, ihSecProceso, szhGlsProceso);
        }
        else
        {
            EXEC SQL INSERT INTO FA_TRAZAPROC (COD_CICLFACT, COD_PROCESO,
                           COD_ESTAPROC, FEC_INICIO, GLS_PROCESO,
                           COD_CLIENTE, NUM_ABONADO, NUM_REGISTROS)
            VALUES (:lhCodCiclo, :lhCodProceso, :ihCodEstado, SYSDATE,:szhGlsProceso, 0,0,0);
        }

        if ( SQLCODE != SQLOK )
        {
            vDTrazasLog (szModulo,"Error en ejecucion de INSERT de bfnReg_Padre [%s]",LOG01, SQLERRM);
            return(FALSE);
        }

        EXEC SQL COMMIT;
        if ( SQLCODE != SQLOK )
        {
            vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de bfnReg_Padre [%s]",LOG01, SQLERRM);
            return(FALSE);
        }

        return(TRUE);
    }

    if ( lNroJob )
    {
        if ( ihCodEstado == iPROC_EST_OK )
        {
            if ( iFlagSecReProc==FALSE )
            {
            iSecProceso++;
            }
            ihSecProceso=iSecProceso;
            ihCodEstado=iPROC_EST_RUN;

            EXEC SQL INSERT INTO FA_TRAZAPROC_JOB_TO (NUM_JOB, COD_CICLFACT, COD_PROCESO,
                              COD_ESTAPROC, SEC_REPROCESO, FEC_INICIO, GLS_PROCESO, COD_CLIENTE, NUM_ABONADO, NUM_REGISTROS)
            VALUES (:lhNroJob, :lhCodCiclo, :lhCodProceso, :ihCodEstado, :ihSecProceso, SYSDATE,:szhGlsProceso, 0,0,0);

            vDTrazasLog(szModulo, "bfnReg_Padre 2 "
            "\nINSERT INTO FA_TRAZAPROC_JOB_TO (NUM_JOB, COD_CICLFACT, COD_PROCESO,                           "
            "\n        COD_ESTAPROC, SEC_REPROCESO, FEC_INICIO, GLS_PROCESO, COD_CLIENTE, NUM_ABONADO, NUM_REGISTROS)     "
            "\nVALUES (:lhNroJob=[%d], :lhCodCiclo=[%d], :lhCodProceso=[%d], :ihCodEstado=[%d], :ihSecProceso=[%d], SYSDATE,:szhGlsProceso=[%s], 0,0,0);\n", LOG04,
            lhNroJob, lhCodCiclo, lhCodProceso, ihCodEstado, ihSecProceso, szhGlsProceso);

            if ( SQLCODE != SQLOK )
            {
            vDTrazasLog (szModulo,"Error en ejecucion de INSERT de bfnReg_Padre [%s]",LOG01, SQLERRM);
            return(FALSE);
            }

            EXEC SQL COMMIT;
            if ( SQLCODE != SQLOK )
            {
            vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de bfnReg_Padre [%s]",LOG01, SQLERRM);
            return(FALSE);
            }
        }
        else if( iFlagSecReProc == FALSE )
        {
            vDTrazasLog (szModulo,"Error Proceso Anterior Ciclo[%d] Job[%d] Secuencia[%d] NO ha terminado Adecuadamente!\n",LOG01,lhCodCiclo,lNroJob,iSecProceso);
            return(FALSE);
        }
        return(TRUE);
    }
    if ( ihCodEstado != iPROC_EST_RUN )
    {
        ihCodEstado=iPROC_EST_RUN;
        EXEC SQL
        UPDATE FA_TRAZAPROC
        SET COD_ESTAPROC = :ihCodEstado ,
        GLS_PROCESO =  :szhGlsProceso,
        FEC_INICIO =  SYSDATE,
        FEC_TERMINO =  NULL
               WHERE COD_PROCESO = :lhCodProceso
               AND COD_CICLFACT = :lhCodCiclo;

        if ( SQLCODE != SQLOK )
        {
            vDTrazasLog (szModulo,"Error en ejecucion de UPDATE de bfnReg_Padre [%s]",LOG01, SQLERRM);
            return(FALSE);
        }
        EXEC SQL COMMIT;

        if ( SQLCODE != SQLOK )
        {
            vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de bfnReg_Padre [%s]",LOG01, SQLERRM);
            return(FALSE);
        }
    }
    else if ( !lNroJob )
    {
        if ( !bfnChequeaEstado(ParEntrada) )
        {
            vDTrazasLog(szModulo,"Falla en la ejecucion de  bfnChequeaEstado ",LOG01);
            return(FALSE);
        }
    }
    return(TRUE);
}/************************************ Final bfnReg_Padre **********************************************/

BOOL bfnActualiza_ProcImpresion(LINEACOMANDO ParEntrada, BOOL bLlave)
{
    EXEC SQL BEGIN DECLARE SECTION  ;
	    long    lhCodCiclo          ;
	    int     ihCodEstado         ;
	    char    szhglosa    [51]    ;
	    char    szhCodDespacho [6];
	    char    szhHostId[11]       ;
    EXEC SQL END DECLARE SECTION    ;

    char *szModulo="bfnActualiza_ProcImpresion";

    gihCodTipDocum   = ParEntrada.iCodTipDocum;
    lhCodCiclo      = ParEntrada.lCodCiclFact;
    strcpy(szhCodDespacho, ParEntrada.szCodDespacho);
    strcpy(szhHostId,szgHostId);

    if ( bLlave )
    {
        ihCodEstado = iPROC_EST_OK;
        strcpy(szhglosa,szPROC_EST_OK);
    }
    else
    {
        ihCodEstado = iPROC_EST_ERR;
        strcpy(szhglosa,szPROC_EST_ERR);
    }
    EXEC SQL
    UPDATE FA_PROCIMPRESION_TD
       SET COD_ESTAPROC = :ihCodEstado ,
           FEC_TERMINO  = SYSDATE,
           GLS_ESTAPROC = :szhglosa
     WHERE COD_CICLFACT = :lhCodCiclo
       AND COD_TIPDOCUM = :gihCodTipDocum
       AND COD_DESPACHO = :szhCodDespacho
       AND ((HOST_ID =:szhHostId) OR (1 <> :igOpcionRango));

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo,"Error en ejecucion de UPDATE de bfnActualiza_ProcImpresion\n[%s]\n[ihCodEstado] = [%d]\n[szhglosa] = [%s]\n[lhCodCiclo] = [%ld]\n[gihCodTipDocum] = [%d]\n[szhCodDespacho] = [%s]\n[szhHostId] = [%s]\n[igOpcionRango] = [%d]\n"
            ,LOG01, SQLERRM,ihCodEstado,szhglosa,lhCodCiclo,gihCodTipDocum,szhCodDespacho,szhHostId,igOpcionRango);
        return(FALSE);
    }
    else
    {
        EXEC SQL COMMIT;
        if ( SQLCODE != SQLOK )
        {
            vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de bfnActualiza_ProcImpresion\n[%s]",LOG01,SQLERRM);
            return(FALSE);
        }
    }
    return(TRUE);
}/************************************ Final bfnActualiza_ProcImpresion **********************************************/

BOOL bfnActualiza_TrazaProceso(LINEACOMANDO ParEntrada,BOOL bLlave)
{
    int     NroRegsProcImp;
    int     i;
    int     TotalEstados=5;

    EXEC SQL BEGIN DECLARE SECTION  ;
	    int     ihCod_Estaproc  [MAX_TRAZAPROC];
	    int     ihCod_Estado  ;
	    char    szhCodDespacho[6];
	    long    lhCodCiclo;
	    long    lhCodProceso;
	    char    szhGlsProceso[50];
	    char    szhHostId[11]    ;
    EXEC SQL END DECLARE SECTION    ;

    int contador_estados[5];
    char *szModulo="bfnActualiza_TrazaProceso";

    vDTrazasLog(szModulo, "\tEntro a %s", LOG04,szModulo);

    lhCodCiclo      = ParEntrada.lCodCiclFact;
    lhCodProceso    = COD_PROCESO;
    strcpy(szhCodDespacho, ParEntrada.szCodDespacho);
    strcpy(szhHostId,szgHostId);

    if ( lhCodCiclo )
    {
        EXEC SQL
        SELECT COD_ESTAPROC
          INTO :ihCod_Estaproc
          FROM FA_PROCIMPRESION_TD
         WHERE COD_CICLFACT = :lhCodCiclo
           AND ((HOST_ID =:szhHostId) OR (1 <> :igOpcionRango));

        NroRegsProcImp = sqlca.sqlerrd[2];
        vDTrazasLog(szModulo, "query retorno registros SQLCODE(%d)NroRegsProcImp(%d)", LOG04,SQLCODE,NroRegsProcImp);

        if ( SQLCODE < SQLOK && NroRegsProcImp<=0 )
        {
            vDTrazasLog(szModulo, "Error en ejecucion del SELECT [%d][%s]", LOG00, SQLCODE,SQLERRM);
            return(FALSE);
        }

        for ( i=0;i<TotalEstados;i++ )
        {
            contador_estados[i]=0;
        }

        for ( i=0; i < NroRegsProcImp; i++ )
        {
            contador_estados[ihCod_Estaproc[i]]++;
        }

        /*ya no hay procesos sin ejecutarse o ejecutandose*/

        if ( !(contador_estados[0]>0 || contador_estados[iPROC_EST_RUN]>0) )
        {
            if ( contador_estados[iPROC_EST_ERR]>0 )
            {
            /*existen procesos que terminaron en error*/
            ihCod_Estado=iPROC_EST_ERR;
            strcpy(szhGlsProceso, GLS_PROCFINNOOK);
            vDTrazasLog (szModulo,"Existen subproceso terminados con error\n",LOG04);
            }
            else
            {
            /*todos procesos terminaron ok*/
            ihCod_Estado=iPROC_EST_OK;
            strcpy(szhGlsProceso, GLS_PROCFINOK);
            vDTrazasLog (szModulo,"todos los subprocesos terminaron y bien\n",LOG04);
            }

            EXEC SQL
            UPDATE FA_TRAZAPROC
            SET COD_ESTAPROC = :ihCod_Estado
            , FEC_TERMINO  = SYSDATE
            , GLS_PROCESO  = :szhGlsProceso
                 WHERE COD_CICLFACT = :lhCodCiclo
                 AND COD_PROCESO  = :lhCodProceso;

            if ( SQLCODE != SQLOK )
            {
            vDTrazasLog (szModulo,"Error en ejecucion de UPDATE de bfnActualiza_TrazaProceso\n[%s]",LOG01,SQLERRM);
            return(FALSE);
            }

            EXEC SQL COMMIT;

            if ( SQLCODE != SQLOK )
            {
            vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de bfnActualiza_TrazaProceso\n[%s]",LOG01,SQLERRM);
            return(FALSE);
            }
        }
        else
        {
            vDTrazasLog (szModulo,"Existe subproceso corriendo o por correr\n",LOG03);
        }
    }
    else
    {
        if ( !bLlave )
        {
            ihCod_Estado=iPROC_EST_ERR;

            vDTrazasLog (szModulo,"ejecucion de UPDATE de FA_INTERFACT por num_proceso",LOG04);
            EXEC SQL
            UPDATE FA_INTERFACT
            SET COD_ESTADOC=:ParEntrada.iCodSalida
            , COD_ESTPROC = :ihCod_Estado
                WHERE NUM_PROCESO = :ParEntrada.lProceso;

            if ( SQLCODE != SQLOK )
            {
            vDTrazasLog (szModulo,"Error en ejecucion de UPDATE de FA_INTERFACT\n[%s]",LOG01,SQLERRM);
            return(FALSE);
            }
        }
        else
        {
            ihCod_Estado=iPROC_EST_OK;
        }
        EXEC SQL COMMIT;

        if ( SQLCODE != SQLOK )
        {
            vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de FA_INTERFACT\n[%s]",LOG01,SQLERRM);
            return(FALSE);
        }
    }
    return(TRUE);

}/************************************ Final bfnActualiza_TrazaProceso **********************************************/


BOOL bfnChequeaEstado (LINEACOMANDO *ParEntrada)
{
    EXEC SQL BEGIN DECLARE SECTION;
	    int     ihCod_Estaproc   ;
	    char    szhCodDespacho[6];
	    long    lhCodCiclo       ;
        char    szhHostId[11]    ;
    EXEC SQL END DECLARE SECTION;

    char *szModulo="bfnChequeaEstado";

    lhCodCiclo      = ParEntrada->lCodCiclFact;
    strcpy(szhCodDespacho, ParEntrada->szCodDespacho);
    gihCodTipDocum   = ParEntrada->iCodTipDocum;
    strcpy(szhHostId,szgHostId);

    EXEC SQL
    	SELECT COD_ESTAPROC
    	  INTO :ihCod_Estaproc
    	  FROM FA_PROCIMPRESION_TD
    	 WHERE COD_CICLFACT  = :lhCodCiclo
           AND COD_DESPACHO  = :szhCodDespacho
           AND COD_TIPDOCUM  = :gihCodTipDocum
           AND ((HOST_ID =:szhHostId) OR (1 <> :igOpcionRango));

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog(szModulo, "Error en SELECT de bfnChequeaEstado [%d]\n[%s]", LOG02, SQLCODE,SQLERRM);
        return(FALSE);
    }
    if ( ihCod_Estaproc == 1 )
    {
        vDTrazasLog(szModulo, "Estado del proceso : En Proceso. El proceso actual se aborta", LOG01);
        return(FALSE);
    }

    return(TRUE);

}/********************* Final bfnChequeaEstado ****************************/


BOOL bfnActualizaRegprocImpres (LINEACOMANDO ParEntrada)
{
    EXEC SQL BEGIN DECLARE SECTION;
	    int     ihCod_Estaproc     ;
	    char    szhCodDespacho  [6];
	    char    szhglosa    [51]   ;
	    long    lhCodCiclo         ;
        char    szhHostId[11]      ;
   EXEC SQL END DECLARE SECTION;

    char *szModulo="bfnActualizaRegprocImpres";

    lhCodCiclo = ParEntrada.lCodCiclFact;
    strcpy(szhCodDespacho, ParEntrada.szCodDespacho);
    gihCodTipDocum   = ParEntrada.iCodTipDocum;
    strcpy(szhHostId,szgHostId);

    EXEC SQL
    	SELECT COD_ESTAPROC
    	  INTO :ihCod_Estaproc
    	  FROM FA_PROCIMPRESION_TD
    	 WHERE COD_CICLFACT = :lhCodCiclo
       	   AND COD_TIPDOCUM = :gihCodTipDocum
       	   AND COD_DESPACHO = :szhCodDespacho
           AND ((HOST_ID =:szhHostId) OR (1 <> :igOpcionRango));

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog(szModulo, "Error en SELECT de bfnActualizaRegprocImpres [%d]\n[%s]", LOG02, SQLCODE,SQLERRM);
        return(FALSE);
    }

    if ( ihCod_Estaproc == 1 )
    {
        vDTrazasLog (szModulo, "Estado del proceso : En Proceso. Proceso nuevo se aborta", LOG01);
        return(FALSE);
    }

    ihCod_Estaproc=iPROC_EST_RUN;
    strcpy(szhglosa,szPROC_EST_RUN);

    EXEC SQL
    	UPDATE FA_PROCIMPRESION_TD
    	   SET COD_ESTAPROC = :ihCod_Estaproc ,
    		   GLS_ESTAPROC = :szhglosa ,
    		   FEC_INICIO   = SYSDATE
         WHERE COD_CICLFACT = :lhCodCiclo
           AND COD_TIPDOCUM = :gihCodTipDocum
           AND COD_DESPACHO = :szhCodDespacho
           AND ((HOST_ID =:szhHostId) OR (1 <> :igOpcionRango));

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo,"Error en ejecucion de UPDATE de bfnActualizaRegprocImpres\n[%s]",LOG01,SQLERRM);
        return(FALSE);
    }
    else
    {
        EXEC SQL COMMIT;
        if ( SQLCODE != SQLOK )
        {
            vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de bfnActualizaRegprocImpres\n[%s]",LOG01,SQLERRM);
            return(FALSE);
        }
    }

    return(TRUE);
}/************************************ Final bfnActualizaRegprocImpres **********************************************/


/****************************************************************************/
/*  Funcion: int ObtieneIdiomaOperadora                         */
/*  Funcion que Obtiene el Idioma de la Operadora               */
/****************************************************************************/
int ObtieneIdiomaOperadora(ST_INFGENERAL *sthFa_InfGeneral)
{
    sprintf(sthFa_InfGeneral->szIdiomaOper ,"%-1.1s\0",szhIdiomaOper);

    return(TRUE);
}/****************Final de ObtieneIdiomaOperadora *******************/


/****************************************************************************/
/*  Funcion: int iGetMensajesNoCiclo                    */
/*  Funcion que Obtiene los mensajes para documentos no ciclicos            */
/****************************************************************************/
int iGetMensajesNoCiclo(ST_MENSAJES_NOCICLO * stFaMensajes_NoCiclo,long lNumProceso)
{
    int  iSqlMensNoCiclo ;

    char *szModulo="iGetMensajesNoCiclo";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    iSqlMensNoCiclo = Open_MensNoCiclo(lNumProceso);

    if ( iSqlMensNoCiclo == SQLOK )
    {
        iSqlMensNoCiclo = Fetch_MensNoCiclo( stFaMensajes_NoCiclo );

        if ( iSqlMensNoCiclo == SQLOK && stFaMensajes_NoCiclo->iCantLineas >= MAX_LINEAS_MENSAJES )
        {
            vDTrazasLog  (szModulo,"\t\tMensajes No Ciclo Sobrepaso Maximo Posible" ,LOG01);
            vDTrazasError(szModulo,"\t\tMensajes No Ciclo Sobrepaso Maximo Posible" ,LOG01);
            return(FALSE);
        }
    }
    if ( (iSqlMensNoCiclo != SQLOK) && (iSqlMensNoCiclo != SQLNOTFOUND) )
    {
        vDTrazasError(szModulo, "\t\t Error Oracle   [%s]",LOG01, SQLERRM);
        vDTrazasLog(szModulo,   "\t\t Error Oracle   [%s]",LOG01, SQLERRM);
        return(FALSE);
    }
    if ( !Close_MensNoCiclo() ) return(FALSE);

    /****************************************************/
    /* Cantidad de Mensajes no ciclo            */
    vDTrazasLog(szModulo,"\t====> Cantidad de Mensajes no ciclo [%d]",LOG04,stFaMensajes_NoCiclo->iCantLineas);

    return(TRUE);
}/************************* Fin GetMensajesNoCiclo *************************/


int Open_MensNoCiclo ( long lNumeroProc )
{
    char *szModulo="Open_MensNoCiclo";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    lhNumAbonado= lNumeroProc; /* variagle global */

    EXEC SQL OPEN curMensNoCiclo;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-OPEN CURSOR curMensNoCiclo **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-OPEN CURSOR curMensNoCiclo **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
    }
    return(SQLCODE);
}/*********************** Final de Open_MensNoCiclo ***********************/

/****************************************************************************/
/* Funcion: int Fetch_MensNoCiclo              */
/* Funcion que realiza Fetch en el cursor de curMensNoCiclo             */
/****************************************************************************/
int Fetch_MensNoCiclo (ST_MENSAJES_NOCICLO * pstFaMensajes_NoCiclo)
{
    char *szModulo="Fetch_MensNoCiclo";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL
    FETCH curMensNoCiclo
    INTO :pstFaMensajes_NoCiclo->szMensajes ;

    if ( (SQLCODE == SQLOK) && (SQLCODE != SQLNOTFOUND) )
        vDTrazasError(szModulo,"\t\tError en Fetch %s : %s", LOG01, szModulo, SQLERRM);
    else
        pstFaMensajes_NoCiclo->iCantLineas = sqlca.sqlerrd[2];

    return(SQLCODE);
}/*************************** Final de Fetch_MensNoCiclo ***************************/

/****************************************************************************/
/*  Funcion: int Close_MensNoCiclo(void)                        */
/*  Funcion que cierra el cursor de curMensNoCiclo              */
/****************************************************************************/

int Close_MensNoCiclo(void)
{
    char *szModulo="Close_MensNoCiclo";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL CLOSE curMensNoCiclo;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasError(szModulo,"\tError al cerrar el Cursor curMensNoCiclo: %s",LOG01, SQLERRM);
        return (FALSE);
    }
    return (TRUE);
}

/****************Final de Close_MensNoCiclo *******************/

/****************************************************************************/
/*  Funcion: int BuscaMascara                           */
/*  Funcion que busca un Registro de la mascara                 */
/****************************************************************************/
BOOL BuscaMascara(DETALLEOPER *pstMascaraOper, char *szCodRegistro, int iTipDocum)
{
    register int x,iIndTipReg;

    char *szModulo="BuscaMascara";

    vDTrazasLog(szModulo,"\tEntrando a %s registro [%s]",LOG04,szModulo, szCodRegistro);

    switch(szCodRegistro[0]) /* primer caracter del codigo de registro */
    {
		case 'A':  /* caratula */
            iIndTipReg = 0;
        	break;
        case 'B':  /* abonados */
            iIndTipReg = 1;
            break;
        case 'D':  /* detalle de llamadas */
            iIndTipReg = 2;
            break;
    }

    vDTrazasLog(szModulo,"=> CODIGO[%s] Num_Registros [%d] Tipo Documento [%d] Tipo Ciclo [%d] Tipo Registro [%d]"
    					, LOG06, szCodRegistro
    					,pstMascaraOper->iMaxRegImp[iIndTipReg]
    					,iTipDocum
    					,iIndTipReg);

    for ( x=0; x < pstMascaraOper->iMaxRegImp[iIndTipReg] ; x++ )
    {
        vDTrazasLog(szModulo,"=> CODIGO Posicion [%d][%d][%s][%s]", 
        			LOG06,iIndTipReg,x, pstMascaraOper->szCodRegistro [iIndTipReg][x],
        			pstMascaraOper->szCodTipDocum [iIndTipReg][x]);
        if ( (strcmp(szCodRegistro,pstMascaraOper->szCodRegistro [iIndTipReg][x]) == 0) &&
             (iTipDocum == atoi (pstMascaraOper->szCodTipDocum [iIndTipReg][x])))
        {
            vDTrazasLog(szModulo,"=> CODIGO ENCONTRADO Posicion [%d][%d] ", LOG06,iIndTipReg,x);
            return(TRUE);
        }
    }

    vDTrazasLog(szModulo,"NO ENCONTRADO ", LOG04);
    return(FALSE);
}/****************Final de BuscaMascara *******************/


int BuscaCodInterfact(long lNumProceso,long lNumSecuencia,LINEACOMANDO *pst_ParamEntrada)
{
    EXEC SQL BEGIN DECLARE SECTION;
    varchar szCodAplic[4];
    varchar szCodModGener[4];
    EXEC SQL END DECLARE SECTION;

    int  iCodEstadoSal;
    int  iCodEstadoEnt;
    int  iCodInterfact;

    char *szModulo="BuscaCodInterfact";

    vDTrazasLog(szModulo,"\tEntrando a %s  lNumProceso [%ld]",LOG04,szModulo,lNumProceso);

    iCodInterfact = COD_INTERFACT;
    if ( lNumProceso )
    {
        EXEC SQL SELECT COD_MODGENER,COD_APLIC
        INTO :szCodModGener,:szCodAplic
        FROM FA_INTERFACT
        WHERE NUM_PROCESO =:lNumProceso;

        if ( SQLCODE != SQLOK )
        {
            vDTrazasLog(szModulo, "Error en SELECT de FA_INTERFACT [%d]\n[%s]", LOG02, SQLCODE,SQLERRM);
            return(FALSE);
        }
    }
    else
    {
        EXEC SQL SELECT DISTINCT COD_MODGENER,COD_APLIC
        INTO :szCodModGener,:szCodAplic
        FROM FA_INTERFACT
        WHERE NUM_PROCESO IN ( SELECT NUM_PROCESO
                     FROM FA_PROCIMPRESLOTE_TD
                    WHERE NUM_SECUENCIAL = :lNumSecuencia
                 );

        if ( SQLCODE != SQLOK )
        {
            vDTrazasLog(szModulo, "Error en SELECT de FA_PROCIMPRESLOTE_TD [%d]\n[%s]", LOG02, SQLCODE,SQLERRM);
            return(FALSE);
        }
    }


    EXEC SQL SELECT COD_ESTADOC_ENT,COD_ESTADOC_SAL
    INTO :iCodEstadoEnt,:iCodEstadoSal
    FROM FA_INTQUEUEPROC
    WHERE COD_MODGENER=:szCodModGener
      AND COD_PROCESO = :iCodInterfact
      AND COD_APLIC   = :szCodAplic;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog(szModulo, "Error en SELECT de FA_INTQUEUEPROC [%d]\n[%s]", LOG02, SQLCODE,SQLERRM);
        return(FALSE);
    }

    pst_ParamEntrada->iCodEntrada = iCodEstadoEnt;
    pst_ParamEntrada->iCodSalida  = iCodEstadoSal;

    return(TRUE);
}/****************Final de BuscaCodInterfact *******************/

int ChequeaInterfact(LINEACOMANDO pst_ParamEntrada)
{
    int  iCodEstaRun;
    int  iCodEstaOk;
    int  iCantProc;

    char *szModulo="ChequeaInterfact";

    vDTrazasLog(szModulo,"\tEntrando a %s numero de proceso [%ld]"
    					,LOG04,szModulo,pst_ParamEntrada.lProceso);

    iCodEstaOk  = iPROC_EST_OK;

    EXEC SQL SELECT COUNT(1)
    INTO :iCantProc
    FROM FA_INTERFACT
    WHERE NUM_PROCESO = :pst_ParamEntrada.lProceso
      AND COD_ESTADOC = :pst_ParamEntrada.iCodEntrada
      AND COD_ESTPROC = :iCodEstaOk;

    if ( !iCantProc )
    {
        vDTrazasLog (szModulo,"numero de proceso [%ld] No esta en el estado correcto de ejecucion ",LOG04,pst_ParamEntrada.lProceso);
        return(FALSE);
    }

    vDTrazasLog (szModulo,"Entro por numero de proceso [%ld]",LOG04,pst_ParamEntrada.lProceso);

    iCodEstaRun = iPROC_EST_RUN;

    EXEC SQL UPDATE FA_INTERFACT
            SET COD_ESTADOC = :pst_ParamEntrada.iCodSalida, 
            COD_ESTPROC = :iCodEstaRun
              WHERE NUM_PROCESO = :pst_ParamEntrada.lProceso;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo,"Error en ejecucion de UPDATE de FA_INTERFACT [%d][%s]",LOG01,SQLCODE, SQLERRM);
        return(FALSE);
    }
    EXEC SQL COMMIT;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de FA_INTERFACT [%d][%s]",LOG01,SQLCODE, SQLERRM);
        return(FALSE);
    }
    return(TRUE);
}

int OpenDetArrastre ( long lCodCiclFact )
{
    char *szModulo="OpenDetArrastre";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    lhCodCilclFact= lCodCiclFact;
    strcpy (szhStrCodCliente, "09999999");

    EXEC SQL OPEN curArrastre;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-OPEN CURSOR curArrastre **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-OPEN CURSOR curArrastre **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
    }
    return(SQLCODE);
}/*********************** Final de OpenDetArrastre ***********************/

/****************************************************************************/
int FetchDetArrastre ( void )
{
    char *szModulo="FetchDetArrastre";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL
    FETCH curArrastre
    INTO :sthCurArrastre.lCodCliente,
    :sthCurArrastre.lNumAbonado,
    :sthCurArrastre.szCodBolsa,
    :sthCurArrastre.dValBolsa,
    :sthCurArrastre.szIndUnidad,
    :sthCurArrastre.dValArrastre,
    :sthCurArrastre.dValExpirado,
    :sthCurArrastre.dValDisponible,
    :sthCurArrastre.dValConsumo,
    :sthCurArrastre.dValResto,
    :sthCurArrastre.szLlaveArrastre;

    if ( (SQLCODE != SQLOK) && (SQLCODE != SQLNOTFOUND) )
    {
        vDTrazasError(szModulo,"\t\tError en Fetch FetchDetArrastre : %s", LOG01, SQLERRM);
        return(SQLCODE);
    }
    sthCurArrastre.iCantidadArrastre = sqlca.sqlerrd[2];
    return(SQLCODE);
}
/*************************** Final de FetchDetArrastre ***************************/

/****************************************************************************/
int CloseDetArrastre(void)
{
    char *szModulo="CloseDetArrastre";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL CLOSE curArrastre;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasError(szModulo,"\tError al cerrar el Cursor Arrastre: %s",LOG01, SQLERRM);
        return (FALSE);
    }
    return (TRUE);
}
/****************Final de CloseDetArrastre *******************/


/****************************************************************************/

/* SAAM-20040116 se modifica definicin funcin para que reciba el cdigo de ciclo de facturacion como parametro, proyecto TMM_DEIMP_03020 */
/* int CargaArrastre( void ) */
int CargaArrastre( long lhCodCiclFact )
{
    int  iSqlDetArrastre,i,j;
    int   rows_to_fetch  = MAX_ARRASTRE_CURSOR;  /* number of rows in each "batch" */
    int   rows_before    =  0;  /* previous value of sqlerrd[2] */
    int   rows_this_time = MAX_ARRASTRE_CURSOR;

    char *szModulo="CargaArrastre";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    iSqlDetArrastre = OpenDetArrastre(lhCodCiclFact);

    if ( iSqlDetArrastre == SQLOK )
    {
        while ( rows_this_time == rows_to_fetch )
        {
            iSqlDetArrastre = FetchDetArrastre();
            if ( (iSqlDetArrastre != SQLOK)&&(iSqlDetArrastre != SQLNOTFOUND) )
            {
            vDTrazasError(szModulo,"\t\tError en Fetch FetchDetArrastre : %s", LOG01, SQLERRM);
            return(SQLCODE);
            }

            j=0;
            for ( i=rows_before;i<sthCurArrastre.iCantidadArrastre ;i++ )
            {
            sthDetArrastre.lCodCliente[i]           = sthCurArrastre.lCodCliente[j];
            sthDetArrastre.lNumAbonado[i]           = sthCurArrastre.lNumAbonado[j];
            strcpy(sthDetArrastre.szCodBolsa[i]     , sthCurArrastre.szCodBolsa[j]);
            sthDetArrastre.dValBolsa[i]             = sthCurArrastre.dValBolsa[j];
            strcpy(sthDetArrastre.szIndUnidad[i]    , sthCurArrastre.szIndUnidad[j]);
            sthDetArrastre.dValArrastre[i]          = sthCurArrastre.dValArrastre[j];
            sthDetArrastre.dValExpirado[i]          = sthCurArrastre.dValExpirado[j];
            sthDetArrastre.dValDisponible[i]        = sthCurArrastre.dValDisponible[j];
            sthDetArrastre.dValConsumo[i]           = sthCurArrastre.dValConsumo[j];
            sthDetArrastre.dValResto[i]             = sthCurArrastre.dValResto[j];
            strcpy(sthDetArrastre.szLlaveArrastre[i], sthCurArrastre.szLlaveArrastre[j]);
            j++;
            }
            sthDetArrastre.iCantidadArrastre = i;
            if ( sthDetArrastre.iCantidadArrastre > MAX_ARRASTRE_ESTRUCTURA )
            {
            vDTrazasLog  (szModulo,"\t\tDetArrastre Sobrepaso Maximo Posible" ,LOG01);
            vDTrazasError(szModulo,"\t\tDetArrastre Sobrepaso Maximo Posible" ,LOG01);
            return(FALSE);
            }
            rows_this_time = sthCurArrastre.iCantidadArrastre - rows_before;
            rows_before = sthCurArrastre.iCantidadArrastre;
            vDTrazasLog(szModulo,"\t[%d]-[%d]-[%d]",LOG05,rows_this_time,rows_before,rows_to_fetch);
        }
    }
    if ( (iSqlDetArrastre != SQLOK) && (iSqlDetArrastre != SQLNOTFOUND) )
    {
        vDTrazasError(szModulo, "\t\t Error Oracle   [%s]",LOG01, SQLERRM);
        vDTrazasLog(szModulo,   "\t\t Error Oracle   [%s]",LOG01, SQLERRM);
        return(FALSE);
    }
    if ( !CloseDetArrastre() ) return(FALSE);
    return(TRUE);
}/************************* Fin CargaArrastre *************************/

int Busca_RangoCliente(int iPosicion,int *iInicio,int *iTermino,int iFin)
{
    int iIndice;
    char szllave[17];
    char *szModulo="Busca_RangoCliente";

    iIndice = iPosicion;
    sprintf(szllave,"%s",sthDetArrastre.szLlaveArrastre[iPosicion]);
    vDTrazasLog(szModulo,"Busca_RangoCliente ENTRADA \t iIndice(%d) >= 0 && *iInicio(%d) == 0  Termino=%d Fin=%d llave=[%s]\n",LOG06,iIndice, *iInicio, *iTermino,iFin,szllave); /* P-TMM-03075 Por Homologacin TM-200410241013*/
    while ( iIndice >= 0 && *iInicio == 0 )
    {
        if ( strcmp(szllave,sthDetArrastre.szLlaveArrastre[iIndice])==0 )
        {
            sprintf(szllave,"%s",sthDetArrastre.szLlaveArrastre[iIndice]);
            iIndice --;
        }
        else
        {
            *iInicio = iIndice+1; break;
        }                           /* P-TMM-03075 Por Homologacin TM-200410241013*/
    }
    if ( iIndice < 0 ) *iInicio = 0;

    iIndice = iPosicion;
    sprintf(szllave,"%s",sthDetArrastre.szLlaveArrastre[iPosicion]);
    vDTrazasLog(szModulo,"Busca_RangoCliente 2\tindice=%d Inicio=%d Termino=%d Fin=%d llave=[%s]\n",LOG06,iIndice,*iInicio,*iTermino,iFin,szllave); /* P-TMM-03075 Por Homologacin TM-200410241013*/
    while ( iIndice < iFin && *iTermino == 0 )
    {
        if ( strcmp(szllave,sthDetArrastre.szLlaveArrastre[iIndice])==0 )
        {
            sprintf(szllave,"%s",sthDetArrastre.szLlaveArrastre[iIndice]);
            iIndice ++;
        }
        else
        {
            *iTermino = iIndice-1; break;
        }                          /* P-TMM-03075 Por Homologacin TM-200410241013*/
    }
    if ( iIndice >= iFin ) *iTermino = iFin-1;

    vDTrazasLog(szModulo,"Busca_RangoCliente SALIDA \tindice=%d Inicio=%d Termino=%d\n",LOG06,iIndice,iInicio,iTermino); /* P-TMM-03075 Por Homologacin TM-200410241013*/

    return(TRUE);
}/****************Final de Busca_RangoCliente ******************************************/

int BuscaCliente(char *szllave,int derecha)
{
    int centro;
    int izquierda;

    izquierda = 0;
    while ( izquierda <= derecha )
    {
        centro = (izquierda + derecha) / 2;
        if ( strcmp(szllave,sthDetArrastre.szLlaveArrastre[centro])<0 )
        {
            derecha = centro - 1;
        }
        else
        {
            if ( strcmp(szllave,sthDetArrastre.szLlaveArrastre[centro])>0 )
            {
            izquierda = centro + 1;
            }
            else
            {
            return(centro);
            }
        }
    }
    return(-1);
}/****************Final de BuscaCliente *******************/

int busca_arrastre(char *szllave,int *iInicio,int *iTermino)
{
    int iPosicionCliente;
    long lderecha;
    char *szModulo="busca_arrastre";

    lderecha = sthDetArrastre.iCantidadArrastre;
    vDTrazasLog(szModulo,"busca_arrastre ENTRADA \tCliente [%s] derecha=%ld",LOG06,szllave,lderecha);
    iPosicionCliente = BuscaCliente(szllave,lderecha);

    if ( iPosicionCliente != -1 )
    {
        vDTrazasLog(szModulo,"busca_arrastre 1\tPosicion del Cliente [%s] es [%d]",LOG06,szllave,iPosicionCliente);
        *iInicio=0;
        *iTermino=0;
        if ( !Busca_RangoCliente(iPosicionCliente,iInicio,iTermino,lderecha) )
        {
            vDTrazasLog(szModulo,"busca_arrastre\tCliente [%s] sin Arrastre ",LOG05,szllave);
            return(FALSE);
        }
        vDTrazasLog(szModulo,"busca_arrastre 2\tPosicion del Cliente [%s] es [%d]  Inicio=%d Termino=%d",LOG06,szllave,iPosicionCliente, *iInicio, *iTermino);
    }
    else
    {
        vDTrazasLog(szModulo,"busca_arrastre\tCliente [%s] sin Arrastre ",LOG06,szllave);
        return(FALSE);
    }
    vDTrazasLog(szModulo,"busca_arrastre SALIDA \tInicio=%d Termino=%d\n",LOG06,*iInicio, *iTermino); /* P-TMM-03075 Por Homologacin TM-200410241013*/
    return(TRUE);
}/****************Final de busca_arrastre *******************/


int CargaFadParametros( void )
{
    int i,j;
    char szTipParametro[7];
    char szCodModulo[3];
    char szValCaracter[2];

    char *szModulo="CargaFadParametros";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    ihZero = 0;
    strcpy(szTipParametro,"NUMBER");
    strcpy(szCodModulo,"FA");
    strcpy(szValCaracter,"0");

    EXEC SQL
    SELECT COD_PARAMETRO,
    DES_PARAMETRO,
    NVL(TIP_PARAMETRO,:szTipParametro),
    NVL(VAL_NUMERICO,:ihZero),
    NVL(VAL_CARACTER,:szValCaracter),
    NVL(VAL_FECHA,SYSDATE),
    vsize(NVL(VAL_CARACTER,:szValCaracter))
    INTO :sthFadParametros
    FROM FAD_PARAMETROS
    WHERE COD_MODULO= :szCodModulo
              ORDER BY COD_MODULO,COD_PARAMETRO;

    if ( ((SQLCODE != SQLOK) && (SQLCODE != SQLNOTFOUND)) || (sqlca.sqlerrd[2]==0) )
    {
        vDTrazasLog(szModulo, "Error en SELECT de FAD_PARAMETROS [%d]\n[%s]", LOG02, SQLCODE,SQLERRM);
        return(FALSE);
    }

    for ( i = 1;i <= sqlca.sqlerrd[2];i++ )
    {
        j = sthFadParametros.cod_parametro[sqlca.sqlerrd[2]-i];
        sthFadParametros.cod_parametro[j] = sthFadParametros.cod_parametro[sqlca.sqlerrd[2]-i];
        strcpy(sthFadParametros.des_parametro[j], sthFadParametros.des_parametro[sqlca.sqlerrd[2]-i]);
        strcpy(sthFadParametros.tip_parametro[j], sthFadParametros.tip_parametro[sqlca.sqlerrd[2]-i]);
        sthFadParametros.val_numerico[j] = sthFadParametros.val_numerico[sqlca.sqlerrd[2]-i];
        strcpy(sthFadParametros.val_caracter[j], sthFadParametros.val_caracter[sqlca.sqlerrd[2]-i]);
        strcpy(sthFadParametros.val_fecha[j], sthFadParametros.val_fecha[sqlca.sqlerrd[2]-i]);
        sthFadParametros.val_cantidad[j] = sthFadParametros.val_cantidad[sqlca.sqlerrd[2]-i];

        sthFadParametros.cod_parametro[sqlca.sqlerrd[2]-i] = 0;
        memset(sthFadParametros.des_parametro[sqlca.sqlerrd[2]-i],0,sizeof(sthFadParametros.des_parametro[sqlca.sqlerrd[2]-i]));
        memset(sthFadParametros.tip_parametro[sqlca.sqlerrd[2]-i],0,sizeof(sthFadParametros.tip_parametro[sqlca.sqlerrd[2]-i]));
        sthFadParametros.val_numerico[sqlca.sqlerrd[2]-i] = 0;
        memset(sthFadParametros.val_caracter[sqlca.sqlerrd[2]-i],0,sizeof(sthFadParametros.val_caracter[sqlca.sqlerrd[2]-i]));
        memset(sthFadParametros.val_fecha[sqlca.sqlerrd[2]-i],0,sizeof(sthFadParametros.val_fecha[sqlca.sqlerrd[2]-i]));
        sthFadParametros.val_cantidad[sqlca.sqlerrd[2]-i] = 0;
    }
    return(TRUE);
}
/***********************************************************************************/
int GargaGedParametros( void )
{
    /* Modificacin Proyecto Ecu-05002 Codigo de Autorizacin.
      Se agrega SQL para obtener el campo para saber si aplica el codigo de autorizacion. Las variables
del select into estan definidas en el ImpSclSt.h. Se modifica el SQL para que en este mismo se rescate el valor
de la tabla y saber si aplica el cod autirizacion (se agrega alias F para ged_parametros).
    */

    char *szModulo="GargaGedParametros";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    strcpy(szhFormato_Hora,"HH24MISS");
    strcpy(szhFormato_Fecha,"YYYYMMDD");
    ihUno = 1;


    EXEC SQL
    SELECT NVL(A.VAL_PARAMETRO,:szhFormato_Hora),
    NVL(B.VAL_PARAMETRO,:szhFormato_Fecha),
    SUBSTR(C.VAL_PARAMETRO,1,5) ,
    D.VAL_PARAMETRO,
    E.COD_ABONOCEL,
    F.VAL_PARAMETRO
    INTO :szformato_hora,:szformato_fecha,:szhIdiomaOper,:szNumDecimal,:iCodAbonoCel,
    :szAplica_Cod_Autorizacion
    FROM GED_PARAMETROS A,GED_PARAMETROS B,GED_PARAMETROS C,GED_PARAMETROS D, FA_DATOSGENER E,
    GED_PARAMETROS F
    WHERE A.COD_MODULO = 'GE'   AND A.COD_PRODUCTO= :ihUno
             AND A.NOM_PARAMETRO ='FORMATO_SEL20'
             AND B.COD_MODULO= 'GE'   AND B.COD_PRODUCTO= :ihUno
             AND B.NOM_PARAMETRO ='FORMATO_SEL6'
             AND C.COD_MODULO= 'GE'   AND C.COD_PRODUCTO= :ihUno
             AND C.NOM_PARAMETRO ='IDIOMA_LOCAL'
             AND D.COD_MODULO= 'GE'   AND D.COD_PRODUCTO= :ihUno
             AND D.NOM_PARAMETRO ='NUM_DECIMAL'
             AND F.NOM_PARAMETRO = 'APLICA_CODAUTORIZA'
             AND F.COD_MODULO = 'FA'
             AND F.COD_PRODUCTO = :ihUno;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog(szModulo, "Error en SELECT de GED_PARAMETROS [%d]\n[%s]", LOG02, SQLCODE,SQLERRM);
        return(FALSE);
    }
    return(TRUE);
}

/*Modificacin Proyecto Ecu-05002 Codigo de Autorizacin.
  Se crea funcion szfnObtiene Cod_autorizacion que es llamada cuando aplica Codigo Autorizacion. 
  Esta funcion rescata el valor del codigo de autorizacion y dejarlo disponible para imprimirlo 
  en el documento.
  Se debe diferenciar entre los documentos ciclicos y los no ciclicos.
  ECU-10012 Se modifica funcin para recuperar Fecha Inicio Cdigo Autorizacin.
*/
/***********************************************************************************/
int szfnObtieneCod_autorizacion (LINEACOMANDO * ParametrosEntrada)
{
    EXEC SQL BEGIN DECLARE SECTION;
    long    lhCodCiclFact;
    char    szhCodAutorizacion[11];EXEC SQL VAR szhCodAutorizacion IS STRING(11);
    char    szhFecVencimiento [10];EXEC SQL VAR szhFecVencimiento  IS STRING(10);
    char    szhFecInicio      [10];EXEC SQL VAR szhFecInicio       IS STRING(10); /* ECU-10012 */
    EXEC SQL END DECLARE SECTION;

    int iCont = 0;

    char *szModulo="ObtieneCod_autorizacion";

    vDTrazasLog(szModulo,"\tEntrando a [%s] ",LOG04,szModulo);

    strcpy(szhFormato_Fecha,"YYYYMMDD");

    if ( ParametrosEntrada->lCodCiclFact )
    {
        lhCodCiclFact = ParametrosEntrada->lCodCiclFact;

        EXEC SQL
        SELECT 
			A.COD_AUTORIZACION, 
			NVL((TO_CHAR(A.FEC_TERMINO,:szhFormato_Fecha)),' '),
			NVL((TO_CHAR(A.FEC_DESDE,:szhFormato_Fecha)),' ')    /* ECU-10012 */
        INTO
			:szhCodAutorizacion,
			:szhFecVencimiento,
			:szhFecInicio       /* ECU-10012 */
        FROM
			AL_AUTORIZACION_FOLIO_TD A,
			FA_CICLFACT B
        WHERE 
			B.COD_CICLFACT = :lhCodCiclFact
			AND B.FEC_EMISION BETWEEN A.FEC_DESDE AND A.FEC_TERMINO             
			AND A.COD_SISTEMA = 'E';

        if ( SQLCODE != SQLOK )
        {
            vDTrazasLog(szModulo, "No se encontro Cod_autorizacion Electronico\n", LOG04);
        }
        else
	{
	    strcpy(stAutorizFolio_E.szCodAutorizacion,szhCodAutorizacion);
	    strcpy(stAutorizFolio_E.szFechaVencimiento,szhFecVencimiento);
	    strcpy(stAutorizFolio_E.szFechaInicio,szhFecInicio); /* ECU-10012 */		
	    iCont ++;
	}

	EXEC SQL
	     SELECT
			A.COD_AUTORIZACION,
			NVL((TO_CHAR(A.FEC_TERMINO,:szhFormato_Fecha)),' '),
			NVL((TO_CHAR(A.FEC_DESDE,:szhFormato_Fecha)),' ')   /* ECU-10012 */
		INTO
			:szhCodAutorizacion,
			:szhFecVencimiento,
			:szhFecInicio       /* ECU-10012 */
		FROM
			AL_AUTORIZACION_FOLIO_TD A,
			FA_CICLFACT B
		WHERE
			B.COD_CICLFACT = :lhCodCiclFact
			AND B.FEC_EMISION BETWEEN A.FEC_DESDE AND A.FEC_TERMINO
			AND A.COD_SISTEMA = 'F';

	if ( SQLCODE != SQLOK )
	{
             vDTrazasLog(szModulo, "No se encontro Cod_autorizacion Fisico\n", LOG04);	     
	}
	else
	{
	     strcpy(stAutorizFolio.szCodAutorizacion,szhCodAutorizacion);
	     strcpy(stAutorizFolio.szFechaVencimiento,szhFecVencimiento);
	     strcpy(stAutorizFolio.szFechaInicio,szhFecInicio); /* ECU-10012 */			
	     iCont++;
	}
       
        if (iCont == 0) return (FALSE);

        return(TRUE);
    }
    else
    {
        EXEC SQL
        SELECT
			A.COD_AUTORIZACION,
			NVL((TO_CHAR(A.FEC_TERMINO,:szhFormato_Fecha)),' '),
			NVL((TO_CHAR(A.FEC_DESDE,:szhFormato_Fecha)),' ')   /* ECU-10012 */
        INTO
			:szhCodAutorizacion,
			:szhFecVencimiento,
			:szhFecInicio		/* ECU-10012 */
        FROM
			AL_AUTORIZACION_FOLIO_TD A
        WHERE
			SYSDATE BETWEEN A.FEC_DESDE AND A.FEC_TERMINO
			AND A.COD_SISTEMA = 'F';

        if ( SQLCODE != SQLOK )
        {
            vDTrazasLog(szModulo, "Else: Error en SELECT de ObtieneCod_autorizacion [%d]\n[%s]", LOG02, SQLCODE,SQLERRM);
            return(FALSE);
        }

        strcpy(stAutorizFolio.szCodAutorizacion,szhCodAutorizacion);
        strcpy(stAutorizFolio.szFechaVencimiento,szhFecVencimiento);
        strcpy(stAutorizFolio.szFechaInicio,szhFecInicio); /* ECU-10012 */

        return(TRUE);

    }

}

/***********************************************************************************/
int OpenFactDocuClie (LINEACOMANDO *ParEnt)
{
    char  szTabla1    [50]    ="";
    char  szTabla2    [50]    ="";
    char  szTabla3    [350]   ="";
    char  szCadenaSQL [2500]  ="";
    char  szJoinJob   [350]   ="";

    EXEC SQL BEGIN DECLARE SECTION;
    char  *szhCodDespacho;
    int   ihCodSalida;
    long  lhProceso;
    int   ihCodEstProc;
    EXEC SQL END DECLARE SECTION;

    char *szModulo="OpenFactDocuClie";

    gihCodTipDocum  = ParEnt->iCodTipDocum ;
    szhCodDespacho = ParEnt->szCodDespacho;
    ihCodSalida    = ParEnt->iCodSalida;
    lhProceso      = ParEnt->lProceso;

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    if ( !ParEnt->iTipoCiclo )
    {
        if ( !lNroJob )
        {
            sprintf(szTabla1,"FA_FACTDOCU_%ld",ParEnt->lCodCiclFact);
            sprintf(szTabla2,"FA_FACTCLIE_%ld",ParEnt->lCodCiclFact);
        }
        else
        {
            sprintf(szTabla1,"FA_FACTDOCU_%ld_%ld",ParEnt->lCodCiclFact,lNroJob);
            sprintf(szTabla2,"FA_FACTCLIE_%ld_%ld",ParEnt->lCodCiclFact,lNroJob);
	        sprintf(szJoinJob,"\n  AND EXISTS (SELECT 1 FROM FA_CLIENTEJOB_TO J "
                  "\n               WHERE J.NUM_JOB         = %ld   "
                  "\n             AND J.COD_CLIENTE    = A.COD_CLIENTE )"
            ,lNroJob);
        }

        sprintf(szCadenaSQL,"SELECT"
            "\n A.ROWID,"
            "\n A.IND_ORDENTOTAL,"
            "\n A.COD_CLIENTE,"
            "\n NVL(A.NUM_CTC,0),"
            "\n TO_CHAR(A.FEC_EMISION,'YYYYMMDD'),"
            "\n TO_CHAR(NVL(A.FEC_VENCIMIE,SYSDATE),'YYYYMMDD'),"
            "\n NVL(A.COD_DESPACHO,'DESNO'),"
            "\n NVL(D.NOM_HEADER,' '),"
            "\n A.COD_TIPDOCUM,"
            "\n A.NUM_FOLIO,"
            "\n C.COD_GENARCH,"
            "\n C.COD_PRIORIDAD,"
            "\n A.TOT_FACTURA,"
            "\n NVL(B.NUM_IDENTTRIB,''),"
            "\n B.NOM_CLIENTE||' '||B.NOM_APECLIEN1||' '||B.NOM_APECLIEN2,"
            "\n A.TOT_CARGOSME,"
            "\n NVL(A.IMP_SALDOANT,0),"
            "\n A.TOT_PAGAR,"
            "\n DECODE(B.IND_DEBITO,'A','1','0'),"
            "\n A.TOT_CUOTAS,"
            "\n NVL(TRIM(B.COD_IDIOMA),'1'),"
            "\n A.NUM_PROCESO,"
            "\n A.PREF_PLAZA,"
            "\n A.COD_OPERADORA,"
            "\n A.COD_PLAZA,"
            "\n A.COD_OFICINA,"
            "\n A.COD_VENDEDOR,"
            "\n A.NOM_USUARORA,"
            "\n E.COD_OPERPLAZA,"
            "\n A.COD_MONEDAIMP, "
            "\n A.IMP_CONVERSION, "
            "\n NVL(A.NUM_SECUREL,0), "
            "\n A.LETRAREL, "
            "\n NVL(A.COD_TIPDOCUMREL,0), "
            "\n NVL(A.COD_VENDEDOR_AGENTEREL,0), "
            "\n NVL(A.COD_CENTRREL,0), "
            "\n NVL(A.NUM_VENTA,0), "
            "\n G.COD_CATEGORIA, "
            "\n NVL(G.NOM_APODERADO,'.'), "
            "\n NVL(H.COD_ZONA,'.'), "
            "\n NVL(G.COD_SISPAGO, 1), "
               /*P-ECU-10004BE*/
	               "\n       NVL(A.TIP_DISTRIBUCION,'F'), "
	               "\n       NVL(A.EMAIL_PRINCIPAL,'SIN INFORMACION'), "
	               "\n       NVL(A.EMAIL_ALTERNO,'SIN INFORMACION'), "
	               "\n       NVL(G.ID_SEGMENTO, 0), "
	               "\n       TO_CHAR(NVL(G.FEC_ALTA,SYSDATE),'YYYYMMDD'), "
               /*P-ECU-10004BE*/
               "G.COD_TIPIDENT " /* Inc-pre-189124  */
            "\nFROM"
            "\n %s A,"
            "\n %s B,"
            "\n FA_CODESPACHO C,"
            "\n FA_PARGENARCH D,"
            "\n GE_OPERPLAZA_TD E,"
            "\n GE_CLIENTES G, "
            "\n FA_ZONACOURIER_TD H "
            "\nWHERE A.TOT_FACTURA   >= 0"
            "\n  AND A.COD_CLIENTE   >= 0"
            "\n  AND A.NUM_FOLIO     >= 0"
            "\n  AND A.IND_SUPERTEL   = 0"
            "\n  AND A.IND_ANULADA    = 0"
            "\n  AND A.IND_FACTUR     = 1"
            "\n  AND A.IND_IMPRESA    = 0"
            "\n  AND A.COD_TIPDOCUM   = :gihCodTipDocum"
            "\n  AND A.COD_DESPACHO   = :szhCodDespacho"
            "\n  AND B.IND_ORDENTOTAL = A.IND_ORDENTOTAL"
            "\n  AND C.COD_DESPACHO   = NVL(A.COD_DESPACHO,'DESNO')"
            "\n  AND D.COD_GENARCH(+) = C.COD_GENARCH"
            "\n  AND A.COD_OPERADORA  = E.COD_OPERADORA_SCL"
            "\n  AND A.COD_PLAZA      = E.COD_PLAZA"
            "\n  AND G.COD_CLIENTE    = A.COD_CLIENTE "
            "\n  AND H.COD_CLIENTE(+) = A.COD_CLIENTE "
            "%s"
            "\nORDER BY"
            "\n A.COD_TIPDOCUM,"
            "\n C.COD_GENARCH,"
            "\n A.COD_DESPACHO,"
            "\n NVL(H.COD_ZONA,'.'),"
            "\n A.COD_CLIENTE,"
            "\n A.IND_ORDENTOTAL"
            ,szTabla1
            ,szTabla2
            ,szJoinJob);
    }
    else
    {
        sprintf(szTabla1,"FA_FACTDOCU_NOCICLO");
        sprintf(szTabla2,"FA_FACTCLIE_NOCICLO");
        sprintf(szTabla3,"(SELECT NUM_PROCESO FROM FA_INTERFACT "
            "\n WHERE COD_ESTADOC=:ihCodSalida AND COD_ESTPROC=:ihCodEstProd "
            "\n AND NUM_PROCESO = :lhProceso )"
               );

        sprintf(szCadenaSQL,"SELECT"
            "\n A.ROWID,"
            "\n A.IND_ORDENTOTAL,"
            "\n A.COD_CLIENTE,"
            "\n NVL(A.NUM_CTC,0),"
            "\n TO_CHAR(A.FEC_EMISION,'YYYYMMDD'),"
            "\n TO_CHAR(NVL(A.FEC_VENCIMIE,SYSDATE),'YYYYMMDD'),"
            "\n NVL(A.COD_DESPACHO,'DESNO'),"
            "\n NVL(D.NOM_HEADER,' '),"
            "\n A.COD_TIPDOCUM,"
            "\n A.NUM_FOLIO,"
            "\n C.COD_GENARCH,"
            "\n C.COD_PRIORIDAD,"
            "\n A.TOT_FACTURA,"
            "\n NVL(B.NUM_IDENTTRIB,''),"
            "\n B.NOM_CLIENTE||' '||B.NOM_APECLIEN1||' '||B.NOM_APECLIEN2,"
            "\n A.TOT_CARGOSME,"
            "\n NVL(A.IMP_SALDOANT,0),"
            "\n A.TOT_PAGAR,"
            "\n DECODE(B.IND_DEBITO,'A','1','0'),"
            "\n A.TOT_CUOTAS,"
            "\n NVL(B.COD_IDIOMA,'1'),"
            "\n A.NUM_PROCESO,"
            "\n A.PREF_PLAZA, "             /* P-TMM-03083*/
            "\n A.COD_OPERADORA,"
            "\n A.COD_PLAZA,"
            "\n A.COD_OFICINA,"
            "\n A.COD_VENDEDOR,"
            "\n A.NOM_USUARORA,"
            "\n F.COD_OPERPLAZA,"
            "\n A.COD_MONEDAIMP, "
            "\n NVL(A.IMP_CONVERSION,1), "
            "\n NVL(A.NUM_SECUREL,0), "
            "\n NVL(A.LETRAREL,' '), "
            "\n NVL(A.COD_TIPDOCUMREL,0), "
            "\n NVL(A.COD_VENDEDOR_AGENTEREL,0), "
            "\n NVL(A.COD_CENTRREL,0), "
            "\n NVL(A.NUM_VENTA,0), "
            "\n G.COD_CATEGORIA, "
            "\n NVL(G.NOM_APODERADO,'.'), "
            "\n NVL(H.COD_ZONA,'.'), "
            "\n NVL(G.COD_SISPAGO, 1), "
           /*P-ECU-10004BE*/
               "\n       NVL(A.TIP_DISTRIBUCION,'F'), "
               "\n       NVL(A.EMAIL_PRINCIPAL,'SIN INFORMACION'), "
               "\n       NVL(A.EMAIL_ALTERNO,'SIN INFORMACION'), "
               "\n       NVL(G.ID_SEGMENTO, 0), "
               "\n       TO_CHAR(NVL(G.FEC_ALTA,SYSDATE),'YYYYMMDD'), "
           /*P-ECU-10004BE*/
               "G.COD_TIPIDENT " /* Inc-pre-189124  */
            "\nFROM"
            "\n %s A,"
            "\n %s B,"
            "\n FA_CODESPACHO C,"
            "\n FA_PARGENARCH D,"
            "\n %s E,"
            "\n GE_OPERPLAZA_TD F, "
            "\n GE_CLIENTES G, "
            "\n FA_ZONACOURIER_TD H "
            "\nWHERE A.NUM_PROCESO = E.NUM_PROCESO"
            "\n  AND B.IND_ORDENTOTAL = A.IND_ORDENTOTAL"
            "\n  AND C.COD_DESPACHO   = NVL(A.COD_DESPACHO,'DESNO')"
            "\n  AND D.COD_GENARCH(+) = C.COD_GENARCH"
            "\n  AND A.COD_OPERADORA  = F.COD_OPERADORA_SCL"
            "\n  AND A.COD_PLAZA      = F.COD_PLAZA"
            "\n  AND G.COD_CLIENTE    = A.COD_CLIENTE "
            "\n  AND H.COD_CLIENTE(+) = A.COD_CLIENTE "
            "\nORDER BY"
            "\n A.COD_TIPDOCUM,"
            "\n C.COD_GENARCH,"
            "\n A.COD_DESPACHO,"
            "\n NVL(H.COD_ZONA,'.'),"
            "\n A.COD_CLIENTE,"
            "\n A.IND_ORDENTOTAL"
            ,szTabla1
            ,szTabla2
            ,szTabla3);
    }
    vDTrazasLog( szModulo,"=> query(\n%s\n)",LOG05,szCadenaSQL);

    EXEC SQL PREPARE sql_Facturas_DetLlam FROM :szCadenaSQL;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo, "Error en PREPARE sql_Facturas_DetLlam. Error [%d][%s]",LOG00,  SQLCODE, SQLERRM);
        return(FALSE);
    }

    EXEC SQL DECLARE curFactDocu2 CURSOR FOR sql_Facturas_DetLlam;
    if ( SQLCODE < SQLOK )
    {
        vDTrazasLog (szModulo, "Error en DECLARE. curFactDocu2. Error [%d][%s]",LOG00,  SQLCODE, SQLERRM);
        return(FALSE);
    }

    if ( !ParEnt->iTipoCiclo )
    {
        EXEC SQL OPEN curFactDocu2 USING :gihCodTipDocum, :szhCodDespacho ;
    }
    else
    {
        ihCodEstProc=iPROC_EST_RUN;
        EXEC SQL OPEN curFactDocu2 USING :ihCodSalida, :ihCodEstProc, :lhProceso;
    }

    if ( SQLCODE < SQLOK )
    {
        vDTrazasLog (szModulo, "Error en OPEN curFactDocu2. Error [%i][%s]",LOG00,  SQLCODE, SQLERRM);
        return(FALSE);
    }
    return(TRUE);

}/**************************** Final OpenFactDocuClie ****************************/


int FetchFactDocuClie( int * iPaso, int * iLeidos)
{
    int i;

    EXEC SQL BEGIN DECLARE SECTION;
    static char    szhRowid              [BUFF_CLIENTE] [19];
    static long    lhIndOrdenTotal       [BUFF_CLIENTE]     ;
    static long    lhCodCliente          [BUFF_CLIENTE]     ;
    static char    szhNumCtc             [BUFF_CLIENTE] [13];
    static char    szhFecEmision         [BUFF_CLIENTE] [9] ;
    static char    szhFecVencimie        [BUFF_CLIENTE] [9] ;
    static char    szhCodDespacho        [BUFF_CLIENTE] [6] ;
    static char    szhNomHeader          [BUFF_CLIENTE] [6] ;
    static int     ihCodTipDocum         [BUFF_CLIENTE]     ;
    static long    lhNum_Folio           [BUFF_CLIENTE]     ;
    static char    szhCodGenArch         [BUFF_CLIENTE] [3] ;
    static int     ihCodPrioridad        [BUFF_CLIENTE]     ;
    static double  dhTotFactura          [BUFF_CLIENTE]     ;
    static char    szhRut_Cliente        [BUFF_CLIENTE] [21];
    static char    szhNom_Cliente        [BUFF_CLIENTE] [93];
    static double  dhTotCargosMes        [BUFF_CLIENTE]     ;
    static double  dhImpSaldoAnt         [BUFF_CLIENTE]     ;
    static double  dhTotPagar            [BUFF_CLIENTE]     ;
    static char    szhIndDebito          [BUFF_CLIENTE] [20];
    static double  dhTotCuotas           [BUFF_CLIENTE]     ;
    static char    szhCodIdioma          [BUFF_CLIENTE] [6] ;
    static long    lhNumProceso          [BUFF_CLIENTE]     ;
    static char    szhPrefPlaza          [BUFF_CLIENTE] [11];
    static char    szhCodOperadora       [BUFF_CLIENTE] [6] ;
    static char    szhCodPlaza           [BUFF_CLIENTE] [6] ;
    static char    szhCodOficina         [BUFF_CLIENTE] [3] ;
    static long    lhCodVendedor         [BUFF_CLIENTE]     ;
    static char    szhNomUsuarora        [BUFF_CLIENTE] [31];
    static int     ihCodOperPlaza        [BUFF_CLIENTE]     ;
    static char    szhCodMonedaImp       [BUFF_CLIENTE][3]  ;
    static double  dhImpConversion       [BUFF_CLIENTE]     ;
    static long    lhNumSecuRel          [BUFF_CLIENTE]     ;
    static char    szhLetraRel           [BUFF_CLIENTE][2]  ;
    static int     ihCodTipDocumRel      [BUFF_CLIENTE]     ;
    static long    lhCodVendedorAgRel    [BUFF_CLIENTE]     ;
    static long    lhCodCentrRel         [BUFF_CLIENTE]     ;
    static long    lhNumVenta            [BUFF_CLIENTE]     ;
    static long    lhCodCategoria        [BUFF_CLIENTE]     ;
    static char    szhNomApoderado       [BUFF_CLIENTE][40] ;
    static char    szhCodZona            [BUFF_CLIENTE][15] ;
    short          i_hIndLetraRel        [BUFF_CLIENTE]     ;
    static int     ihCodSisPago          [BUFF_CLIENTE]     ;
    /*ecu 10004 PCRV*/
	    static char    szhTipDistribucion    [BUFF_CLIENTE][2]  ;
	    static char    szhEmailPrincipal     [BUFF_CLIENTE][256];
	    static char    szhEmailAlterno       [BUFF_CLIENTE][256];
	    static long		 lIdSegmento           [BUFF_CLIENTE]     ;
	    static char		 szFecAlta             [BUFF_CLIENTE][15];
    /*ecu 10004 PCRV*/
    char           szhCod_tipident           [BUFF_CLIENTE][3]; /* Inc-pre-189124  */
    EXEC SQL END DECLARE SECTION;

    char *szModulo="FetchFactDocuClie";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    memset(szhRowid             ,0,sizeof( szhRowid             ));
    memset(lhIndOrdenTotal      ,0,sizeof( lhIndOrdenTotal      ));
    memset(lhCodCliente         ,0,sizeof( lhCodCliente         ));
    memset(szhNumCtc            ,0,sizeof( szhNumCtc            ));
    memset(szhFecEmision        ,0,sizeof( szhFecEmision        ));
    memset(szhFecVencimie       ,0,sizeof( szhFecVencimie       ));
    memset(szhCodDespacho       ,0,sizeof( szhCodDespacho       ));
    memset(szhNomHeader         ,0,sizeof( szhNomHeader         ));
    memset(ihCodTipDocum        ,0,sizeof( ihCodTipDocum        ));
    memset(lhNum_Folio          ,0,sizeof( lhNum_Folio          ));
    memset(szhCodGenArch        ,0,sizeof( szhCodGenArch        ));
    memset(ihCodPrioridad       ,0,sizeof( ihCodPrioridad       ));
    memset(dhTotFactura         ,0,sizeof( dhTotFactura         ));
    memset(szhRut_Cliente       ,0,sizeof( szhRut_Cliente       ));
    memset(szhNom_Cliente       ,0,sizeof( szhNom_Cliente       ));
    memset(dhTotCargosMes       ,0,sizeof( dhTotCargosMes       ));
    memset(dhImpSaldoAnt        ,0,sizeof( dhImpSaldoAnt        ));
    memset(dhTotPagar           ,0,sizeof( dhTotPagar           ));
    memset(szhIndDebito         ,0,sizeof( szhIndDebito         ));
    memset(dhTotCuotas          ,0,sizeof( dhTotCuotas          ));
    memset(szhCodIdioma         ,0,sizeof( szhCodIdioma         ));
    memset(lhNumProceso         ,0,sizeof( lhNumProceso         ));
    memset(szhPrefPlaza         ,0,sizeof( szhPrefPlaza         ));
    memset(szhCodOperadora      ,0,sizeof( szhCodOperadora      ));
    memset(szhCodPlaza          ,0,sizeof( szhCodPlaza          ));
    memset(szhCodOficina        ,0,sizeof( szhCodOficina        ));
    memset(lhCodVendedor        ,0,sizeof( lhCodVendedor        ));
    memset(szhNomUsuarora       ,0,sizeof( szhNomUsuarora       ));
    memset(ihCodOperPlaza       ,0,sizeof( ihCodOperPlaza       ));
    memset(ihCodOperPlaza       ,0,sizeof( ihCodOperPlaza       ));
    memset(szhCodMonedaImp      ,0,sizeof( szhCodMonedaImp      ));
    memset(dhImpConversion      ,0,sizeof( dhImpConversion      ));
    memset(lhNumSecuRel         ,0,sizeof( lhNumSecuRel         ));
    memset(szhLetraRel          ,0,sizeof( szhLetraRel          ));
    memset(ihCodTipDocumRel     ,0,sizeof( ihCodTipDocumRel     ));
    memset(lhCodVendedorAgRel   ,0,sizeof( lhCodVendedorAgRel   ));
    memset(lhCodCentrRel        ,0,sizeof( lhCodCentrRel        ));
    memset(lhNumVenta           ,0,sizeof( lhNumVenta           ));
    memset(lhCodCategoria       ,0,sizeof( lhCodCategoria       ));
    memset(szhNomApoderado      ,0,sizeof( szhNomApoderado      ));
    memset(szhCodZona           ,0,sizeof( szhCodZona           ));
    memset(ihCodSisPago         ,0,sizeof( ihCodSisPago         ));

   /*ecu 10004 PCRV*/
    memset(szhTipDistribucion   ,0,sizeof( szhTipDistribucion   ));
    memset(szhEmailPrincipal    ,0,sizeof( szhEmailPrincipal    ));
    memset(szhEmailAlterno      ,0,sizeof( szhEmailAlterno      ));
    memset(lIdSegmento          ,0,sizeof( lIdSegmento      ));
    memset(szFecAlta    		,0,sizeof( szFecAlta      ));
   /*ecu 10004 PCRV*/
    memset(szhCod_tipident      ,0,sizeof( szhCod_tipident      )); /* Inc-pre-189124  */
    
    EXEC SQL FETCH curFactDocu2
    INTO    :szhRowid        ,
    :lhIndOrdenTotal ,
    :lhCodCliente    ,
    :szhNumCtc       ,
    :szhFecEmision   ,
    :szhFecVencimie  ,
    :szhCodDespacho  ,
    :szhNomHeader    ,
    :ihCodTipDocum   ,
    :lhNum_Folio     ,
    :szhCodGenArch   ,
    :ihCodPrioridad  ,
    :dhTotFactura    ,
    :szhRut_Cliente  ,
    :szhNom_Cliente  ,
    :dhTotCargosMes  ,
    :dhImpSaldoAnt   ,
    :dhTotPagar      ,
    :szhIndDebito    ,
    :dhTotCuotas     ,
    :szhCodIdioma    ,
    :lhNumProceso    ,
    :szhPrefPlaza    ,
    :szhCodOperadora ,
    :szhCodPlaza     ,
    :szhCodOficina   ,
    :lhCodVendedor   ,
    :szhNomUsuarora  ,
    :ihCodOperPlaza  ,
    :szhCodMonedaImp ,
    :dhImpConversion ,
    :lhNumSecuRel    ,
    :szhLetraRel :i_hIndLetraRel,
    :ihCodTipDocumRel,
    :lhCodVendedorAgRel,
    :lhCodCentrRel,
    :lhNumVenta,
    :lhCodCategoria,
    :szhNomApoderado,
    :szhCodZona,
    :ihCodSisPago,
    /*ecu 10004 PCRV*/
	    :szhTipDistribucion,
	    :szhEmailPrincipal,
	    :szhEmailAlterno,
	    :lIdSegmento,
	    :szFecAlta,
    /*ecu 10004 PCRV*/
    :szhCod_tipident;  /* Inc-pre-189124  */

    if ( (SQLCODE != SQLOK) && (SQLCODE != SQLNOTFOUND) )
    {
        vDTrazasLog(szModulo,"\t\tError en Fetch FetchFactDocuClie : %s", LOG01, SQLERRM);
        vDTrazasError(szModulo,"\t\tError en Fetch FetchFactDocuClie : %s", LOG01, SQLERRM);
        return(SQLCODE);
    }
    if ( *iLeidos == 0 )
        *iLeidos = sqlca.sqlerrd[2];
    else
        *iLeidos = sqlca.sqlerrd[2] - *iPaso;

    *iPaso = sqlca.sqlerrd[2];

    for ( i =0 ; i < *iLeidos; i++ )
    {
        FacturaCliente[i].lIndOrdenTotal     = lhIndOrdenTotal[i];
        FacturaCliente[i].lCodCliente        = lhCodCliente[i];
        FacturaCliente[i].iCodTipDocum       = ihCodTipDocum[i];
        FacturaCliente[i].lNum_Folio         = lhNum_Folio[i];
        FacturaCliente[i].iCodPrioridad      = ihCodPrioridad[i];
        FacturaCliente[i].dTotFactura        = dhTotFactura[i];
        FacturaCliente[i].dTotCargosMes      = dhTotCargosMes[i];
        FacturaCliente[i].dImpSaldoAnt       = dhImpSaldoAnt[i];
        FacturaCliente[i].dTotPagar          = dhTotPagar[i];
        FacturaCliente[i].dTotCuotas         = dhTotCuotas[i];
        FacturaCliente[i].lNumProceso        = lhNumProceso[i];
        FacturaCliente[i].lCodVendedor       = lhCodVendedor[i];
        FacturaCliente[i].iCodOperPlaza      = ihCodOperPlaza[i];
        FacturaCliente[i].lNumSecuRel        = lhNumSecuRel[i];
        FacturaCliente[i].iCodTipDocumRel    = ihCodTipDocumRel[i];
        FacturaCliente[i].lCodVendedorAgRel  = lhCodVendedorAgRel[i];
        FacturaCliente[i].lCodCentrRel       = lhCodCentrRel[i];
        FacturaCliente[i].lNumVenta          = lhNumVenta[i];
        FacturaCliente[i].lCodCategoria      = lhCodCategoria[i];
        FacturaCliente[i].dImpConversion     = ((dhImpConversion[i] == 0)? 1:dhImpConversion[i]);
        FacturaCliente[i].iCodSisPago        = ihCodSisPago[i];


        strcpy(FacturaCliente[i].szIndDebito     , alltrim(szhIndDebito[i]));
        strcpy(FacturaCliente[i].szRowid         , alltrim(szhRowid[i]));
        strcpy(FacturaCliente[i].szRut_Cliente   , alltrim(szhRut_Cliente[i]));
        strcpy(FacturaCliente[i].szNombre_Clie   , alltrim(szhNom_Cliente[i]));
        strcpy(FacturaCliente[i].szNumCtc        , alltrim(szhNumCtc[i]));
        strcpy(FacturaCliente[i].szCodDespacho   , alltrim(szhCodDespacho[i]));
        strcpy(FacturaCliente[i].szNomHeader     , alltrim(szhNomHeader[i]));
        strcpy(FacturaCliente[i].szCodGenArch    , alltrim(szhCodGenArch[i]));
        strcpy(FacturaCliente[i].szCod_Idioma    , alltrim(szhCodIdioma[i]));
        strcpy(FacturaCliente[i].szFecEmision    , alltrim(szhFecEmision[i]));
        strcpy(FacturaCliente[i].szFecVencimie   , alltrim(szhFecVencimie[i]));
        strcpy(FacturaCliente[i].szPrefPlaza     , alltrim(szhPrefPlaza[i]));
        strcpy(FacturaCliente[i].szCodOperadora  , alltrim(szhCodOperadora[i]));
        strcpy(FacturaCliente[i].szCodPlaza      , alltrim(szhCodPlaza[i]));
        strcpy(FacturaCliente[i].szCod_Oficina   , alltrim(szhCodOficina[i]));
        strcpy(FacturaCliente[i].szNomUsuarora   , alltrim(szhNomUsuarora[i]));
        strcpy(FacturaCliente[i].szCodMonedaImp  , alltrim(szhCodMonedaImp[i]));
        strcpy(FacturaCliente[i].szNomApoderado  , alltrim(szhNomApoderado[i]));
        strcpy(FacturaCliente[i].szCodZona       , alltrim(szhCodZona[i]));

        /*ecu 10004 PCRV*/
	        strcpy(FacturaCliente[i].szTipDistribucion, alltrim(szhTipDistribucion[i]));
	        strcpy(FacturaCliente[i].szEmailPrincipal , alltrim(szhEmailPrincipal[i]));
	        strcpy(FacturaCliente[i].szEmailAlterno   , alltrim(szhEmailAlterno[i]));
	        FacturaCliente[i].lIdSegmento  = lIdSegmento[i];
	        strcpy(FacturaCliente[i].szFecAlta        , alltrim(szFecAlta[i]));
        /*ecu 10004 PCRV*/
        if ( i_hIndLetraRel[i]!=ORA_NULL )
            strcpy(FacturaCliente[i].szLetraRel      , alltrim(szhLetraRel[i]));
        
        strcpy(FacturaCliente[i].szCod_tipident      , szhCod_tipident[i]); /* Inc-pre-189124  */
    }
    return(TRUE);
}

int CloseFactDocuClie (void)
{
    char *szModulo="CloseFactDocuClie";

    vDTrazasLog(szModulo, "Entro a iCloseFactDocuClie ", LOG05);
    EXEC SQL CLOSE curFactDocu2;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo, "Error en CLOSE curFactDocu2. Error [%i][%s]",LOG00,  SQLCODE, SQLERRM);
        return (FALSE);
    }
    return(1);
}/************************ Final iCloseFactDocuClie ******************************/


int OpenMinutoAdicional( long lCodCiclFact )
{
    char *szModulo="OpenMinutoAdicional";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL BEGIN DECLARE SECTION;
    char szhVacio       [2] ;
    char szhUno         [2] ;
    char szhFCA         [4] ;
    char szhCodDominio  [15];
    char szhV           [2] ;
    long lhCod_Ciclfact     ;

    EXEC SQL END DECLARE SECTION;

    strcpy(szhVacio," ");
    strcpy(szhUno  ,"1");
    strcpy(szhFCA  ,"FCA");
    strcpy(szhCodDominio  ,"AGRULLAM_B4001");
    strcpy(szhV  ,"V");
    lhCod_Ciclfact = lCodCiclFact;

    EXEC SQL DECLARE curMinAdicional CURSOR FOR

            SELECT A.COD_PLAN,
            A.COD_AGRULLAM,
            NVL(A.MTO_MIN,0)
            FROM TOL_ESTCOBRO A, FA_CICLFACT B, FA_AGRULLAM_B4001_VW C
            WHERE B.COD_CICLFACT = :lhCod_Ciclfact
            AND A.COD_OPERADOR > :szhVacio
            AND A.COD_PLAN > :szhVacio
            AND A.COD_TDIA = :szhUno
            AND B.FEC_DESDELLAM BETWEEN A.FEC_INI_VIG AND A.FEC_TER_VIG
            AND B.FEC_HASTALLAM BETWEEN A.FEC_INI_VIG AND A.FEC_TER_VIG
            AND A.COD_SFRAN = :szhFCA
            AND C.COD_DOMINIO = :szhCodDominio
            AND C.IND_ESTADO  = :szhV
            AND A.COD_AGRULLAM = C.DESCRIPCION_VALOR
            ORDER BY A.COD_PLAN, A.COD_AGRULLAM;

    EXEC SQL OPEN curMinAdicional;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-OPEN CURSOR curMinAdicional **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-OPEN CURSOR curMinAdicional **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
    }
    return(SQLCODE);
}

/*********************** Final de OpenMinutoAdicional***********************/
/****************************************************************************/
int FetchMinutoAdicional ( void )
{
    int i;
    EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR szhCodPlan              [MAX_MINUTOADICIONAL][6] ;
    VARCHAR szhLlaveMinutoAdicional [MAX_MINUTOADICIONAL][7] ;
    double  dhMtoAdicional          [MAX_MINUTOADICIONAL]    ;
    EXEC SQL END DECLARE SECTION;

    char *szModulo="FetchMinutoAdicional";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL
    FETCH curMinAdicional
    INTO :szhCodPlan,
    :szhLlaveMinutoAdicional,
    :dhMtoAdicional;

    if ( (SQLCODE != SQLOK) && (SQLCODE != SQLNOTFOUND) )
    {
        vDTrazasError(szModulo,"\t\tError en Fetch FetchMinutoAdicional : %s", LOG01, SQLERRM);
        return(SQLCODE);
    }

    sthMinutoAdicional.iCantidadMinutoAdicional = sqlca.sqlerrd[2];

    for ( i =0 ; i < sthMinutoAdicional.iCantidadMinutoAdicional; i++ )
    {
        sthMinutoAdicional.dMtoAdicional[i] = dhMtoAdicional[i];

        sprintf(sthMinutoAdicional.szCodPlan[i]             ,"%.*s\0",szhCodPlan[i].len,szhCodPlan[i].arr);
        sprintf(sthMinutoAdicional.szLlaveMinutoAdicional[i],"%.*s\0",szhLlaveMinutoAdicional[i].len,szhLlaveMinutoAdicional[i].arr);
    }
    return(SQLCODE);
}

/*************************** Final de FetchMinutoAdicional ***************************/
/****************************************************************************/
int CloseMinutoAdicional(void)
{
    char *szModulo="CloseMinutoAdicional";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL CLOSE curMinAdicional;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasError(szModulo,"\tError al cerrar el Cursor Minuto Adicional: %s",LOG01, SQLERRM);
        return (FALSE);
    }
    return (TRUE);
}
/****************Final de CloseMinutoAdicional *******************/
int CargaMinutoAdicional( long lCodCiclFact ) /* PGG SOPORTE - 82815 - 16-03-2009 */
{
    int  iSqlDetMinutoAdicional;
    int  rows_to_fetch  = MAX_MINUTOADICIONAL;
    int  rows_before    =  0;
    int  rows_this_time = MAX_MINUTOADICIONAL;

    char *szModulo="CargaMinutoAdicional";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    iSqlDetMinutoAdicional = OpenMinutoAdicional(lCodCiclFact);

    if ( iSqlDetMinutoAdicional == SQLOK )
    {
        while ( rows_this_time == rows_to_fetch )
        {
            iSqlDetMinutoAdicional = FetchMinutoAdicional();
            if ( (iSqlDetMinutoAdicional != SQLOK)&&(iSqlDetMinutoAdicional != SQLNOTFOUND) )
            {
            vDTrazasError(szModulo,"\t\tError en Fetch FetchMinutoAdicional : %s", LOG01, SQLERRM);
            return(SQLCODE);
            }

            sthMinutoAdicional.iCantidadMinutoAdicional = sqlca.sqlerrd[2];
            if ( sthMinutoAdicional.iCantidadMinutoAdicional > MAX_MINUTOADICIONAL )
            {
            vDTrazasLog  (szModulo,"\tsthMinutoAdicional Sobrepaso Maximo Posible" ,LOG01);
            vDTrazasError(szModulo,"\tsthMinutoAdicional Sobrepaso Maximo Posible" ,LOG01);
            return(FALSE);
            }
            rows_this_time = sthMinutoAdicional.iCantidadMinutoAdicional - rows_before;
            rows_before = sthMinutoAdicional.iCantidadMinutoAdicional;
            vDTrazasLog(szModulo,"\t[%d]-[%d]-[%d]",LOG05,rows_this_time,rows_before,rows_to_fetch);
        }
    }
    if ( (iSqlDetMinutoAdicional != SQLOK) && (iSqlDetMinutoAdicional != SQLNOTFOUND) )
    {
        vDTrazasError(szModulo,  "\t\t Error Oracle   [%s]",LOG01, SQLERRM);
        vDTrazasLog(szModulo,    "\t\t Error Oracle   [%s]",LOG01, SQLERRM);
        return(FALSE);
    }
    if ( !CloseMinutoAdicional() ) return(FALSE);
    return(TRUE);
}
/************************* Fin CargaMinutoAdicional *************************/


int Busca_RangoPlanes(int iPosicion,int *ihInicio,int *ihTermino,int iFin)
{
    int iIndice;
    int iInicio;
    int iTermino;
    char szllave[6];

    iIndice = iPosicion;
    iInicio = *ihInicio;
    iTermino = *ihTermino;

    sprintf(szllave,"%s",sthMinutoAdicional.szCodPlan[iPosicion]);
    while ( iIndice >= 0 && iInicio == 0 )
    {
        if ( strcmp(szllave,sthMinutoAdicional.szCodPlan[iIndice])==0 )
        {
            sprintf(szllave,"%s",sthMinutoAdicional.szCodPlan[iIndice]);
            iIndice--;
        }
        else
        {
            iInicio = iIndice+1;
        }
    }
    if ( iIndice < 0 ) iInicio = 0;

    iIndice = iPosicion;
    sprintf(szllave,"%s",sthMinutoAdicional.szCodPlan[iPosicion]);
    while ( iIndice < iFin && iTermino == 0 && iIndice > 0 )
    {
        if ( strcmp(szllave,sthMinutoAdicional.szCodPlan[iIndice])==0 )
        {
            sprintf(szllave,"%s",sthMinutoAdicional.szCodPlan[iIndice]);
            iIndice ++;
        }
        else
        {
            iTermino = iIndice-1;
        }
    }
    if ( iIndice >= iFin ) iTermino = iFin-1;

    *ihInicio = iInicio;
    *ihTermino = iTermino;

    return(TRUE);
}/****************Final de Busca_RangoPlanes ******************************************/

int BuscaEstrucPlanes(char *szllave,int iDerecha)
{
    int iCentro;
    int iIzquierda;
    char *szModulo="BuscaEstrucPlanes";

    iIzquierda = 0;
    while ( iIzquierda <= iDerecha )
    {
        iCentro = (iIzquierda + iDerecha) / 2;
        vDTrazasLog(szModulo,"\tPlan [%s]-[%s]",LOG06,szllave,sthMinutoAdicional.szCodPlan[iCentro]);
        if ( strcmp(szllave,sthMinutoAdicional.szCodPlan[iCentro])<0 )
        {
            iDerecha = iCentro - 1;
        }
        else
        {
            if ( strcmp(szllave,sthMinutoAdicional.szCodPlan[iCentro])>0 )
            {
            iIzquierda = iCentro + 1;
            }
            else
            {
            return(iCentro);
            }
        }
    }
    return(-1);
}/****************Final de BuscaEstrucPlanes *******************/


int BuscaValorMinuto(char *szllave,int iIzquierda, int iDerecha)
{
    int iCentro;
    char *szModulo="BuscaValorMinuto";

    while ( iIzquierda <= iDerecha )
    {
        iCentro = (iIzquierda + iDerecha) / 2;
        vDTrazasLog(szModulo,"\tPlan [%s]-[%s]",LOG06,szllave,sthMinutoAdicional.szLlaveMinutoAdicional[iCentro]);
        if ( strcmp(szllave,sthMinutoAdicional.szLlaveMinutoAdicional[iCentro])<0 )
        {
            iDerecha = iCentro - 1;
        }
        else
        {
            if ( strcmp(szllave,sthMinutoAdicional.szLlaveMinutoAdicional[iCentro])>0 )
            {
            iIzquierda = iCentro + 1;
            }
            else
            {
            return(iCentro);
            }
        }
    }
    return(-1);
}/****************Final de BuscaValorMinuto *******************/


int buscaMinutoAdicional(char *szCodPlan,char *szllave)
{
    int iPosicionEstrucPlanes;
    int iPosicionValorMinutos;
    int iDerecha;
    int iInicio;
    int iTermino;

    char *szModulo="buscaMinutoAdicional";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    iPosicionValorMinutos=-1;
    iDerecha = sthMinutoAdicional.iCantidadMinutoAdicional;
    vDTrazasLog(szModulo,"\tPlan [%s] es [%s]",LOG05,szCodPlan,szllave);
    iPosicionEstrucPlanes = BuscaEstrucPlanes(szCodPlan,iDerecha);
    if ( iPosicionEstrucPlanes != -1 )
    {
        vDTrazasLog(szModulo,"\tPlan [%s] es [%d]",LOG06,szCodPlan,iPosicionEstrucPlanes);
        iInicio=0;
        iTermino=0;
        if ( !Busca_RangoPlanes(iPosicionEstrucPlanes,&iInicio,&iTermino,iDerecha) )
        {
            return(FALSE);
        }
        vDTrazasLog(szModulo,"\tPlan [%s] Inicio [%d] Termino [%d] ", LOG06,szCodPlan,iInicio,iTermino);
        iPosicionValorMinutos = BuscaValorMinuto(szllave,iInicio,iTermino);
        if ( iPosicionValorMinutos != -1 )
        {
            return(iPosicionValorMinutos);
        }
    }
    return(iPosicionValorMinutos);
}/****************Final de busca_arrastre *******************/


int ifnCmpCodCliente(const void *cad1,const void *cad2)
{
    int rc = 0;

    return
    ( (rc =     ((CODCLI *)cad1)->lCodCliente-
       ((CODCLI *)cad2)->lCodCliente) != 0)?rc:
    ( (rc = strcmp  (((CODCLI *)cad1)->szFecDesde,
             ((CODCLI *)cad2)->szFecDesde)) < 0)?rc:
    ( (rc = strcmp  (((CODCLI *)cad1)->szFecHasta,
             ((CODCLI *)cad2)->szFecHasta)) > 0)?rc:0;
}/****************Final de ifnCmpCodCliente *******************/

int ifnOpenCod_Plantarif()
{
    char *szModulo="ifnOpenCod_Plantarif";

    vDTrazasLog (szModulo,"\n\t\t* Open=> TA_PLANTARIF, TA_CARGOSBASICO", LOG06);

    ihUno = 1;

    EXEC SQL DECLARE Cur_Cod_Plantarif CURSOR for
        SELECT  A.COD_PLANTARIF,
        A.DES_PLANTARIF,
        A.TIP_PLANTARIF,
        A.NUM_UNIDADES,
        B.IMP_CARGOBASICO,
        A.IND_ARRASTRE
        FROM  TA_PLANTARIF A,
        TA_CARGOSBASICO B
        WHERE A.COD_PRODUCTO = :ihUno
                   AND A.COD_CARGOBASICO = B.COD_CARGOBASICO
                   AND A.COD_PRODUCTO    = B.COD_PRODUCTO;

    EXEC SQL OPEN Cur_Cod_Plantarif;

    if ( SQLCODE != SQLOK )
        iDError (szModulo,ERR000,vInsertarIncidencia,"Open=> TA_PLANTARIF, TA_CARGOSBASICO",szfnORAerror ());

    return (SQLCODE);
}/***************************** Final ifnOpenCod_Plantarif **********************/


BOOL bfnFetchCod_Plantarif(PLAN_TARIFARIO_HOSTS * pst_PlanTarifario, int *iCantPlanes)                 
{                                                          
    char *szModulo="bfnFetchCod_Plantarif";                                    
                                                           
    EXEC SQL FETCH Cur_Cod_Plantarif                                           
    INTO    :pst_PlanTarifario->szCod_Plantarif    ,                               
    :pst_PlanTarifario->szDes_Plantarif    ,                                       
    :pst_PlanTarifario->szTip_Plantarif    ,                                       
    :pst_PlanTarifario->lMinutosPlan       ,                                       
    :pst_PlanTarifario->dValorPlan         ,                                       
    :pst_PlanTarifario->iInd_Arrastre      ;                                       
                                                           
    if ( (SQLCODE != SQLOK) && (SQLCODE != SQLNOTFOUND) )                                  
    {                                                      
            vDTrazasError(szModulo,"\t\tError en Fetch %s : %s", LOG01, szModulo, SQLERRM);            
    }                                                      
    else                                                   
    {                                                      
        *iCantPlanes = sqlca.sqlerrd[2];                                       
    }                                                      
    return (SQLCODE);                                                  
}/***************************** Final bfnFetchCod_Plantarif ****************/                          


int ifnCloseCod_Plantarif(void)
{
    char *szModulo="ifnCloseCod_Plantarif";
    vDTrazasLog (szModulo,"\n\t\t* Open=> TA_PLANTARIF, TA_CARGOSBASICO", LOG06);

    EXEC SQL CLOSE Cur_Cod_Plantarif;

    if ( SQLCODE != SQLOK )
    {
            iDError (szModulo,ERR000,vInsertarIncidencia,"Close=> Cursor=> TA_PLANTARIF, TA_CARGOSBASICO",szfnORAerror ());
    }

    return (SQLCODE);
}/***************************** Final ifnCloseFetchCod_Plantarif **********************/


BOOL bfnCargaCod_Plantarif (PLAN_TARIFARIO **pstCodPlanTarif, int *iNumCodPlanes)
{
    int     rc = 0;
    int    iNumFilas;
    static  PLAN_TARIFARIO_HOSTS stCodPlanTarifHost;
    PLAN_TARIFARIO  *pstCodPlanTarifTemp;
    int iCont;
    char *szModulo="bfnCargaCod_Plantarif";

    vDTrazasLog (szModulo,"\n\t* Carga Planes tarifarios ", LOG06);

    *iNumCodPlanes = 0;
    *pstCodPlanTarif = NULL;

    if ( ifnOpenCod_Plantarif() )
        return (FALSE);

    while ( rc != SQLNOTFOUND )
    {
        rc = bfnFetchCod_Plantarif(&stCodPlanTarifHost,&iNumFilas);
        if ( rc != SQLOK  && rc != SQLNOTFOUND )
            return (FALSE);

        if ( !iNumFilas )
            break;

        *pstCodPlanTarif =(PLAN_TARIFARIO*) realloc(*pstCodPlanTarif,(int)(((*iNumCodPlanes)+iNumFilas)*sizeof(PLAN_TARIFARIO)));

        if ( !*pstCodPlanTarif )
        {
            iDError (szModulo,ERR000,vInsertarIncidencia,"Error bfnCargaCod_Plantarif", "No se pudo reservar memoria");
            return (FALSE);
        }

        pstCodPlanTarifTemp = &(*pstCodPlanTarif)[(*iNumCodPlanes)];
        memset(pstCodPlanTarifTemp, 0, (int)(sizeof(PLAN_TARIFARIO)*iNumFilas));
        for ( iCont = 0 ; iCont < iNumFilas ; iCont++ )
        {
            strcpy( pstCodPlanTarifTemp[iCont].szCod_Plantarif,alltrim(stCodPlanTarifHost.szCod_Plantarif[iCont]));
            strcpy( pstCodPlanTarifTemp[iCont].szDes_Plantarif,stCodPlanTarifHost.szDes_Plantarif[iCont]);
            strcpy( pstCodPlanTarifTemp[iCont].szTip_Plantarif,stCodPlanTarifHost.szTip_Plantarif[iCont]);
            pstCodPlanTarifTemp[iCont].lMinutosPlan   = stCodPlanTarifHost.lMinutosPlan   [iCont];
            pstCodPlanTarifTemp[iCont].dValorPlan     = stCodPlanTarifHost.dValorPlan     [iCont];
            pstCodPlanTarifTemp[iCont].iInd_Arrastre  = stCodPlanTarifHost.iInd_Arrastre  [iCont];
        }
        (*iNumCodPlanes) += iNumFilas;
    }/* fin while */

    vDTrazasLog (szModulo,"\n\t\t* Codigos de Planes Tarifarios cargados [%ld]", LOG06, *iNumCodPlanes);

    rc = ifnCloseCod_Plantarif();
    if ( rc != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Error bfnCargaCod_Plantarif", szfnORAerror ());
        return (FALSE);
    }

    qsort((void*)*pstCodPlanTarif, *iNumCodPlanes, sizeof(PLAN_TARIFARIO),ifnCmpCod_PlanTarif);

    vfnPrintCod_PlanTarif (*pstCodPlanTarif, *iNumCodPlanes);

    return(TRUE);
}/***************************** Final bfnCargaCod_Plantarif *********************/



/*************************************/
/*  FUNCION : ifnOpenDetTransClie() */
/*************************************/
static int ifnOpenDetTransClie(ST_CICLOFACT *sthFa_CicloFact ,long lCodCliente, long lCodCiclFact)
{
    long lhCodCiclFact;
    int  iUno  = 1;
    int  iCero = 0;
    char szhFormatoFecha[17];
    char szhFechadesde[15];
    char szhFechahasta[15];
    char szhFormatoFechaCorto[9];
    char szTablaBalan  [50] ="";
    char szTablaDetBalan  [50] ="";
    char szTablaCuotCredito  [50] ="";
    char szCadenaSQL [14000] ="";/*INC 202818 de 10000 a 14000 PPQL*/ 

    lhCodCliente = lCodCliente;
    lhCodCiclFact = lCodCiclFact;
    strcpy(szhFormatoFecha,"YYYYMMDDHH24MISS");
    strcpy(szhFormatoFechaCorto,"YYYYMMDD");

    sprintf(szhFechadesde,"%s000000",sthFa_CicloFact->fec_desde);
    sprintf(szhFechahasta,"%s235959",sthFa_CicloFact->fec_hasta);

/* P-ECU-09005 */

    if ( !lNroJob )
    {
         strcpy(szTablaBalan,"FA_BALANCE_TO");
         strcpy(szTablaDetBalan,"FA_DETBALANCE_TO");
         //strcpy(szTablaCuotCredito,"FA_CUOTCREDITO"); /* parece que tiene el ciclo asociado */
         sprintf(szTablaCuotCredito,"FA_CUOTCREDITO_%ld",lhCodCiclFact);

          sprintf(szCadenaSQL,"SELECT"
            "\n 'CANCE', "
            "\n A.NUM_ABONADO,"
            "\n B.IND_DETALLE,"
            "\n A.COD_TIPDOCUM,"
            "\n ' ' as COD_OFICINA,"
            "\n A.PREF_PLAZA,"
            "\n A.NUM_FOLIO,"
            "\n TO_CHAR(A.FEC_EFECTIVIDAD,:szhFormatoFechaCorto),"
            "\n A.SEC_CUOTA,"
            "\n A.NUM_CUOTA,"
            "\n SUM(DECODE(A.COD_TIPDOCUM,25,(ABS(A.IMPORTE_DEBE) * -1),A.IMPORTE_DEBE)), "
            "\n SUM(DECODE(A.COD_TIPDOCUM,25,(ABS(A.IMPORTE_HABER) * -1),A.IMPORTE_HABER)),"
            "\n 0 as MTO_SALDO, "
            "\n 0 as MTO_AJUSTE,"
            "\n 0 as TOT_BALANCE,"
            "\n 0 as IND_PAGO, "
            "\n DECODE(B.COD_REGISTRO,'B5020','B5010','B5030'), "
            "\n DECODE(A.COD_TIPDOCUM,53,'FDOCU',48,'FDOCU',B.COD_ORIGEN), "
            "\n 0, "
            "\n 'N' " /* para acelerada */
            "\n FROM "
            "\n  CO_CANCELADOS A, "
            "\n  FA_NEWCONFBALANCE_TD B, "
            "\n  FA_TIPDOCUMEN C "
            "\n WHERE A.COD_CLIENTE = :lhCodCliente"
            "\n  AND B.COD_ORIGEN       = 'CARUP' "
            "\n  AND B.COD_REGISTRO     IN ('B5020','B5040') "
            "\n  AND B.COD_TIPDOCUM     = A.COD_TIPDOCUM"
            "\n  AND B.IND_IMPRESION    = :iUno"
            "\n  AND C.COD_TIPDOCUMMOV  = B.COD_TIPDOCUM"
            "\n  AND C.IND_CICLO        = :iCero"
            "\n  AND A.FEC_PAGO >= TO_DATE (:szhFechadesde,:szhFormatoFecha)"
            "\n  AND A.FEC_PAGO <= TO_DATE (:szhFechahasta,:szhFormatoFecha)"
            "\n  AND A.NUM_CUOTA > 0"
            "\n  AND A.IND_FACTURADO = 0"
            "\n GROUP BY A.NUM_ABONADO,  B.IND_DETALLE,  A.COD_TIPDOCUM,  A.PREF_PLAZA,  A.NUM_FOLIO,  "
            "\n A.FEC_EFECTIVIDAD,  A.SEC_CUOTA,  A.NUM_CUOTA,  "
            "\n B.COD_REGISTRO, B.COD_ORIGEN"
            "\n UNION   "  /*-------------------------------------------------------------------------*/
            "\n SELECT  "  /*INI PPQL 201822*/
            "\n ROWIDTOCHAR(A.ROWID),"
            "\n B.NUM_ABONADO,"
            "\n C.IND_DETALLE,"
            "\n A.COD_TIPDOCUM,"
            "\n A.COD_OFICINA,"
            "\n A.PREF_PLAZA,"
            "\n A.NUM_FOLIO,"
            "\n TO_CHAR(A.FEC_TRANSACCION,:szhFormatoFechaCorto),"
            "\n B.NUM_CUOTA,"
            "\n B.NUM_TOTCUOTA,"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_DEBE) * -1),B.MTO_DEBE),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_HABER) * -1),B.MTO_HABER),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_SALDO) * -1),B.MTO_SALDO),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(A.MTO_AJUSTE) * -1),A.MTO_AJUSTE),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(A.TOT_BALANCE) * -1),A.TOT_BALANCE),"
            "\n C.IND_PAGO, "
            "\n C.COD_REGISTRO, "
            "\n C.COD_ORIGEN, "
            "\n NVL((SELECT 1 FROM FA_NEWCONFBALANCE_TD Z WHERE A.COD_TIPDOCUM=25 AND A.COD_TIPDOCUMREL= Z.COD_TIPDOCUM AND Z.COD_ORIGEN='CARUP'),0) , "
            "\n 'N' " /* para acelerada */
            "\nFROM"
            "\n %s A,"
            "\n %s B,"
            "\n %s E,"  /*INI 202818 PPQL*/
            "\n FA_NEWCONFBALANCE_TD C,"
            "\n FA_TIPDOCUMEN D "
            "\n WHERE A.COD_CLIENTE     = :lhCodCliente"
            "\n AND B.SEC_BALANCE      = A.SEC_BALANCE"
            "\n AND A.COD_CLIENTE = E.COD_CLIENTE "   /*INI 202818 PPQL*/
            "\n AND B.NUM_ABONADO = E.NUM_ABONADO "   
            "\n AND E.SEC_CUOTA = B.NUM_CUOTA "       
            "\n AND A.NUM_SECUENCI = E.NUM_SECUENCI " 
            "\n AND E.IND_ACELERADA = 'N' "           /*FIN 202818 PPQL*/            
            "\n AND C.COD_ORIGEN       = A.ORIGEN"
            "\n AND C.COD_TIPDOCUM     = A.COD_TIPDOCUM"
            "\n AND C.IND_IMPRESION    = :iUno"
            "\n AND D.COD_TIPDOCUMMOV  = C.COD_TIPDOCUM"
            "\n AND D.IND_CICLO        = :iCero"
            "\n AND A.FEC_TRANSACCION >= C.FEC_DESDE"  /* PGG - SE VUELVE ATRAS ESTAS LINEAS COMENTADAS. 137177 */
            "\n AND A.FEC_TRANSACCION <= C.FEC_HASTA" /* PGG - SE VUELVE ATRAS ESTAS LINEAS COMENTADAS. 137177 */
            "\n AND A.FEC_TRANSACCION <= TO_DATE (:szhFechahasta,:szhFormatoFecha) "  /*FIN PPQL 201822*/ 
            "\n UNION   "  /*   INICIO b5030, b5010 INC 202818 PPQL*/  
            "\n SELECT  "  
            "\n ROWIDTOCHAR(A.ROWID),"
            "\n B.NUM_ABONADO,"
            "\n C.IND_DETALLE,"
            "\n A.COD_TIPDOCUM,"
            "\n A.COD_OFICINA,"
            "\n A.PREF_PLAZA,"
            "\n A.NUM_FOLIO,"
            "\n TO_CHAR(A.FEC_TRANSACCION,'YYYYMMDD'),"
            "\n B.NUM_CUOTA,"
            "\n B.NUM_TOTCUOTA,"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_DEBE) * -1),B.MTO_DEBE),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_HABER) * -1),B.MTO_HABER),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_SALDO) * -1),B.MTO_SALDO),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(A.MTO_AJUSTE) * -1),A.MTO_AJUSTE),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(A.TOT_BALANCE) * -1),A.TOT_BALANCE),"
            "\n C.IND_PAGO,"
            "\n C.COD_REGISTRO,"
            "\n C.COD_ORIGEN,"
            "\n NVL((SELECT 1 FROM FA_NEWCONFBALANCE_TD Z WHERE A.COD_TIPDOCUM=25 AND A.COD_TIPDOCUMREL= Z.COD_TIPDOCUM AND Z.COD_ORIGEN='CARUP'),0) , "
            "\n 'N' " /* para acelerada */
            "\n FROM"
            "\n FA_BALANCE_TO A,"
            "\n FA_DETBALANCE_TO B, "
            "\n FA_NEWCONFBALANCE_TD C, "
            "\n FA_TIPDOCUMEN D "
            "\n WHERE A.COD_CLIENTE     = :lhCodCliente "
            "\n AND B.SEC_BALANCE      = A.SEC_BALANCE "
            "\n AND C.COD_ORIGEN       = A.ORIGEN "
            "\n AND A.ORIGEN = 'FDOCU' "
            "\n AND C.COD_TIPDOCUM     = A.COD_TIPDOCUM "
            "\n AND C.IND_IMPRESION    = :iUno "
            "\n AND D.COD_TIPDOCUMMOV  = C.COD_TIPDOCUM "
            "\n AND D.IND_CICLO        = :iCero "
            "\n AND A.FEC_TRANSACCION >= C.FEC_DESDE " 
            "\n AND A.FEC_TRANSACCION <= C.FEC_HASTA " 
            "\n AND A.FEC_TRANSACCION <= TO_DATE (:szhFechahasta,:szhFormatoFecha) "/*   FIN b5030, b5010 INC 202818 PPQL* */ 
            "\n UNION   "  /*-------------------------------------------------------------------------*/
            "\n SELECT  "
            "\n ROWIDTOCHAR(A.ROWID),"
            "\n B.NUM_ABONADO,"
            "\n C.IND_DETALLE,"
            "\n A.COD_TIPDOCUM,"
            "\n A.COD_OFICINA,"
            "\n A.PREF_PLAZA,"
            "\n A.NUM_FOLIO,"
            "\n TO_CHAR(A.FEC_TRANSACCION,:szhFormatoFechaCorto),"
            "\n B.NUM_CUOTA,"
            "\n B.NUM_TOTCUOTA,"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_DEBE) * -1),B.MTO_DEBE),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_HABER) * -1),B.MTO_HABER),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_SALDO) * -1),B.MTO_SALDO),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(A.MTO_AJUSTE) * -1),A.MTO_AJUSTE),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(A.TOT_BALANCE) * -1),A.TOT_BALANCE),"
            "\n C.IND_PAGO, "
            "\n C.COD_REGISTRO, "
            "\n C.COD_ORIGEN, "
            "\n NVL((SELECT 1 FROM FA_NEWCONFBALANCE_TD Z WHERE A.COD_TIPDOCUM=25 AND A.COD_TIPDOCUMREL= Z.COD_TIPDOCUM AND Z.COD_ORIGEN='CARUP'),0), "
            "\n J.IND_ACELERADA " /* para acelerada */
            "\nFROM"
            "\n %s A,"
            "\n %s B,"
            "\n FA_NEWCONFBALANCE_TD C,"
            "\n FA_TIPDOCUMEN D, "
            "\n (  SELECT  DISTINCT H.NUM_ABONADO, H.SEC_CUOTA, H.IND_ACELERADA , H.NUM_CUOTA, I.SEC_BALANCE " /* para acelerada */
            "\n FROM %s H, %s I " /* para acelerada */
            "\n WHERE H.COD_CLIENTE      = :lhCodCliente " /* para acelerada */
            "\n AND   H.NUM_ABONADO = I.NUM_ABONADO " /* para acelerada */
            "\n AND   H.SEC_CUOTA = I.NUM_CUOTA "
            "\n AND   H.NUM_CUOTA = I.NUM_TOTCUOTA) J " /* para acelerada */
            "\n WHERE A.COD_CLIENTE     = :lhCodCliente"
            "\n AND B.SEC_BALANCE      = A.SEC_BALANCE"
            "\n AND C.COD_ORIGEN       = A.ORIGEN"
            "\n AND C.COD_TIPDOCUM     = A.COD_TIPDOCUM"
            "\n AND C.IND_IMPRESION    = :iUno"
            "\n AND D.COD_TIPDOCUMMOV  = C.COD_TIPDOCUM"
            "\n AND D.IND_CICLO        = :iCero"
            "\n AND A.FEC_TRANSACCION >= C.FEC_DESDE"  /* PGG - SE VUELVE ATRAS ESTAS LINEAS COMENTADAS. 137177 */
            "\n AND A.FEC_TRANSACCION <= C.FEC_HASTA" /* PGG - SE VUELVE ATRAS ESTAS LINEAS COMENTADAS. 137177 */
            "\n AND J.NUM_ABONADO = B.NUM_ABONADO " /* para acelerada */
            "\n AND J.SEC_CUOTA = B.NUM_CUOTA " /* para acelerada */
            "\n AND J.SEC_BALANCE = B.SEC_BALANCE " /* para acelerada */
            "\n AND   J.NUM_CUOTA = B.NUM_TOTCUOTA "
            /* "\n AND A.FEC_TRANSACCION >= TO_DATE (:szhFechadesde,:szhFormatoFecha)"  */ /* PGG 1.1 - 138693 - 23-06-2010 */
            "\n AND A.FEC_TRANSACCION <= TO_DATE (:szhFechahasta,:szhFormatoFecha) "  /* Inc 132916 (se fue en inc 137918) PPV Se deja tope final para que no tome cuotas insertadas por el trigger que deben ser facturadar el proximo ciclo */
            "\nUNION " /* --------------- De aqui en adelante solo cuotas de NC ----------------- */
            "\nSELECT"
            "\n 'CANCE', "
            "\n A.NUM_ABONADO,"
            "\n B.IND_DETALLE,"
            "\n A.COD_TIPDOCUM,"
            "\n ' ' as COD_OFICINA,"
            "\n A.PREF_PLAZA,"
            "\n A.NUM_FOLIO,"
            "\n TO_CHAR(A.FEC_EFECTIVIDAD,:szhFormatoFechaCorto),"
            "\n 0 , " /* A.SEC_CUOTA Se pone siempre 0 para que salga en el B5030 */
            "\n 0 , " /* A.NUM_CUOTA Se pone siempre 0 para que salga en el B5030 */
            "\n SUM(ABS(A.IMPORTE_DEBE) * -1), "
            "\n SUM(ABS(A.IMPORTE_HABER) * -1),"
            "\n 0 as MTO_SALDO, "
            "\n 0 as MTO_AJUSTE,"
            "\n 0 as TOT_BALANCE,"
            "\n 0 as IND_PAGO, "
            "\n B.COD_REGISTRO, "
            "\n B.COD_ORIGEN, "
            "\n 0, "
            "\n 'N' " /* para acelerada */
            "\n FROM "
            "\n  CO_CANCELADOS A, "
            "\n  FA_NEWCONFBALANCE_TD B, "
            "\n  FA_TIPDOCUMEN C "
            "\n WHERE A.COD_CLIENTE = :lhCodCliente"
            "\n  AND B.COD_ORIGEN       = 'FDOCU' "
            "\n  AND B.COD_REGISTRO     = 'B5030' "
            "\n  AND B.COD_TIPDOCUM     = A.COD_TIPDOCUM"
            "\n  AND B.IND_IMPRESION    = :iUno"
            "\n  AND C.COD_TIPDOCUMMOV  = B.COD_TIPDOCUM"
            "\n  AND C.IND_CICLO        = :iCero"
            "\n  AND A.FEC_EFECTIVIDAD >= TO_DATE (:szhFechadesde,:szhFormatoFecha)"
            "\n  AND A.FEC_EFECTIVIDAD <= TO_DATE (:szhFechahasta,:szhFormatoFecha)"
            "\n  AND A.NUM_CUOTA > 0"
            "\n  AND A.IND_FACTURADO = 1"
            "\n  AND A.COD_TIPDOCUM = 25"
            "\n AND EXISTS (SELECT 1 FROM FAD_CONFBALANCE Z WHERE Z.COD_ITEM = 4 AND Z.COD_ORIGEN IN ('CRED1','CREDI') AND Z.COD_TIPDOCUM = A.COD_TIPDOCUM)"
            "\n GROUP BY A.NUM_ABONADO,  B.IND_DETALLE,  A.COD_TIPDOCUM,  A.PREF_PLAZA,  A.NUM_FOLIO,  "
            "\n A.FEC_EFECTIVIDAD, "
            "\n B.COD_REGISTRO, B.COD_ORIGEN "
            "\n UNION "
            "\n SELECT"
            "\n 'CANCE', "
            "\n A.NUM_ABONADO,"
            "\n B.IND_DETALLE,"
            "\n A.COD_TIPDOCUM,"
            "\n ' ' as COD_OFICINA,"
            "\n A.PREF_PLAZA,"
            "\n A.NUM_FOLIO,"
            "\n TO_CHAR(A.FEC_EFECTIVIDAD,:szhFormatoFechaCorto),"
            "\n 0," /* A.SEC_CUOTA Se pone siempre 0 para que salga en el B5030 */
            "\n 0," /* A.NUM_CUOTA Se pone siempre 0 para que salga en el B5030 */
            "\n SUM(ABS(A.IMPORTE_HABER) * -1), "  /* Se considera el haber por que en la cartera solo hay haber */
            "\n SUM(ABS(A.IMPORTE_HABER) * -1), "  /* Se considera el haber por que en la cartera solo hay haber */
            "\n 0 as MTO_SALDO, "
            "\n 0 as MTO_AJUSTE,"
            "\n 0 as TOT_BALANCE,"
            "\n 0 as IND_PAGO, "
            "\n B.COD_REGISTRO, "
            "\n B.COD_ORIGEN, "
            "\n 0, "
            "\n 'N' " /* para acelerada */
            "\n FROM "
            "\n  CO_CARTERA A, "
            "\n  FA_NEWCONFBALANCE_TD B, "
            "\n  FA_TIPDOCUMEN C "
            "\n WHERE A.COD_CLIENTE = :lhCodCliente"
            "\n  AND B.COD_ORIGEN       = 'FDOCU' "
            "\n  AND B.COD_REGISTRO     = 'B5030' "
            "\n  AND B.COD_TIPDOCUM     = A.COD_TIPDOCUM"
            "\n  AND B.IND_IMPRESION    = :iUno"
            "\n  AND C.COD_TIPDOCUMMOV  = B.COD_TIPDOCUM"
            "\n  AND C.IND_CICLO        = :iCero"
            "\n  AND A.FEC_EFECTIVIDAD >= TO_DATE (:szhFechadesde,:szhFormatoFecha)"
            "\n  AND A.FEC_EFECTIVIDAD <= TO_DATE (:szhFechahasta,:szhFormatoFecha)"
            "\n  AND A.NUM_CUOTA > 0"
            "\n  AND A.IND_FACTURADO = 1"
            "\n  AND A.COD_TIPDOCUM = 25"
            "\n AND EXISTS (SELECT 1 FROM FAD_CONFBALANCE Z WHERE Z.COD_ITEM = 4 AND Z.COD_ORIGEN IN ('CRED1','CREDI') AND Z.COD_TIPDOCUM = A.COD_TIPDOCUM)"
            "\n GROUP BY A.NUM_ABONADO,  B.IND_DETALLE,  A.COD_TIPDOCUM,  A.PREF_PLAZA,  A.NUM_FOLIO,  "
            "\n A.FEC_EFECTIVIDAD, "
            "\n B.COD_REGISTRO, B.COD_ORIGEN "
            "\n ORDER BY 2,4,6,7,9, 20 DESC"
          ,szTablaBalan
          ,szTablaDetBalan
          ,szTablaCuotCredito
          ,szTablaBalan
          ,szTablaDetBalan
          ,szTablaCuotCredito
          ,szTablaDetBalan);


            vDTrazasLog( szModulo,"=> query (\n%s\n)",LOG05,szCadenaSQL);

            EXEC SQL PREPARE Cur_Balance FROM :szCadenaSQL;

            if ( SQLCODE != SQLOK )
            {
            vDTrazasLog (szModulo, "Error en PREPARE Cur_Balance. Error [%d][%s]",LOG00,  SQLCODE, SQLERRM);
            return(FALSE);
            }

            EXEC SQL DECLARE curFacBalance CURSOR FOR Cur_Balance;
            if ( SQLCODE < SQLOK )
            {
            vDTrazasLog (szModulo, "Error en DECLARE. curFacBalance. Error [%d][%s]",LOG00,  SQLCODE, SQLERRM);
            return(FALSE);
            }


            EXEC SQL OPEN curFacBalance USING :szhFormatoFechaCorto,
                          :lhCodCliente,
                          :iUno,
                          :iCero,
                          :szhFechadesde,
                          :szhFormatoFecha,
                          :szhFechahasta,
                          :szhFormatoFecha,
                          :szhFormatoFechaCorto,/* INI PPQL 201822*/
                          :lhCodCliente,
                          :iUno,
                          :iCero,
                          :szhFechahasta,
                          :szhFormatoFecha,/* FIN PPQL 201822*/ 
                          :lhCodCliente,/* INI PPQL 202818*/
                          :iUno,
                          :iCero,
                          :szhFechahasta,
                          :szhFormatoFecha,/* FIN PPQL 202818*/
                          :szhFormatoFechaCorto,
                          :lhCodCliente,
                          :lhCodCliente,
                          :iUno,
                          :iCero,
                          :szhFechahasta, /* Inc 139216 PPV 30/06/2010 Se agrega fecha tope */
                          :szhFormatoFecha, /* Inc 139216 PPV 30/06/2010 Se agrega fecha tope */
                          :szhFormatoFechaCorto, /* Inc 137918 PPV 02/07/2010 */
                          :lhCodCliente, /* Inc 137918 PPV 02/07/2010 */
                          :iUno, /* Inc 137918 PPV 02/07/2010 */
                          :iCero, /* Inc 137918 PPV 02/07/2010 */
                          :szhFechadesde, /* Inc 137918 PPV 02/07/2010 */
                          :szhFormatoFecha, /* Inc 137918 PPV 02/07/2010 */
                          :szhFechahasta, /* Inc 137918 PPV 02/07/2010 */
                          :szhFormatoFecha, /* Inc 137918 PPV 02/07/2010 */
                          :szhFormatoFechaCorto, /* Inc 137918 PPV 02/07/2010 */
                          :lhCodCliente, /* Inc 137918 PPV 02/07/2010 */
                          :iUno, /* Inc 137918 PPV 02/07/2010 */
                          :iCero, /* Inc 137918 PPV 02/07/2010 */
                          :szhFechadesde, /* Inc 137918 PPV 02/07/2010 */
                          :szhFormatoFecha, /* Inc 137918 PPV 02/07/2010 */
                          :szhFechahasta, /* Inc 137918 PPV 02/07/2010 */
                          :szhFormatoFecha; /* Inc 137918 PPV 02/07/2010 */

    }
    else
    {
         sprintf(szTablaBalan,"FA_BALANCE_%ld_%ld",lhCodCiclFact,lNroJob);
         sprintf(szTablaDetBalan,"FA_DETBALANCE_%ld_%ld",lhCodCiclFact,lNroJob);
         sprintf(szTablaCuotCredito,"FA_CUOTCREDITO_%ld_%ld",lhCodCiclFact,lNroJob);

         /* Inc 137918 PPV 24/06/2010 */
         sprintf(szCadenaSQL,"SELECT"
            "\n 'CANCE', "
            "\n A.NUM_ABONADO,"
            "\n B.IND_DETALLE,"
            "\n A.COD_TIPDOCUM,"
            "\n ' ' as COD_OFICINA,"
            "\n A.PREF_PLAZA,"
            "\n A.NUM_FOLIO,"
            "\n TO_CHAR(A.FEC_EFECTIVIDAD,:szhFormatoFechaCorto),"
            "\n A.SEC_CUOTA,"
            "\n A.NUM_CUOTA,"
            "\n SUM(DECODE(A.COD_TIPDOCUM,25,(ABS(A.IMPORTE_DEBE) * -1),A.IMPORTE_DEBE)), "
            "\n SUM(DECODE(A.COD_TIPDOCUM,25,(ABS(A.IMPORTE_HABER) * -1),A.IMPORTE_HABER)),"
            "\n 0 as MTO_SALDO, "
            "\n 0 as MTO_AJUSTE,"
            "\n 0 as TOT_BALANCE,"
            "\n 0 as IND_PAGO, "
            "\n DECODE(B.COD_REGISTRO,'B5020','B5010','B5030'), "
            "\n DECODE(A.COD_TIPDOCUM,53,'FDOCU',48,'FDOCU',B.COD_ORIGEN), "
            "\n 0, "
            "\n 'N' " /* para acelerada */
            "\n FROM "
            "\n  CO_CANCELADOS A, "
            "\n  FA_NEWCONFBALANCE_TD B, "
            "\n  FA_TIPDOCUMEN C "
            "\n WHERE A.COD_CLIENTE = :lhCodCliente"
            "\n  AND B.COD_ORIGEN       = 'CARUP' "
            "\n  AND B.COD_REGISTRO     IN ('B5020','B5040') "
            "\n  AND B.COD_TIPDOCUM     = A.COD_TIPDOCUM"
            "\n  AND B.IND_IMPRESION    = :iUno"
            "\n  AND C.COD_TIPDOCUMMOV  = B.COD_TIPDOCUM"
            "\n  AND C.IND_CICLO        = :iCero"
            "\n  AND A.FEC_PAGO >= TO_DATE (:szhFechadesde,:szhFormatoFecha)"
            "\n  AND A.FEC_PAGO <= TO_DATE (:szhFechahasta,:szhFormatoFecha)"
            "\n  AND A.NUM_CUOTA > 0"
            "\n  AND A.IND_FACTURADO = 0"
            "\n GROUP BY A.NUM_ABONADO,  B.IND_DETALLE,  A.COD_TIPDOCUM,  A.PREF_PLAZA,  A.NUM_FOLIO,  "
            "\n A.FEC_EFECTIVIDAD,  A.SEC_CUOTA,  A.NUM_CUOTA,  "
            "\n B.COD_REGISTRO, B.COD_ORIGEN"
            "\n UNION " /*INICIO PPQL 201822*/
            "\n SELECT " 
            "\n ROWIDTOCHAR(A.ROWID),"
            "\n B.NUM_ABONADO,"
            "\n C.IND_DETALLE,"
            "\n A.COD_TIPDOCUM,"
            "\n A.COD_OFICINA,"
            "\n A.PREF_PLAZA,"
            "\n A.NUM_FOLIO,"
            "\n TO_CHAR(A.FEC_TRANSACCION,:szhFormatoFechaCorto),"
            "\n B.NUM_CUOTA,"
            "\n B.NUM_TOTCUOTA,"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_DEBE) * -1),B.MTO_DEBE),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_HABER) * -1),B.MTO_HABER),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_SALDO) * -1),B.MTO_SALDO),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(A.MTO_AJUSTE) * -1),A.MTO_AJUSTE),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(A.TOT_BALANCE) * -1),A.TOT_BALANCE),"
            "\n C.IND_PAGO, "
            "\n C.COD_REGISTRO, "
            "\n C.COD_ORIGEN, "
            "\n NVL((SELECT 1 FROM FA_NEWCONFBALANCE_TD Z WHERE A.COD_TIPDOCUM=25 AND A.COD_TIPDOCUMREL= Z.COD_TIPDOCUM AND Z.COD_ORIGEN='CARUP'),0), "
            "\n 'N' " /* para acelerada */          
            "\nFROM "
            "\n FA_BALANCE_TO A,"
            "\n FA_DETBALANCE_TO B,"
            "\n FA_NEWCONFBALANCE_TD C,"
            "\n FA_TIPDOCUMEN D "
            "\n WHERE A.COD_CLIENTE      = :lhCodCliente"
            "\n AND B.SEC_BALANCE      = A.SEC_BALANCE"
            "\n AND C.COD_ORIGEN       = A.ORIGEN"
            "\n AND C.COD_TIPDOCUM     = A.COD_TIPDOCUM"
            "\n AND C.IND_IMPRESION    = :iUno"
            "\n AND D.COD_TIPDOCUMMOV  = C.COD_TIPDOCUM"
            "\n AND D.IND_CICLO        = :iCero"
            "\n AND A.FEC_TRANSACCION >= C.FEC_DESDE"
            "\n AND A.FEC_TRANSACCION <= C.FEC_HASTA " /*FIN PPQL 201822*/
            "\n UNION   "
            "\n SELECT  "
            "\n ROWIDTOCHAR(A.ROWID),"
            "\n B.NUM_ABONADO,"
            "\n C.IND_DETALLE,"
            "\n A.COD_TIPDOCUM,"
            "\n A.COD_OFICINA,"
            "\n A.PREF_PLAZA,"
            "\n A.NUM_FOLIO,"
            "\n TO_CHAR(A.FEC_TRANSACCION,:szhFormatoFechaCorto),"
            "\n B.NUM_CUOTA,"
            "\n B.NUM_TOTCUOTA,"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_DEBE) * -1),B.MTO_DEBE),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_HABER) * -1),B.MTO_HABER),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(B.MTO_SALDO) * -1),B.MTO_SALDO),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(A.MTO_AJUSTE) * -1),A.MTO_AJUSTE),"
            "\n DECODE(A.COD_TIPDOCUM,25,(ABS(A.TOT_BALANCE) * -1),A.TOT_BALANCE),"
            "\n C.IND_PAGO, "
            "\n C.COD_REGISTRO, "
            "\n C.COD_ORIGEN, "
            "\n NVL((SELECT 1 FROM FA_NEWCONFBALANCE_TD Z WHERE A.COD_TIPDOCUM=25 AND A.COD_TIPDOCUMREL= Z.COD_TIPDOCUM AND Z.COD_ORIGEN='CARUP'),0), "
            "\n J.IND_ACELERADA " /* para acelerada */
            "\nFROM"
            "\n %s A,"
            "\n %s B,"
            "\n FA_NEWCONFBALANCE_TD C,"
            "\n FA_TIPDOCUMEN D, "
            "\n (  SELECT  DISTINCT H.NUM_ABONADO, H.SEC_CUOTA, H.IND_ACELERADA , H.NUM_CUOTA, I.SEC_BALANCE " /* para acelerada */
            "\n FROM %s H, %s I " /* para acelerada */
            "\n WHERE H.COD_CLIENTE      = :lhCodCliente " /* para acelerada */
            "\n AND   H.NUM_ABONADO = I.NUM_ABONADO " /* para acelerada */
            "\n AND   H.SEC_CUOTA = I.NUM_CUOTA "
            "\n AND   H.NUM_CUOTA = I.NUM_TOTCUOTA) J " /* para acelerada */
            "\nWHERE A.COD_CLIENTE      = :lhCodCliente"
            "\n AND B.SEC_BALANCE      = A.SEC_BALANCE"
            "\n AND C.COD_ORIGEN       = A.ORIGEN"
            "\n AND C.COD_TIPDOCUM     = A.COD_TIPDOCUM"
            "\n AND C.IND_IMPRESION    = :iUno"
            "\n AND D.COD_TIPDOCUMMOV  = C.COD_TIPDOCUM"
            "\n AND D.IND_CICLO        = :iCero"
            "\n AND A.FEC_TRANSACCION >= C.FEC_DESDE"
            "\n AND A.FEC_TRANSACCION <= C.FEC_HASTA "
            "\n AND J.NUM_ABONADO = B.NUM_ABONADO " /* para acelerada */
            "\n AND J.SEC_CUOTA = B.NUM_CUOTA " /* para acelerada */
            "\n AND J.SEC_BALANCE = B.SEC_BALANCE " /* para acelerada */
            "\n AND   J.NUM_CUOTA = B.NUM_TOTCUOTA "
            /* "\n AND A.FEC_TRANSACCION >= TO_DATE (:szhFechadesde,:szhFormatoFecha)"  */ /* PGG 1.1 - 138693 - 23-06-2010 */
            "\n AND A.FEC_TRANSACCION <= TO_DATE (:szhFechahasta,:szhFormatoFecha) "  /* Inc 132916 (se fue en inc 137918) PPV Se deja tope final para que no tome cuotas insertadas por el trigger que deben ser facturadar el proximo ciclo */
            "\nUNION " /* --------------- De aqui en adelante solo cuotas de NC ----------------- */
            "\nSELECT"
            "\n 'CANCE', "
            "\n A.NUM_ABONADO,"
            "\n B.IND_DETALLE,"
            "\n A.COD_TIPDOCUM,"
            "\n ' ' as COD_OFICINA,"
            "\n A.PREF_PLAZA,"
            "\n A.NUM_FOLIO,"
            "\n TO_CHAR(A.FEC_EFECTIVIDAD,:szhFormatoFechaCorto),"
            "\n 0 , " /* A.SEC_CUOTA Se pone siempre 0 para que salga en el B5030 */
            "\n 0 , " /* A.NUM_CUOTA Se pone siempre 0 para que salga en el B5030 */
            "\n SUM(ABS(A.IMPORTE_DEBE) * -1), "
            "\n SUM(ABS(A.IMPORTE_HABER) * -1),"
            "\n 0 as MTO_SALDO, "
            "\n 0 as MTO_AJUSTE,"
            "\n 0 as TOT_BALANCE,"
            "\n 0 as IND_PAGO, "
            "\n B.COD_REGISTRO, "
            "\n B.COD_ORIGEN, "
            "\n 0, "
            "\n 'N' " /*para acelerada */
            "\n FROM "
            "\n  CO_CANCELADOS A, "
            "\n  FA_NEWCONFBALANCE_TD B, "
            "\n  FA_TIPDOCUMEN C "
            "\n WHERE A.COD_CLIENTE = :lhCodCliente"
            "\n  AND B.COD_ORIGEN       = 'FDOCU' "
            "\n  AND B.COD_REGISTRO     = 'B5030' "
            "\n  AND B.COD_TIPDOCUM     = A.COD_TIPDOCUM"
            "\n  AND B.IND_IMPRESION    = :iUno"
            "\n  AND C.COD_TIPDOCUMMOV  = B.COD_TIPDOCUM"
            "\n  AND C.IND_CICLO        = :iCero"
            "\n  AND A.FEC_EFECTIVIDAD >= TO_DATE (:szhFechadesde,:szhFormatoFecha)"
            "\n  AND A.FEC_EFECTIVIDAD <= TO_DATE (:szhFechahasta,:szhFormatoFecha)"
            "\n  AND A.NUM_CUOTA > 0"
            "\n  AND A.IND_FACTURADO = 1"
            "\n  AND A.COD_TIPDOCUM = 25"
            "\n AND EXISTS (SELECT 1 FROM FAD_CONFBALANCE Z WHERE Z.COD_ITEM = 4 AND Z.COD_ORIGEN IN ('CRED1','CREDI') AND Z.COD_TIPDOCUM = A.COD_TIPDOCUM)"
            "\n GROUP BY A.NUM_ABONADO,  B.IND_DETALLE,  A.COD_TIPDOCUM,  A.PREF_PLAZA,  A.NUM_FOLIO,  "
            "\n A.FEC_EFECTIVIDAD, "
            "\n B.COD_REGISTRO, B.COD_ORIGEN "
            "\n UNION "
            "\n SELECT"
            "\n 'CANCE', "
            "\n A.NUM_ABONADO,"
            "\n B.IND_DETALLE,"
            "\n A.COD_TIPDOCUM,"
            "\n ' ' as COD_OFICINA,"
            "\n A.PREF_PLAZA,"
            "\n A.NUM_FOLIO,"
            "\n TO_CHAR(A.FEC_EFECTIVIDAD,:szhFormatoFechaCorto),"
            "\n 0," /* A.SEC_CUOTA Se pone siempre 0 para que salga en el B5030 */
            "\n 0," /* A.NUM_CUOTA Se pone siempre 0 para que salga en el B5030 */
            "\n SUM(ABS(A.IMPORTE_HABER) * -1), "  /* Se considera el haber por que en la cartera solo hay haber */
            "\n SUM(ABS(A.IMPORTE_HABER) * -1), "  /* Se considera el haber por que en la cartera solo hay haber */
            "\n 0 as MTO_SALDO, "
            "\n 0 as MTO_AJUSTE,"
            "\n 0 as TOT_BALANCE,"
            "\n 0 as IND_PAGO, "
            "\n B.COD_REGISTRO, "
            "\n B.COD_ORIGEN, "
            "\n 0, "
            "\n 'N' " /*para acelerada */
            "\n FROM "
            "\n  CO_CARTERA A, "
            "\n  FA_NEWCONFBALANCE_TD B, "
            "\n  FA_TIPDOCUMEN C "
            "\n WHERE A.COD_CLIENTE = :lhCodCliente"
            "\n  AND B.COD_ORIGEN       = 'FDOCU' "
            "\n  AND B.COD_REGISTRO     = 'B5030' "
            "\n  AND B.COD_TIPDOCUM     = A.COD_TIPDOCUM"
            "\n  AND B.IND_IMPRESION    = :iUno"
            "\n  AND C.COD_TIPDOCUMMOV  = B.COD_TIPDOCUM"
            "\n  AND C.IND_CICLO        = :iCero"
            "\n  AND A.FEC_EFECTIVIDAD >= TO_DATE (:szhFechadesde,:szhFormatoFecha)"
            "\n  AND A.FEC_EFECTIVIDAD <= TO_DATE (:szhFechahasta,:szhFormatoFecha)"
            "\n  AND A.NUM_CUOTA > 0"
            "\n  AND A.IND_FACTURADO = 1"
            "\n  AND A.COD_TIPDOCUM = 25"
            "\n AND EXISTS (SELECT 1 FROM FAD_CONFBALANCE Z WHERE Z.COD_ITEM = 4 AND Z.COD_ORIGEN IN ('CRED1','CREDI') AND Z.COD_TIPDOCUM = A.COD_TIPDOCUM)"
            "\n GROUP BY A.NUM_ABONADO,  B.IND_DETALLE,  A.COD_TIPDOCUM,  A.PREF_PLAZA,  A.NUM_FOLIO,  "
            "\n	A.FEC_EFECTIVIDAD, "
            "\n	 B.COD_REGISTRO, B.COD_ORIGEN "
            "\n ORDER BY 2,4,6,7,9, 20 DESC"
          ,szTablaBalan
          ,szTablaDetBalan
          ,szTablaCuotCredito
          ,szTablaDetBalan
          /*,szTablaCuotCredito*/);

            vDTrazasLog( szModulo,"=> query JOB (\n%s\n)",LOG05,szCadenaSQL);

            EXEC SQL PREPARE Cur_BalanceJOB FROM :szCadenaSQL;

            if ( SQLCODE != SQLOK )
            {
            vDTrazasLog (szModulo, "Error en PREPARE Cur_BalanceJOB. Error [%d][%s]",LOG00,  SQLCODE, SQLERRM);
            return(FALSE);
            }

            EXEC SQL DECLARE curFacBalanceJOB CURSOR FOR Cur_BalanceJOB;
            if ( SQLCODE < SQLOK )
            {
            vDTrazasLog (szModulo, "Error en DECLARE. curFacBalanceJOB. Error [%d][%s]",LOG00,  SQLCODE, SQLERRM);
            return(FALSE);
            }

            EXEC SQL OPEN curFacBalanceJOB USING :szhFormatoFechaCorto,
                          :lhCodCliente,
                          :iUno,
                          :iCero,
                          :szhFechadesde,
                          :szhFormatoFecha,
                          :szhFechahasta,
                          :szhFormatoFecha,
                          :szhFormatoFechaCorto,/* INI PPQL 201822*/
                          :lhCodCliente,
                          :iUno,
                          :iCero,/* FIN PPQL 201822*/
                          :szhFormatoFechaCorto,
                          :lhCodCliente,
                          :lhCodCliente,
                          :iUno,
                          :iCero,
                          :szhFechahasta, /* Inc 139216 PPV 30/06/2010 Se agrega fecha tope */
                          :szhFormatoFecha, /* Inc 139216 PPV 30/06/2010 Se agrega fecha tope */
                          :szhFormatoFechaCorto,
                          :lhCodCliente,
                          :iUno,
                          :iCero,
                          :szhFechadesde,
                          :szhFormatoFecha,
                          :szhFechahasta,
                          :szhFormatoFecha,
                          :szhFormatoFechaCorto,
                          :lhCodCliente,
                          :iUno,
                          :iCero,
                          :szhFechadesde,
                          :szhFormatoFecha,
                          :szhFechahasta,
                          :szhFormatoFecha;
    }



    if ( SQLCODE < SQLOK )
    {
        vDTrazasLog (szModulo, "Error en OPEN curFacBalance. Error [%i][%s]",LOG00,  SQLCODE, SQLERRM);
        return(FALSE);
    }

    vDTrazasLog (szExeName,"\n\t\t* Open=> curFacBalance", LOG06);

/* P-ECU-09005 */

    return SQLCODE;
}/** END ifnOpenDetTransClie **/

/*************************************************************************************************/
/*  FUNCION : BOOL bfnFetchDetTransClie(DET_TRANSACCIONES_CLIE_HOST * pst_DetTransClie, long *lCantDetTrans) */
/*************************************************************************************************/
static BOOL bfnFetchDetTransClie(DET_TRANSACCIONES_CLIE_HOST * pst_DetTransClie, long *lCantDetTrans)
{

    if ( !lNroJob )
    {
        EXEC SQL FETCH curFacBalance
            INTO :pst_DetTransClie->szRowId            ,
             :pst_DetTransClie->lNumAbonado        ,
             :pst_DetTransClie->iIndDetalle        ,
             :pst_DetTransClie->iCodTipDocum       ,
             :pst_DetTransClie->szCodOficina       ,
             :pst_DetTransClie->szCodPlaza         ,
             :pst_DetTransClie->lNumFolio          ,
             :pst_DetTransClie->szFecTrans         ,
             :pst_DetTransClie->lNumCuota          ,
             :pst_DetTransClie->lNumTotalCuota     ,
             :pst_DetTransClie->dMontoDebe         ,
             :pst_DetTransClie->dMontoHaber        ,
             :pst_DetTransClie->dMontoSaldo        ,
             :pst_DetTransClie->dMontoAjuste       ,
             :pst_DetTransClie->dMontoTotBalance   ,
             :pst_DetTransClie->iIndPago           ,
             :pst_DetTransClie->szCodRegistro      ,
             :pst_DetTransClie->szCodOrigen        ,
             :pst_DetTransClie->iIndCaratula       ,
             :pst_DetTransClie->sz_IndAcelerada    ;
    }else{
            EXEC SQL FETCH curFacBalanceJOB
            INTO :pst_DetTransClie->szRowId            ,
             :pst_DetTransClie->lNumAbonado        ,
             :pst_DetTransClie->iIndDetalle        ,
             :pst_DetTransClie->iCodTipDocum       ,
             :pst_DetTransClie->szCodOficina       ,
             :pst_DetTransClie->szCodPlaza         ,
             :pst_DetTransClie->lNumFolio          ,
             :pst_DetTransClie->szFecTrans         ,
             :pst_DetTransClie->lNumCuota          ,
             :pst_DetTransClie->lNumTotalCuota     ,
             :pst_DetTransClie->dMontoDebe         ,
             :pst_DetTransClie->dMontoHaber        ,
             :pst_DetTransClie->dMontoSaldo        ,
             :pst_DetTransClie->dMontoAjuste       ,
             :pst_DetTransClie->dMontoTotBalance   ,
             :pst_DetTransClie->iIndPago           ,
             :pst_DetTransClie->szCodRegistro      ,
             :pst_DetTransClie->szCodOrigen        ,
             :pst_DetTransClie->iIndCaratula       ,
             :pst_DetTransClie->sz_IndAcelerada    ;

    }

    if((SQLCODE == SQLOK) && (SQLCODE != SQLNOTFOUND))
        vDTrazasError(szModulo,"\t\tError en Fetch %s : %s", LOG01, szModulo, SQLERRM);
    else
    {
        *lCantDetTrans = sqlca.sqlerrd[2];
    }
    return SQLCODE;
}/** END bfnFetchDetTransClie **/

/******************************************/
/*  FUNCION : ifnCloseDetTransClie(void) */
/******************************************/
static int ifnCloseDetTransClie(void)
{
    vDTrazasLog (szExeName,"\n\t\t* Close=> curFacBalance", LOG06);

    if ( !lNroJob )
    {
        EXEC SQL CLOSE curFacBalance;
    }else{
        EXEC SQL CLOSE curFacBalanceJOB;
    }

    if (SQLCODE != SQLOK)
       iDError (szExeName,ERR000,vInsertarIncidencia,"Close=> curFacBalance",
             szfnORAerror ());

    return SQLCODE;
}/** END ifnCloseDetTransClie **/



static int ifnOpenConfB4001(void)
{
    char *szModulo="ifnOpenConfB4001";

    char szhCodDominio  [15];
    char szhV           [2];

    vDTrazasLog (szModulo,"\n\t\t* En la funcion ifnOpenConfB4001", LOG06);

    strcpy(szhCodDominio  ,"AGRULLAM_B4001");
    strcpy(szhV  ,"V");

    EXEC SQL DECLARE Cur_RegB4001 CURSOR for
        SELECT
            TO_NUMBER(VALOR),
            DESCRIPCION_VALOR
        FROM FA_AGRULLAM_B4001_VW
        WHERE COD_DOMINIO = :szhCodDominio
          AND IND_ESTADO  = :szhV
        ORDER BY TO_NUMBER(VALOR) ASC;

    EXEC SQL OPEN Cur_RegB4001;

    if ( SQLCODE != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Open=> FA_AGRULLAM_B4001_VW",szfnORAerror ());
    }

    return (SQLCODE);
}/***************************** Final ifnOpenConfB4001 **********************/


static int ifnOpenRegistrosTipoD(void)
{
    char *szModulo="ifnOpenRegistrosTipoD";


    vDTrazasLog (szModulo,"\n\t\t* En la funcion ifnOpenRegistrosTipoD", LOG06);


    EXEC SQL DECLARE Cur_ConfRegTipD CURSOR for
        SELECT POSICION, COD_REGISTRO, TIP_REGISTRO, VALOR, TIP_TRAF /*MLA 123425*/
        FROM FA_REGDETLLAM_TD
        ORDER BY POSICION ASC;

    EXEC SQL OPEN Cur_ConfRegTipD;

    if ( SQLCODE != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Open=> Cur_ConfRegTipD",szfnORAerror ());
    }

    return (SQLCODE);
}/***************************** Final ifnOpenConfB4001 **********************/


static BOOL bfnFetchConfB4001 (REG_B4001_HOST *pstHost,int *piNumFilas)
{
    char *szModulo="bfnFetchConfB4001";

    vDTrazasLog (szModulo,"\n\t\t* En la funcion bfnFetchConfB4001", LOG06);

    EXEC SQL FETCH Cur_RegB4001
    INTO :pstHost->iPosicion ,
         :pstHost->szCodAgrullam;

    if ( SQLCODE==SQLOK )
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if ( SQLCODE==SQLNOTFOUND )
        *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
    else
        iDError (szModulo,ERR000,vInsertarIncidencia,"Fetch=> FA_AGRULLAM_B4001_VW", szfnORAerror ());
    return (SQLCODE);
}/***************************** Final bfnFetchConfB4001 ****************/

static BOOL bfnFetchRegistrosTipoD (REGTIP_D_HOST *pstHost,int *piNumFilas)
{
    char *szModulo="bfnFetchRegistrosTipoD";

    vDTrazasLog (szModulo,"\n\t\t* En la funcion bfnFetchRegistrosTipoD", LOG06);

    EXEC SQL FETCH Cur_ConfRegTipD
    INTO :pstHost->iPosicion ,
         :pstHost->szCodRegistro,
         :pstHost->szCodTipLlam,
         :pstHost->szCodValor,
         :pstHost->szTipTraf; /*MLA 123425*/

    if ( SQLCODE==SQLOK )
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if ( SQLCODE==SQLNOTFOUND )
        *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
    else
        iDError (szModulo,ERR000,vInsertarIncidencia,"Fetch=> Cur_ConfRegTipD", szfnORAerror ());
    return (SQLCODE);
}/***************************** Final bfnFetchRegistrosTipoD ****************/


static int ifnCloseRegistrosTipoD(void)
{
    char *szModulo="ifnCloseRegistrosTipoD";

    vDTrazasLog (szModulo,"\n\t\t* En la funcion ifnCloseRegistrosTipoD", LOG06);

    EXEC SQL CLOSE Cur_ConfRegTipD;

    if ( SQLCODE != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Close=> Cur_ConfRegTipD",szfnORAerror ());
    }

    return (SQLCODE);
}/***************************** Final ifnCloseRegistrosTipoD **********************/

static int ifnCloseConfB4001(void)
{
    char *szModulo="ifnCloseConfB4001";

    vDTrazasLog (szModulo,"\n\t\t* En la funcion ifnCloseConfB4001", LOG06);

    EXEC SQL CLOSE Cur_RegB4001;

    if ( SQLCODE != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Close=> Cursor=> FA_AGRULLAM_B4001_VW",szfnORAerror ());
    }

    return (SQLCODE);
}/***************************** Final ifnCloseConfB4001 **********************/

BOOL bfnCargaConfB4001 (REG_B4001 **stRegB4001, int *iNumRegB4001)
{
    int     rc = 0;
    int     iNumFilas;
    static  REG_B4001_HOST stRegB4001Host;
    REG_B4001 *stRegB4001Temp;
    int     iCont;
    char *szModulo="CargaConfB4001";

    vDTrazasLog (szModulo,"\n\t* Carga Configuracion Registro B4001 ", LOG06);

    *iNumRegB4001 = 0;
    *stRegB4001 = NULL;

    if ( ifnOpenConfB4001() )
        return (FALSE);

    while ( rc != SQLNOTFOUND )
    {
        rc = bfnFetchConfB4001(&stRegB4001Host,&iNumFilas);
        if ( rc != SQLOK  && rc != SQLNOTFOUND )
            return (FALSE);

        if ( !iNumFilas )
            break;

        *stRegB4001 =(REG_B4001*) realloc(*stRegB4001,(int)(((*iNumRegB4001)+iNumFilas)*sizeof(REG_B4001)));

        if ( !*stRegB4001 )
        {
            iDError (szModulo,ERR000,vInsertarIncidencia,
             "Error bCargaConfB4001", "no se pudo reservar memoria");
            return (FALSE);
        }

        stRegB4001Temp = &(*stRegB4001)[(*iNumRegB4001)];
        memset(stRegB4001Temp, 0, (int)(sizeof(REG_B4001)*iNumFilas));
        for ( iCont = 0 ; iCont < iNumFilas ; iCont++ )
        {
            stRegB4001Temp[iCont].iPosicion      = stRegB4001Host.iPosicion[iCont];
            strcpy( stRegB4001Temp[iCont].szCodAgrullam  , stRegB4001Host.szCodAgrullam[iCont]);
        }
        (*iNumRegB4001) += iNumFilas;

    }/* fin while */

    vDTrazasLog (szModulo,"\n\t\t* Configuracion de Registros B4001 cargados :[%d]", LOG04, *iNumRegB4001);

    rc = ifnCloseConfB4001();
    if ( rc != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Error bCargaConfB4001", szfnORAerror ());
        return (FALSE);
    }

    vDTrazasLog (szModulo,"\n\t\t* (bCargaConfB4001) Saliendo de la funcion...", LOG06);

    return(TRUE);
}/***************************** Final bCargaConfB4001 *********************/

BOOL bfnCargaRegistrosTipoD (REGTIP_D **stRegTipD, int *iNumRegD)
{
    int     rc = 0;
    int     iNumFilas;
    static  REGTIP_D_HOST stRegTipDHost;
    REGTIP_D *stRegTipDTemp;
    int     iCont;
    char *szModulo="bfnCargaRegistrosTipoD";

    vDTrazasLog (szModulo,"\n\t* Carga Configuracion Registro D ", LOG06);

    *iNumRegD  = 0;
    *stRegTipD = NULL;

    if ( ifnOpenRegistrosTipoD() )
        return (FALSE);

    while ( rc != SQLNOTFOUND )
    {
        rc = bfnFetchRegistrosTipoD(&stRegTipDHost,&iNumFilas);
        if ( rc != SQLOK  && rc != SQLNOTFOUND )
            return (FALSE);

        if ( !iNumFilas )
            break;

        *stRegTipD =(REGTIP_D*) realloc(*stRegTipD,(int)(((*iNumRegD)+iNumFilas)*sizeof(REGTIP_D)));

        if ( !*stRegTipD )
        {
            iDError (szModulo,ERR000,vInsertarIncidencia,
             "Error bfnCargaRegistrosTipoD", "no se pudo reservar memoria");
            return (FALSE);
        }

        stRegTipDTemp = &(*stRegTipD)[(*iNumRegD)];
        memset(stRegTipDTemp, 0, (int)(sizeof(REGTIP_D)*iNumFilas));
        for ( iCont = 0 ; iCont < iNumFilas ; iCont++ )
        {
            stRegTipDTemp[iCont].iPosicion      = stRegTipDHost.iPosicion[iCont];
            strcpy( stRegTipDTemp[iCont].szCodRegistro  , alltrim(stRegTipDHost.szCodRegistro[iCont]));
            strcpy( stRegTipDTemp[iCont].szCodTipLlam   , alltrim(stRegTipDHost.szCodTipLlam[iCont]));
            strcpy( stRegTipDTemp[iCont].szCodValor     , alltrim(stRegTipDHost.szCodValor[iCont]));
            strcpy( stRegTipDTemp[iCont].szTipTraf      , alltrim(stRegTipDHost.szTipTraf[iCont])); /*MLA 123425*/
        }
        (*iNumRegD) += iNumFilas;

    }/* fin while */

    vDTrazasLog (szModulo,"\n\t\t* Configuracion de Registros D cargados :[%d]", LOG04, *iNumRegD);

    rc = ifnCloseRegistrosTipoD();
    if ( rc != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Error bfnCargaRegistrosTipoD", szfnORAerror ());
        return (FALSE);
    }

    vDTrazasLog (szModulo,"\n\t\t* (bfnCargaRegistrosTipoD) Saliendo de la funcion...", LOG06);

    return(TRUE);
}/***************************** Final bfnCargaRegistrosTipoD *********************/


/*******************************************************************************************/
/*  FUNCION : bfnCargaDetTransClie (DET_TRANSACCIONES_CLIE **pstDetTransClie, int *iNumDetTrans, long lCodCliente) */
/*******************************************************************************************/

BOOL bfnCargaDetTransClie (DET_TRANSACCIONES *pstDetTrans,
               ST_CICLOFACT      *sthFa_CicloFact,
               long              lCodCliente,
               long              lNumProceso,
               long              lCodCiclFact)
{
    int              rc = 0;
    int              ihNumRegTrans=0;
    int              iFlagTrans = FALSE;
    int              iIdxTrans = 0;
    long             lNumFilas;
    static  DET_TRANSACCIONES_CLIE_HOST stDetTransClieHost;
    MOVIM_CLIE           *pstMovimClieTemp;
    PAGOS_CLIE           *pstPagosClieTemp;
    RES_MOVIM_CLIE       *pstResMovimClieTemp;
    RES_PAGOS_CLIE       *pstResPagosClieTemp;
    DET_MOVIM_CLIE       *pstDetMovimClieTemp;
    DET_PAGOS_CLIE       *pstDetPagosClieTemp;
    DET_ABON_MOVIM_CLIE  *pstDetAbonMovimClieTemp;
    DET_ABON_PAGOS_CLIE  *pstDetAbonPagosClieTemp;
    long             lCont;
    long   			     lNum_Folio_Rel;
    char   				 szPrefPlaza_Rel[11];

    vDTrazasLog (szExeName,"\n\t* Carga Detalle de Transacciones del Cliente [%ld] ", LOG06,lCodCliente);

    strcpy(pstDetTrans->szFecDesde,sthFa_CicloFact->fec_desde);
    strcpy(pstDetTrans->szFecHasta,sthFa_CicloFact->fec_hasta);
    pstDetTrans->dTotalTransDebe   = 0;
    pstDetTrans->dTotalTransHaber  = 0;
    pstDetTrans->dTotalTransSaldo  = 0;

    /*Inicio Movimientos del Cliente*/
    pstMovimClieTemp = &pstDetTrans->stMovimClie;
    memset(pstMovimClieTemp, 0, sizeof(MOVIM_CLIE)*1);

    pstMovimClieTemp->iNumRegResMov  = 0;
    pstMovimClieTemp->iNumRegDetMov  = 0;
    /*Fin Movimientos del Cliente*/

    /*Inicio Pagos del Cliente*/
    pstPagosClieTemp = &pstDetTrans->stPagosClie;
    memset(pstPagosClieTemp, 0, sizeof(PAGOS_CLIE)*1);

    pstPagosClieTemp->iNumRegResPag  = 0;
    pstPagosClieTemp->iNumRegDetPag  = 0;
    /*Fin Pagos del Cliente*/

    if (ifnOpenDetTransClie(sthFa_CicloFact,lCodCliente,lCodCiclFact))
        return FALSE;

    while (rc != SQLNOTFOUND)
    {
        rc = bfnFetchDetTransClie(&stDetTransClieHost,&lNumFilas);
        if (rc != SQLOK  && rc != SQLNOTFOUND)
        return FALSE;

        vDTrazasLog (szExeName,"\n\t* lNumFilas [%ld] ", LOG06,lNumFilas);
        if (!lNumFilas)
            break;

        for (lCont = 0 ; lCont < lNumFilas ; lCont++)
        {
            /*INICIO TOTALES TRANSACCIONES*/
            pstDetTrans->dTotalTransDebe  +=stDetTransClieHost.dMontoDebe      [lCont];
            pstDetTrans->dTotalTransHaber +=stDetTransClieHost.dMontoHaber     [lCont];
            pstDetTrans->dTotalTransSaldo +=stDetTransClieHost.dMontoSaldo     [lCont];
            /*FIN TOTALES TRANSACCIONES*/
            if (stDetTransClieHost.iIndPago[lCont]== 0) /*Movimiento*/
            {
            /* INICIO DETALLE DE MOVIEMIENTOS*/
            if(stDetTransClieHost.iIndDetalle[lCont] == 1 )
            {
            ihNumRegTrans = pstMovimClieTemp->iNumRegDetMov;
            iFlagTrans = FALSE;

            for (iIdxTrans = 0 ; iIdxTrans < ihNumRegTrans; iIdxTrans++)
            {
            if ( pstMovimClieTemp->stDetMovimClie[iIdxTrans].lNumAbonado == stDetTransClieHost.lNumAbonado[lCont] )
            {
                pstDetMovimClieTemp = &pstMovimClieTemp->stDetMovimClie[iIdxTrans];

                pstDetMovimClieTemp->dMontoDetDebe  += stDetTransClieHost.dMontoDebe      [lCont];
                pstDetMovimClieTemp->dMontoDetHaber += stDetTransClieHost.dMontoHaber     [lCont];

                pstDetMovimClieTemp->stDetAbonMovimClie = (DET_ABON_MOVIM_CLIE*) realloc(pstDetMovimClieTemp->stDetAbonMovimClie,((pstDetMovimClieTemp->lCantReg + 1)*sizeof(DET_ABON_MOVIM_CLIE)));
                if (!pstDetMovimClieTemp->stDetAbonMovimClie)
                {
                    iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error pstDetMovimClieTemp->stDetAbonMovimClie", "No se pudo reservar memoria");
                    return FALSE;
                }
                pstDetAbonMovimClieTemp = &pstDetMovimClieTemp->stDetAbonMovimClie[(pstDetMovimClieTemp->lCantReg)];
                memset(pstDetAbonMovimClieTemp, 0, sizeof(DET_ABON_MOVIM_CLIE)*1);

                strcpy(pstDetAbonMovimClieTemp->szFecTrans   , stDetTransClieHost.szFecTrans      [lCont]);
                strcpy(pstDetAbonMovimClieTemp->szCodOficina , stDetTransClieHost.szCodOficina    [lCont]);
                strcpy(pstDetAbonMovimClieTemp->szCodPlaza   , stDetTransClieHost.szCodPlaza      [lCont]);
                pstDetAbonMovimClieTemp->iCodTipDocum        = stDetTransClieHost.iCodTipDocum    [lCont];
                pstDetAbonMovimClieTemp->lNumFolio           = stDetTransClieHost.lNumFolio       [lCont];
                pstDetAbonMovimClieTemp->lNumCuota           = stDetTransClieHost.lNumCuota       [lCont];
                pstDetAbonMovimClieTemp->lNumTotalCuota      = stDetTransClieHost.lNumTotalCuota  [lCont];
                pstDetAbonMovimClieTemp->dMontoDetDebe       = stDetTransClieHost.dMontoDebe      [lCont];
                pstDetAbonMovimClieTemp->dMontoDetHaber      = stDetTransClieHost.dMontoHaber     [lCont];
                pstDetAbonMovimClieTemp->dMontoDetSaldo      = stDetTransClieHost.dMontoSaldo     [lCont];
							
							strcpy(pstDetAbonMovimClieTemp->sz_IndAcelerada, stDetTransClieHost.sz_IndAcelerada[lCont]); /*para acelerada */

                strcpy(pstDetAbonMovimClieTemp->szCodRegistro , stDetTransClieHost.szCodRegistro   [lCont]);

							if ( pstDetAbonMovimClieTemp->iCodTipDocum == stDatosGener.iCodNotaCre )
							{
	                if ( !bfnFolioRelacionado(lCodCliente,
                          pstDetAbonMovimClieTemp->lNumFolio,
                          pstDetAbonMovimClieTemp->szCodPlaza,
                          &lNum_Folio_Rel,
                          szPrefPlaza_Rel) )
                    {
                        iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error No se pudo obtener detalle documento de origen"
                          , "Obtiene folio rel");
                        return FALSE;
                    }

                    pstDetAbonMovimClieTemp->lNumFolioRel = lNum_Folio_Rel;
                    strcpy (pstDetAbonMovimClieTemp->szPrefPlazaRel, szPrefPlaza_Rel);

                    stDetTransClieHost.lNumFolioRel           [lCont] = lNum_Folio_Rel;
                	strcpy (stDetTransClieHost.szPrefPlazaRel [lCont], szPrefPlaza_Rel);
	    					}

                pstDetMovimClieTemp->lCantReg++;

                iFlagTrans = TRUE;

                break;
            }
            }

            if (!iFlagTrans)
            {
            pstMovimClieTemp->stDetMovimClie =(DET_MOVIM_CLIE*) realloc(pstMovimClieTemp->stDetMovimClie,((ihNumRegTrans + 1)*sizeof(DET_MOVIM_CLIE)));
            if (!pstMovimClieTemp->stDetMovimClie)
            {
                iDError (szExeName,ERR000,vInsertarIncidencia,
                      "Error pstMovimClieTemp->stDetMovimClie", "No se pudo reservar memoria");
                return FALSE;
            }
            pstDetMovimClieTemp = &pstMovimClieTemp->stDetMovimClie[ihNumRegTrans];
            memset(pstDetMovimClieTemp, 0, sizeof(DET_MOVIM_CLIE)*1);

            pstDetMovimClieTemp->lCantReg=0;
            pstDetMovimClieTemp->lNumAbonado    = stDetTransClieHost.lNumAbonado [lCont];
            pstDetMovimClieTemp->dMontoDetDebe  = stDetTransClieHost.dMontoDebe  [lCont];
            pstDetMovimClieTemp->dMontoDetHaber = stDetTransClieHost.dMontoHaber [lCont];


            pstDetMovimClieTemp->stDetAbonMovimClie =(DET_ABON_MOVIM_CLIE*) realloc(pstDetMovimClieTemp->stDetAbonMovimClie,((pstDetMovimClieTemp->lCantReg + 1)*sizeof(DET_ABON_MOVIM_CLIE)));
            if (!pstDetMovimClieTemp->stDetAbonMovimClie)
            {
                iDError (szExeName,ERR000,vInsertarIncidencia,
                      "Error pstDetMovimClieTemp->stDetAbonMovimClie", "No se pudo reservar memoria");
                return FALSE;
            }
            pstDetAbonMovimClieTemp = &pstDetMovimClieTemp->stDetAbonMovimClie[(pstDetMovimClieTemp->lCantReg)];
            memset(pstDetAbonMovimClieTemp, 0, sizeof(DET_ABON_MOVIM_CLIE)*1);

            strcpy(pstDetAbonMovimClieTemp->szFecTrans   , stDetTransClieHost.szFecTrans      [lCont]);
            strcpy(pstDetAbonMovimClieTemp->szCodOficina , stDetTransClieHost.szCodOficina    [lCont]);
            strcpy(pstDetAbonMovimClieTemp->szCodPlaza   , stDetTransClieHost.szCodPlaza      [lCont]);
            pstDetAbonMovimClieTemp->iCodTipDocum        = stDetTransClieHost.iCodTipDocum    [lCont];
            pstDetAbonMovimClieTemp->lNumFolio           = stDetTransClieHost.lNumFolio       [lCont];
            pstDetAbonMovimClieTemp->lNumCuota           = stDetTransClieHost.lNumCuota       [lCont];
            pstDetAbonMovimClieTemp->lNumTotalCuota      = stDetTransClieHost.lNumTotalCuota  [lCont];
            pstDetAbonMovimClieTemp->dMontoDetDebe       = stDetTransClieHost.dMontoDebe      [lCont];
            pstDetAbonMovimClieTemp->dMontoDetHaber      = stDetTransClieHost.dMontoHaber     [lCont];
            pstDetAbonMovimClieTemp->dMontoDetSaldo      = stDetTransClieHost.dMontoSaldo     [lCont];
						
						strcpy(pstDetAbonMovimClieTemp->sz_IndAcelerada, stDetTransClieHost.sz_IndAcelerada[lCont]); /*para acelerada */

            strcpy(pstDetAbonMovimClieTemp->szCodRegistro, stDetTransClieHost.szCodRegistro   [lCont]);

            if ( pstDetAbonMovimClieTemp->iCodTipDocum == stDatosGener.iCodNotaCre )
						{
                if ( !bfnFolioRelacionado(lCodCliente,
                          pstDetAbonMovimClieTemp->lNumFolio,
                          pstDetAbonMovimClieTemp->szCodPlaza,
                          &lNum_Folio_Rel,
                          szPrefPlaza_Rel) )
                {
                    iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error No se pudo obtener detalle documento de origen"
                          , "Obtiene folio rel");
                    return FALSE;
                }

                pstDetAbonMovimClieTemp->lNumFolioRel = lNum_Folio_Rel;
                strcpy (pstDetAbonMovimClieTemp->szPrefPlazaRel, szPrefPlaza_Rel);

                stDetTransClieHost.lNumFolioRel           [lCont] = lNum_Folio_Rel;
                strcpy (stDetTransClieHost.szPrefPlazaRel [lCont], szPrefPlaza_Rel);
    					}

            pstDetMovimClieTemp->lCantReg++;

            pstMovimClieTemp->iNumRegDetMov++;
            }
            }
            /* FIN DETALLE DE MOVIEMIENTOS*/

            /* INICIO RESUMEN DE MOVIEMIENTOS*/
            if(strcmp(stDetTransClieHost.szCodOrigen [lCont],"FDOCU")==0 &&
              stDetTransClieHost.iIndCaratula[lCont] == 0)
            {
            ihNumRegTrans = pstMovimClieTemp->iNumRegResMov;
            iFlagTrans = FALSE;

            for (iIdxTrans = 0 ; iIdxTrans < ihNumRegTrans; iIdxTrans++)
            {
            if ( pstMovimClieTemp->stResMovimClie[iIdxTrans].iCodTipDocum    == stDetTransClieHost.iCodTipDocum[lCont] &&
                 strcmp(pstMovimClieTemp->stResMovimClie[iIdxTrans].szCodPlaza, stDetTransClieHost.szCodPlaza[lCont])==0 &&
                 pstMovimClieTemp->stResMovimClie[iIdxTrans].lNumFolio       == stDetTransClieHost.lNumFolio[lCont])
            {
                pstMovimClieTemp->stResMovimClie[iIdxTrans].dTotalFactura += stDetTransClieHost.dMontoDebe[lCont];
                iFlagTrans = TRUE;
            }
            }

            if (!iFlagTrans)
            {
            pstMovimClieTemp->stResMovimClie =(RES_MOVIM_CLIE*) realloc(pstMovimClieTemp->stResMovimClie,((ihNumRegTrans + 1)*sizeof(RES_MOVIM_CLIE)));
            if (!pstMovimClieTemp->stResMovimClie)
            {
                iDError (szExeName,ERR000,vInsertarIncidencia,
                      "Error pstMovimClieTemp->stResMovimClie", "No se pudo reservar memoria");
                return FALSE;
            }
            pstResMovimClieTemp = &pstMovimClieTemp->stResMovimClie[ihNumRegTrans];
            memset(pstResMovimClieTemp, 0, sizeof(RES_MOVIM_CLIE)*1);

            strcpy(pstResMovimClieTemp->szCodOficina, stDetTransClieHost.szCodOficina [lCont]);
            pstResMovimClieTemp->iCodTipDocum       = stDetTransClieHost.iCodTipDocum [lCont];
            strcpy(pstResMovimClieTemp->szCodPlaza  , stDetTransClieHost.szCodPlaza   [lCont]);
            pstResMovimClieTemp->lNumFolio          = stDetTransClieHost.lNumFolio    [lCont];
            strcpy(pstResMovimClieTemp->szFecTrans  , stDetTransClieHost.szFecTrans   [lCont]);
            pstResMovimClieTemp->dTotalFactura      = stDetTransClieHost.dMontoDebe[lCont];

						/* para notas de credito se obtiene info dcumento de origen */
						if ( pstResMovimClieTemp->iCodTipDocum == stDatosGener.iCodNotaCre )
						{
							pstResMovimClieTemp->lNumFolioRel          = stDetTransClieHost.lNumFolioRel   [lCont];
                strcpy (pstResMovimClieTemp->szPrefPlazaRel, stDetTransClieHost.szPrefPlazaRel [lCont]);
    					}

            pstMovimClieTemp->iNumRegResMov++;
            }
            }
            /* FIN RESUMEN DE MOVIEMIENTOS*/

            }else{ /*Pagos*/

            /* INICIO DETALLE DE PAGOS*/
            if(stDetTransClieHost.iIndDetalle[lCont] == 1 )
            {
            ihNumRegTrans = pstPagosClieTemp->iNumRegDetPag;
            iFlagTrans = FALSE;

            for (iIdxTrans = 0 ; iIdxTrans < ihNumRegTrans; iIdxTrans++)
            {
            if ( pstPagosClieTemp->stDetPagosClie[iIdxTrans].lNumAbonado == stDetTransClieHost.lNumAbonado[lCont] )
            {

                pstDetPagosClieTemp = &pstPagosClieTemp->stDetPagosClie[iIdxTrans];

                pstDetPagosClieTemp->dMontoDetDebe  += stDetTransClieHost.dMontoDebe      [lCont];
                pstDetPagosClieTemp->dMontoDetHaber += stDetTransClieHost.dMontoHaber     [lCont];


                pstDetPagosClieTemp->stDetAbonPagosClie =(DET_ABON_PAGOS_CLIE*) realloc(pstDetPagosClieTemp->stDetAbonPagosClie,((pstDetPagosClieTemp->lCantReg + 1)*sizeof(DET_ABON_PAGOS_CLIE)));
                if (!pstDetPagosClieTemp->stDetAbonPagosClie)
                {
                    iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error pstDetPagosClieTemp->stDetAbonPagosClie", "No se pudo reservar memoria");
                    return FALSE;
                }

                pstDetAbonPagosClieTemp = &pstDetPagosClieTemp->stDetAbonPagosClie[(pstDetPagosClieTemp->lCantReg)];
                memset(pstDetAbonPagosClieTemp, 0, sizeof(DET_ABON_PAGOS_CLIE)*1);

                strcpy(pstDetAbonPagosClieTemp->szFecTrans   , stDetTransClieHost.szFecTrans      [lCont]);
                strcpy(pstDetAbonPagosClieTemp->szCodOficina , stDetTransClieHost.szCodOficina    [lCont]);
                strcpy(pstDetAbonPagosClieTemp->szCodPlaza   , stDetTransClieHost.szCodPlaza      [lCont]);
                pstDetAbonPagosClieTemp->iCodTipDocum        = stDetTransClieHost.iCodTipDocum    [lCont];
                pstDetAbonPagosClieTemp->lNumFolio           = stDetTransClieHost.lNumFolio       [lCont];
                pstDetAbonPagosClieTemp->lNumCuota           = stDetTransClieHost.lNumCuota       [lCont];
                pstDetAbonPagosClieTemp->lNumTotalCuota      = stDetTransClieHost.lNumTotalCuota  [lCont];
                pstDetAbonPagosClieTemp->dMontoDetDebe       = stDetTransClieHost.dMontoDebe      [lCont];
                pstDetAbonPagosClieTemp->dMontoDetHaber      = stDetTransClieHost.dMontoHaber     [lCont];
                pstDetAbonPagosClieTemp->dMontoDetSaldo      = stDetTransClieHost.dMontoSaldo     [lCont];
							
							strcpy(pstDetAbonPagosClieTemp->sz_IndAcelerada, stDetTransClieHost.sz_IndAcelerada[lCont]); /*para acelerada */

                strcpy(pstDetAbonPagosClieTemp->szCodRegistro, stDetTransClieHost.szCodRegistro   [lCont]);

							if ( pstDetAbonPagosClieTemp->iCodTipDocum == stDatosGener.iCodNotaCre )
							{
	                if ( !bfnFolioRelacionado(lCodCliente,
                          pstDetAbonPagosClieTemp->lNumFolio,
                          pstDetAbonPagosClieTemp->szCodPlaza,
                          &lNum_Folio_Rel,
                          szPrefPlaza_Rel) )
                    {
                        iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error No se pudo obtener detalle documento de origen"
                          , "Obtiene folio rel");
                        return FALSE;
                    }

                    pstDetAbonPagosClieTemp->lNumFolioRel = lNum_Folio_Rel;
                    strcpy (pstDetAbonPagosClieTemp->szPrefPlazaRel, szPrefPlaza_Rel);

                    stDetTransClieHost.lNumFolioRel           [lCont] = lNum_Folio_Rel;
                	strcpy (stDetTransClieHost.szPrefPlazaRel [lCont], szPrefPlaza_Rel);
	    					}

                pstDetPagosClieTemp->lCantReg++;

                iFlagTrans = TRUE;

                break;
            }
            }

            if (!iFlagTrans)
            {

            pstPagosClieTemp->stDetPagosClie =(DET_PAGOS_CLIE*) realloc(pstPagosClieTemp->stDetPagosClie,((ihNumRegTrans + 1)*sizeof(DET_PAGOS_CLIE)));
            if (!pstPagosClieTemp->stDetPagosClie)
            {
                iDError (szExeName,ERR000,vInsertarIncidencia,
                      "Error pstPagosClieTemp->stDetPagosClie", "No se pudo reservar memoria");
                return FALSE;
            }
            pstDetPagosClieTemp = &pstPagosClieTemp->stDetPagosClie[ihNumRegTrans];
            memset(pstDetPagosClieTemp, 0, sizeof(DET_PAGOS_CLIE)*1);

            pstDetPagosClieTemp->lCantReg=0;
            pstDetPagosClieTemp->lNumAbonado    = stDetTransClieHost.lNumAbonado [lCont];
            pstDetPagosClieTemp->dMontoDetDebe  = stDetTransClieHost.dMontoDebe  [lCont];
            pstDetPagosClieTemp->dMontoDetHaber = stDetTransClieHost.dMontoHaber [lCont];

            pstDetPagosClieTemp->stDetAbonPagosClie =(DET_ABON_PAGOS_CLIE*) realloc(pstDetPagosClieTemp->stDetAbonPagosClie,((pstDetPagosClieTemp->lCantReg + 1)*sizeof(DET_ABON_PAGOS_CLIE)));
            if (!pstDetPagosClieTemp->stDetAbonPagosClie)
            {
                iDError (szExeName,ERR000,vInsertarIncidencia,
                      "Error pstDetPagosClieTemp->stDetAbonPagosClie", "No se pudo reservar memoria");
                return FALSE;
            }
            pstDetAbonPagosClieTemp = &pstDetPagosClieTemp->stDetAbonPagosClie[(pstDetPagosClieTemp->lCantReg)];
            memset(pstDetAbonPagosClieTemp, 0, sizeof(DET_ABON_PAGOS_CLIE)*1);

            strcpy(pstDetAbonPagosClieTemp->szFecTrans   , stDetTransClieHost.szFecTrans      [lCont]);
            strcpy(pstDetAbonPagosClieTemp->szCodOficina , stDetTransClieHost.szCodOficina    [lCont]);
            strcpy(pstDetAbonPagosClieTemp->szCodPlaza   , stDetTransClieHost.szCodPlaza      [lCont]);
            pstDetAbonPagosClieTemp->iCodTipDocum        = stDetTransClieHost.iCodTipDocum    [lCont];
            pstDetAbonPagosClieTemp->lNumFolio           = stDetTransClieHost.lNumFolio       [lCont];
            pstDetAbonPagosClieTemp->lNumCuota           = stDetTransClieHost.lNumCuota       [lCont];
            pstDetAbonPagosClieTemp->lNumTotalCuota      = stDetTransClieHost.lNumTotalCuota  [lCont];
            pstDetAbonPagosClieTemp->dMontoDetDebe       = stDetTransClieHost.dMontoDebe      [lCont];
            pstDetAbonPagosClieTemp->dMontoDetHaber      = stDetTransClieHost.dMontoHaber     [lCont];
            pstDetAbonPagosClieTemp->dMontoDetSaldo      = stDetTransClieHost.dMontoSaldo     [lCont];

            strcpy(pstDetAbonPagosClieTemp->sz_IndAcelerada, stDetTransClieHost.sz_IndAcelerada[lCont]); /*para acelerada */

            strcpy(pstDetAbonPagosClieTemp->szCodRegistro, stDetTransClieHost.szCodRegistro   [lCont]);


						if ( pstDetAbonPagosClieTemp->iCodTipDocum == stDatosGener.iCodNotaCre )
						{
                if ( !bfnFolioRelacionado(lCodCliente,
                          pstDetAbonPagosClieTemp->lNumFolio,
                          pstDetAbonPagosClieTemp->szCodPlaza,
                          &lNum_Folio_Rel,
                          szPrefPlaza_Rel) )
                {
                    iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error No se pudo obtener detalle documento de origen"
                          , "Obtiene folio rel");
                    return FALSE;
                }

                pstDetAbonPagosClieTemp->lNumFolioRel = lNum_Folio_Rel;
                strcpy (pstDetAbonPagosClieTemp->szPrefPlazaRel, szPrefPlaza_Rel);

                stDetTransClieHost.lNumFolioRel           [lCont] = lNum_Folio_Rel;
                strcpy (stDetTransClieHost.szPrefPlazaRel [lCont], szPrefPlaza_Rel);
    					}

            pstDetPagosClieTemp->lCantReg++;

            pstPagosClieTemp->iNumRegDetPag++;
            }
            }
            /* FIN DETALLE DE PAGOS*/


            /* INICIO RESUMEN DE PAGOS*/
            ihNumRegTrans = pstPagosClieTemp->iNumRegResPag;
            iFlagTrans = FALSE;

            for (iIdxTrans = 0 ; iIdxTrans < ihNumRegTrans; iIdxTrans++)
            {
            if ( pstPagosClieTemp->stResPagosClie[iIdxTrans].iCodTipDocum == stDetTransClieHost.iCodTipDocum[lCont] )
            {
            pstPagosClieTemp->stResPagosClie[iIdxTrans].dTotalResDebe  += stDetTransClieHost.dMontoDebe      [lCont];
            pstPagosClieTemp->stResPagosClie[iIdxTrans].dTotalResHaber += stDetTransClieHost.dMontoHaber     [lCont];
            iFlagTrans = TRUE;
            }
            }

            if (!iFlagTrans)
            {
            pstPagosClieTemp->stResPagosClie =(RES_PAGOS_CLIE*) realloc(pstPagosClieTemp->stResPagosClie,((ihNumRegTrans + 1)*sizeof(RES_PAGOS_CLIE)));
            if (!pstPagosClieTemp->stResPagosClie)
            {
            iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error pstPagosClieTemp->stResPagosClie", "No se pudo reservar memoria");
            return FALSE;
            }
            pstResPagosClieTemp = &pstPagosClieTemp->stResPagosClie[ihNumRegTrans];
            memset(pstResPagosClieTemp, 0, sizeof(RES_PAGOS_CLIE)*1);

            pstResPagosClieTemp->iCodTipDocum   = stDetTransClieHost.iCodTipDocum    [lCont];
            pstResPagosClieTemp->dTotalResDebe  = stDetTransClieHost.dMontoDebe      [lCont];
            pstResPagosClieTemp->dTotalResHaber = stDetTransClieHost.dMontoHaber     [lCont];

            pstPagosClieTemp->iNumRegResPag++;
            }
            /* FIN RESUMEN DE PAGOS*/
            }
			/* P-ECU-09005 */
        	/* Inc 137275 PPV 10/06/2010 */
        	vDTrazasLog(szModulo,"\t\t lcont ==> [%ld]  stDetTransClieHost.szRowId[lCont] ==> [ %s ]",LOG05,lCont, stDetTransClieHost.szRowId[lCont]);
        	trim(stDetTransClieHost.szRowId[lCont],stDetTransClieHost.szRowId[lCont]);
        	/* Fin Inc 137275 PPV 10/06/2010 */

        	if (!lNroJob && strcmp(stDetTransClieHost.szRowId[lCont],"CANCE")!=0)
            {
            	    EXEC SQL
            	   		UPDATE FA_BALANCE_TO
            	   		   SET NUM_PROCESO  = :lNumProceso,
            	   COD_CICLFACT = :lCodCiclFact
             WHERE ROWID = :stDetTransClieHost.szRowId[lCont];


            if ( sqlca.sqlcode != SQLOK )
            {
             vDTrazasLog(szModulo, "Error en EXECUTE sql_Update_FaBalanceTo. Error [%i][%s]"
                     , LOG00, sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
             return(FALSE);
            }
            }
/* P-ECU-09005 */
        } /* fin for */

    }/* fin while */

    vDTrazasLog (szExeName,"\n\t\t* FIN Detalle de Transacciones del Cliente -> CanRegistros[%ld]", LOG06, lNumFilas);

    rc = ifnCloseDetTransClie();
    if (rc != SQLOK)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Error bfnCargaDetTransClie", szfnORAerror ());
        return FALSE;
    }
    return (TRUE);
}/** END bfnCargaDetTransClie **/



void vfnPrintCod_PlanTarif (PLAN_TARIFARIO *pstCodPlanTarif, int iNumCodPlanes)
{
    int i = 0;
    char *szModulo="vfnPrintCod_PlanTarif";

    if ( stStatus.LogNivel >= LOG06 )
    {
        vDTrazasLog (szModulo,"\n\t\t* Carga Planes Tarifarios [%d]", LOG06, iNumCodPlanes);

        for ( i=0;i<iNumCodPlanes;i++ )
        {
            vDTrazasLog (szModulo,"\n\t\t=> [%d]: Codigo de Plan        [%s]"
             "\n\t\t=> [%d]: Descripcion del Plan  [%s]"
             "\n\t\t=> [%d]: Tipo del Plan         [%s]"
             "\n\t\t=> [%d]: Minutos del Plan      [%ld]"
             "\n\t\t=> [%d]: Valor Plan            [%f]"
             "\n\t\t=> [%d]: Indicador de Arrastre [%ld]"
             ,LOG06
             ,i, pstCodPlanTarif[i].szCod_Plantarif
             ,i, pstCodPlanTarif[i].szDes_Plantarif
             ,i, pstCodPlanTarif[i].szTip_Plantarif
             ,i, pstCodPlanTarif[i].lMinutosPlan
             ,i, pstCodPlanTarif[i].dValorPlan
             ,i, pstCodPlanTarif[i].iInd_Arrastre   );
        }
    }
}/*************************** vfnPrintCod_PlanTarif *****************************/


int ifnCmpCod_PlanTarif(const void *cad1,const void *cad2)
{
    return( strcmp (((PLAN_TARIFARIO  *)cad1)->szCod_Plantarif,((PLAN_TARIFARIO  *)cad2)->szCod_Plantarif) );

}/*************************** ifnCmpCod_PlanTarif *****************************/


BOOL bfnFindCod_PlanTarif (char *szCodPlanTarif, PLAN_TARIFARIO *pstCodPlanTarif)
{
    char *szModulo="bfnFindCod_PlanTarif" ;
    PLAN_TARIFARIO  stkey;
    PLAN_TARIFARIO  *pstAux = (PLAN_TARIFARIO *)NULL;

    if ( strcmp(szCodPlanTarif,"")!= 0 )
    {
        strcpy(szCodPlanTarif,alltrim(szCodPlanTarif));
    }

    vDTrazasLog (szModulo, "\n\t\t* Busca Codigo de Plan Tarifario "
             "\n\t\t=> Cod. Plan Tarifario   [%s]"
             , LOG05,szCodPlanTarif );

    strcpy(stkey.szCod_Plantarif, szCodPlanTarif);

    if ( pstPlanes.iNumRegPlanTarif > 0 )
    {
        if ( (pstAux = (PLAN_TARIFARIO *)bsearch(&stkey, pstPlanes.stPlanesTarifarios , pstPlanes.iNumRegPlanTarif,
                         sizeof (PLAN_TARIFARIO),ifnCmpCod_PlanTarif ))== (PLAN_TARIFARIO *)NULL )
        {
            vDTrazasLog(szModulo, "Codigo de Plan Tarifario [%s] no encontrado ...", LOG01, szCodPlanTarif);
            return(FALSE);
        }
        memcpy (pstCodPlanTarif, pstAux, sizeof(PLAN_TARIFARIO));
    }
    else
    {
        vDTrazasLog(szModulo, "No existen datos para buscar en estructura de Planes tarifarios ...", LOG01);
    }
    return(TRUE);
}


#ifndef isnull
    #define isnull(name) (name==(char )NULL )
#endif
#ifndef strnull
    #define strnull(name) (name==(char *)NULL || name[0]==(char)NULL)
#endif

char *ltrim(char *s)
{
    char *p=s;
    if ( strnull(s) )
        return(s);
    while ( *p<=32 && *p>1 ) p++;
    strcpy(s,p);
    return(s);
}

char *rtrim(char *s)
{
    char *p=NULL;
    if ( strnull(s) )
        return(s);
    p=(s+_strlen(s)-1);
    while ( *p<=32 && *p>1 )  p--;
    *(++p)=0;
    return(s);
}

char *alltrim(char *s)
{
    return(ltrim(rtrim(s)));
}

/****************************************************************************/
/*                 funcion : CargaMultiIdiomas              */
/****************************************************************************/
BOOL CargaMultiIdiomas (GRPMULTIIDIOMA **pstGrpMulti, int *iNumGrpMulti)
{
    int     rc = 0;
    int    iNumFilas;
    static  GRPMULTIIDIOMAS_HOSTS stGrpMultiHost;
    GRPMULTIIDIOMA *pstGrpMultiTemp;
    int  iCont;

    char *szModulo="CargaMultiIdiomas";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG06,szModulo);

    *iNumGrpMulti = 0;
    *pstGrpMulti = NULL;

    if ( OpenMultiIdiomas() )
        return(FALSE);

    while ( rc != SQLNOTFOUND )
    {
        rc = FetchMultiIdiomas (&stGrpMultiHost,&iNumFilas);
        if ( rc != SQLOK  && rc != SQLNOTFOUND )
            return(FALSE);

        if ( !iNumFilas )
            break;

        *pstGrpMulti =(GRPMULTIIDIOMA*) realloc(*pstGrpMulti,(int)(((*iNumGrpMulti)+iNumFilas)*sizeof(GRPMULTIIDIOMA)));

        if ( !*pstGrpMulti )
        {
            iDError (szModulo,ERR000,vInsertarIncidencia,"Error CargaMultiIdiomas", "no se pudo reservar memoria");
            return(FALSE);
        }

        pstGrpMultiTemp = &(*pstGrpMulti)[(*iNumGrpMulti)];
        memset(pstGrpMultiTemp, 0, (int)(sizeof(GRPMULTIIDIOMA)*iNumFilas));

        for ( iCont = 0 ; iCont < iNumFilas ; iCont++ )
        {
            strcpy(pstGrpMultiTemp[iCont].szCod_Idioma_Grupos   ,alltrim(stGrpMultiHost.szCod_Idioma_Grupos [iCont]));
            strcpy(pstGrpMultiTemp[iCont].szGlosa_Grupo         ,stGrpMultiHost.szGlosa_Grupo   [iCont]);
            strcpy(pstGrpMultiTemp[iCont].szGlosa_Subgrp        ,alltrim(stGrpMultiHost.szGlosa_Subgrp  [iCont]));
        }
        (*iNumGrpMulti) += iNumFilas;
    }/* fin while */

    rc = CloseMultiIdiomas();
    if ( rc == SQLNOTFOUND )
        return (TRUE);

    if ( rc != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Error CargaMultiIdiomas", szfnORAerror ());
        return(FALSE);
    }
    if ( *iNumGrpMulti > 0 )
    {
        qsort((void*)*pstGrpMulti, *iNumGrpMulti, sizeof(GRPMULTIIDIOMA),ifnCmpGrpMulti);
        vfnPrintGrpMulti (*pstGrpMulti, *iNumGrpMulti);
    }
    return(TRUE);
}/***************************** Final CargaMultiIdiomas *********************/


/****************************************************************************/
/*                 funcion : OpenMultiIdiomas               */
/****************************************************************************/
int OpenMultiIdiomas ( void )
{
    char *szModulo="OpenMultiIdiomas";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL DECLARE curMultiIdiomas CURSOR FOR
    SELECT substr(TO_CHAR(TO_NUMBER(substr(C.COD_CONCEPTO,1,4)),'0009'),2) || C.COD_IDIOMA CONCEPTO,
           substr(B.DES_CONCEPTO,1,50),
           substr(C.DES_CONCEPTO,1,50)
    FROM FAD_IMPSUBGRUPOS A,
         GE_MULTIIDIOMA B,
         GE_MULTIIDIOMA C
    WHERE TO_CHAR(A.COD_GRUPO)=B.COD_CONCEPTO
      AND B.NOM_TABLA='FAD_IMPGRUPOS' AND B.NOM_CAMPO='COD_GRUPOS'
      AND TO_CHAR(A.COD_SUBGRUPO)=C.COD_CONCEPTO
      AND C.NOM_TABLA='FAD_IMPSUBGRUPOS' AND C.NOM_CAMPO='COD_SUBGRUPO'
      AND B.COD_IDIOMA=C.COD_IDIOMA
    ORDER BY CONCEPTO;

    EXEC SQL OPEN curMultiIdiomas;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-OPEN CURSOR curMultiIdiomas **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-OPEN CURSOR curMultiIdiomas **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return(SQLCODE);
    }
    return(SQLCODE);
}/*********************** Final de OpenMultiIdiomas ***********************/


/****************************************************************************/
/* Funcion: int FetchMultiIdiomas                       */
/* Funcion que realiza Fetch en el cursor de curMultiIdiomas             */
/****************************************************************************/
BOOL FetchMultiIdiomas (GRPMULTIIDIOMAS_HOSTS *pstHost,int  *piNumFilas)
{
    char *szModulo="FetchMultiIdiomas";

    EXEC SQL FETCH curMultiIdiomas
    INTO    :pstHost->szCod_Idioma_Grupos,
    :pstHost->szGlosa_Grupo ,
    :pstHost->szGlosa_Subgrp;

    if ( SQLCODE==SQLOK )
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if ( SQLCODE==SQLNOTFOUND )
        *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
    else
        iDError (szModulo,ERR000,vInsertarIncidencia,"Fetch=> Oficinas",
             szfnORAerror ());

    return (SQLCODE);
}/***************************** Final FetchMultiIdiomas ****************/


/****************************************************************************/
/*  Funcion: int CloseMultiIdiomas(void)                       */
/*  Funcion que cierra el cursor de curMultiIdiomas               */
/****************************************************************************/
int CloseMultiIdiomas(void)
{
    char *szModulo="CloseMultiIdiomas";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL CLOSE curMultiIdiomas;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasError(szModulo,"\tError al cerrar el Cursor curMultiIdiomas: %s",LOG01, SQLERRM);
    }
    return(SQLCODE);
}/****************Final de CloseMultiIdiomas *******************/


/****************************************************************************/
/*               funcion : vfnPrintFaCiclFact               */
/****************************************************************************/
void vfnPrintGrpMulti (GRPMULTIIDIOMA *pstEstruc, int iNumRegs)
{
    int i = 0;
    char *szModulo="vfnPrintGrpMulti";

    if ( stStatus.LogNivel >= LOG06 )
    {
        vDTrazasLog (szModulo,"\n\t\t* Carga Grupos Multiidiomas [%d]", LOG06, iNumRegs);

        for ( i=0;i<iNumRegs;i++ )
        {
            vDTrazasLog (szModulo,"\n\t\t=> [%d]: Codigo Idioma   [%s]"
             "\n\t\t=> [%d]: Glosa Grupo     [%s]"
             "\n\t\t=> [%d]: Glosa SubGrupo  [%s]"
             ,LOG06
             ,i, pstEstruc[i].szCod_Idioma_Grupos
             ,i, pstEstruc[i].szGlosa_Grupo
             ,i, pstEstruc[i].szGlosa_Subgrp);
        }
    }
}/*************************** vfnPrintOperadoras *****************************/


/****************************************************************************/
/*                 funcion : ifnCmpGrpMulti             */
/****************************************************************************/
int ifnCmpGrpMulti (const void *cad1,const void *cad2)
{
    return( strcmp (((GRPMULTIIDIOMA *)cad1)->szCod_Idioma_Grupos
            ,((GRPMULTIIDIOMA *)cad2)->szCod_Idioma_Grupos) );

}/*********************** Final de ifnCmpGrpMulti ***************************/


/****************************************************************************/
/*  Funcion: int BuscaMultiIdiomas                      */
/*  Funcion que busca un Concepto                       */
/****************************************************************************/
BOOL BuscaMultiIdiomas (char *szCod_Multiidioma, GRPMULTIIDIOMA *pstGrpMulti )
{
    GRPMULTIIDIOMA  stkey;
    GRPMULTIIDIOMA  *pstAux = (GRPMULTIIDIOMA *)NULL;
    char *szModulo="BuscaMultiIdiomas";

    vDTrazasLog (szModulo, "\n\t\t* Busca Grupo Multiidioma "
             "\n\t\t=> Codigo      [%s]"
             "\n\t\t=> Num.Grupos  [%d]"
             , LOG05,szCod_Multiidioma, stGrpMultiidiomas.iNumRegs);

    strcpy (stkey.szCod_Idioma_Grupos,szCod_Multiidioma);

    if ( stGrpMultiidiomas.iNumRegs > 0 )
    {
        if ( (pstAux = (GRPMULTIIDIOMA *)bsearch (&stkey, stGrpMultiidiomas.stGrpIdiomas, stGrpMultiidiomas.iNumRegs,
                          sizeof (GRPMULTIIDIOMA),ifnCmpGrpMulti ))== (GRPMULTIIDIOMA *)NULL )
        {
            vDTrazasLog(szModulo, "Codigo [%s] no encontrado ", LOG01, szCod_Multiidioma);
            return(FALSE);
        }
        memcpy (pstGrpMulti, pstAux, sizeof(GRPMULTIIDIOMA));
    }
    else
    {
        vDTrazasLog(szModulo, "No existen datos para buscar en estructura de Multiidiomas ...", LOG01);
    }
    return (TRUE);
}/**************************** Final BuscaMultiIdiomas *********************/


/****************************************************************************/
/*             funcion : CargaNumOrden                  */
/*  recupera los Numero de Orden de los Grupos, SubGrupos y Conceptos       */
/****************************************************************************/
BOOL CargaNumOrden (NUMORDEN **pstNumOrden, int *iNumRegs, int iCodFormulario )
{
    int     rc = 0;
    int    iNumFilas;
    static  NUMORDENES_HOSTS stNumOrdenHost;
    NUMORDEN *pstNumOrdenTemp;
    int  iCont;

    char *szModulo="CargaNumOrden";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG06,szModulo);

    *iNumRegs = 0;
    *pstNumOrden = NULL;

    if ( OpenNumOrden(iCodFormulario) )
        return(FALSE);

    while ( rc != SQLNOTFOUND )
    {
        rc = FetchNumOrden (&stNumOrdenHost,&iNumFilas);
        if ( rc != SQLOK  && rc != SQLNOTFOUND )
            return(FALSE);

        if ( !iNumFilas )
            break;

        *pstNumOrden =(NUMORDEN*) realloc(*pstNumOrden,(int)(((*iNumRegs)+iNumFilas)*sizeof(NUMORDEN)));

        if ( !*pstNumOrden )
        {
            iDError (szModulo,ERR000,vInsertarIncidencia,
             "Error CargaNumOrden", "no se pudo reservar memoria");
            return(FALSE);
        }

        pstNumOrdenTemp = &(*pstNumOrden)[(*iNumRegs)];
        memset(pstNumOrdenTemp, 0, (int)(sizeof(NUMORDEN)*iNumFilas));
        for ( iCont = 0 ; iCont < iNumFilas ; iCont++ )
        {
            pstNumOrdenTemp[iCont].iNum_OrdenGr     = stNumOrdenHost.iNum_OrdenGr[iCont];
            pstNumOrdenTemp[iCont].iNum_OrdenSubGr  = stNumOrdenHost.iNum_OrdenSubGr[iCont];
            pstNumOrdenTemp[iCont].iNum_OrdenConc   = stNumOrdenHost.iNum_OrdenConc[iCont];
            pstNumOrdenTemp[iCont].iCodGrupo        = stNumOrdenHost.iCodGrupo[iCont];
            pstNumOrdenTemp[iCont].iCodSubGrupo     = stNumOrdenHost.iCodSubGrupo[iCont];
            pstNumOrdenTemp[iCont].iCodConcepto     = stNumOrdenHost.iCodConcepto[iCont];
            strcpy(pstNumOrdenTemp[iCont].szCodRegistro ,alltrim(stNumOrdenHost.szCodRegistro[iCont]));
            pstNumOrdenTemp[iCont].iCodCriterio = stNumOrdenHost.iCodCriterio[iCont];
            pstNumOrdenTemp[iCont].iTipo_Llamada    = stNumOrdenHost.iTipo_Llamada[iCont];
            pstNumOrdenTemp[iCont].iTipo_SubGrupo   = stNumOrdenHost.iTipo_SubGrupo[iCont];
        }
        (*iNumRegs) += iNumFilas;
    }/* fin while */

    vDTrazasLog (szModulo,"\n\t\t* Numeros de Orden cargados [%ld]", LOG06, *iNumRegs);

    rc = CloseNumOrden();

    if ( rc != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Error CargaNumOrden", szfnORAerror ());
        return(FALSE);
    }

    qsort((void*)*pstNumOrden, *iNumRegs, sizeof(NUMORDEN),ifnCmpNumOrden);
    vfnPrintNumOrden (*pstNumOrden, *iNumRegs);
    return(TRUE);
}/***************************** Final CargaNumOrden *************************/


/****************************************************************************/
/*                 funcion : OpenNumOrden               */
/****************************************************************************/
int OpenNumOrden ( int iCodFormulario )
{
    char *szModulo="OpenNumOrden";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    ihZero = 0;

    EXEC SQL DECLARE curNumOrden CURSOR FOR
    SELECT  C.NUM_ORDEN GRP     ,
    B.NUM_ORDEN SGRP    ,
    A.NUM_ORDEN CONC    ,
    C.COD_GRUPO     ,
    B.COD_SUBGRUPO      ,
    A.COD_CONCEPTO      ,
    NVL(B.COD_REGISTRO,'D3001') ,
    NVL(B.CRIT_ORDEN,:ihZero) ,
    NVL(B.COD_TIPLLAMADA,:ihZero) ,
    B.COD_TIPSUBGRUPO
    FROM    FAD_IMPCONCEPTOS A  ,
    FAD_IMPSUBGRUPOS B  ,
    FAD_IMPGRUPOS C
    WHERE   A.COD_CONCEPTO  > :ihZero
    AND     A.COD_SUBGRUPO  = B.COD_SUBGRUPO
                  AND     B.COD_GRUPO     = C.COD_GRUPO
                  AND     C.COD_FORMULARIO= :iCodFormulario
                  ORDER BY A.COD_CONCEPTO;

    EXEC SQL OPEN curNumOrden;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-OPEN CURSOR curNumOrden **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-OPEN CURSOR curNumOrden **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return(SQLCODE);
    }
    return(SQLCODE);
}/*********************** Final de OpenNumOrden ***********************/


/****************************************************************************/
/* Funcion: int FetchNumOrden                           */
/* Funcion que realiza Fetch en el cursor de curNumOrden            */
/****************************************************************************/
BOOL FetchNumOrden (NUMORDENES_HOSTS *pstHost,int *piNumFilas)
{
    char *szModulo="FetchNumOrden";

    EXEC SQL FETCH curNumOrden
    INTO    :pstHost->iNum_OrdenGr      ,
    :pstHost->iNum_OrdenSubGr   ,
    :pstHost->iNum_OrdenConc    ,
    :pstHost->iCodGrupo     ,
    :pstHost->iCodSubGrupo      ,
    :pstHost->iCodConcepto      ,
    :pstHost->szCodRegistro     ,
    :pstHost->iCodCriterio      ,
    :pstHost->iTipo_Llamada     ,
    :pstHost->iTipo_SubGrupo    ;

    if ( SQLCODE==SQLOK )
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if ( SQLCODE==SQLNOTFOUND )
        *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
    else
        iDError (szModulo,ERR000,vInsertarIncidencia,"Fetch=> Num.Orden", szfnORAerror ());

    return (SQLCODE);
}/***************************** Final FetchNumOrden *********************/


/****************************************************************************/
/*  Funcion: int CloseNumOrden(void)                    */
/*  Funcion que cierra el cursor de CloseNumOrden               */
/****************************************************************************/
int CloseNumOrden(void)
{
    char *szModulo="CloseNumOrden";

    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL CLOSE curNumOrden;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasError(szModulo,"\tError al cerrar el Cursor curNumOrden: %s",LOG01, SQLERRM);
    }
    return(SQLCODE);
}/****************Final de CloseNumOrden *******************/


/****************************************************************************/
/*                 funcion : ifnCmpNumOrden             */
/****************************************************************************/
int ifnCmpNumOrden (const void *cad1,const void *cad2)
{
    return( ((NUMORDEN *)cad1)->iCodConcepto -((NUMORDEN *)cad2)->iCodConcepto) ;

}/*********************** Final de ifnCmpNumOrden ***************************/


/****************************************************************************/
/*  Funcion: int BuscaNumOrden                          */
/*  Funcion que busca para un Concepto el orden de impresion            */
/****************************************************************************/
BOOL BuscaNumOrden (int iCodConcepto, NUMORDEN *pstNumOrden )
{
    NUMORDEN  stkey;
    NUMORDEN  *pstAux = (NUMORDEN *)NULL;
    char *szModulo="BuscaNumOrden";

    vDTrazasLog (szModulo, "\n\t\t* Busca Num. Orden "
             "\n\t\t=> Concepto  [%d]"
             "\n\t\t=> Registros     [%d]"
             , LOG05,iCodConcepto, stNumOrdenes.iNumRegs);

    stkey.iCodConcepto=iCodConcepto;
    if ( stNumOrdenes.iNumRegs )
    {
        if ( (pstAux = (NUMORDEN *)bsearch (&stkey, stNumOrdenes.stNumOrden, stNumOrdenes.iNumRegs,
                        sizeof (NUMORDEN),ifnCmpNumOrden ))== (NUMORDEN *)NULL )
        {
            vDTrazasLog(szModulo, "Codigo [%d] no encontrado ", LOG01, iCodConcepto);
            return(FALSE);
        }
        memcpy (pstNumOrden, pstAux, sizeof(NUMORDEN));
    }
    else
    {
        vDTrazasLog(szModulo, "No existen datos para buscar en estructura de Orden ...", LOG01);
    }
    return (TRUE);
}/**************************** Final BuscaNumOrden  *************************/


/****************************************************************************/
/*               funcion : vfnPrintNumOrden             */
/****************************************************************************/
void vfnPrintNumOrden (NUMORDEN *pstEstruc, int iNumRegs)
{
    int i = 0;
    char *szModulo="vfnPrintNumOrden";

    if ( stStatus.LogNivel >= LOG06 )
    {
        vDTrazasLog (szModulo,"\n\t\t* Carga Tabla Numeros de Orden [%d]", LOG06, iNumRegs);

        for ( i=0;i<iNumRegs;i++ )
        {
            vDTrazasLog (szModulo,"\n\t\t=> [%d]: Orden Grupo     [%d]"
             "\n\t\t=> [%d]: Orden subGrupo  [%d]"
             "\n\t\t=> [%d]: Orden Concepto  [%d]"
             "\n\t\t=> [%d]: Codigo Grupo    [%d]"
             "\n\t\t=> [%d]: Codigo SubGrupo [%d]"
             "\n\t\t=> [%d]: Codigo Concepto [%d]"
             "\n\t\t=> [%d]: Codigo Registro [%s]"
             "\n\t\t=> [%d]: Codigo Criterio [%d]"
             ,LOG06
             ,i, pstEstruc[i].iNum_OrdenGr
             ,i, pstEstruc[i].iNum_OrdenSubGr
             ,i, pstEstruc[i].iNum_OrdenConc
             ,i, pstEstruc[i].iCodGrupo
             ,i, pstEstruc[i].iCodSubGrupo
             ,i, pstEstruc[i].iCodConcepto
             ,i, pstEstruc[i].szCodRegistro
             ,i, pstEstruc[i].iCodCriterio);
        }
    }
}/*************************** vfnPrintNumOrden *****************************/


extern BOOL CargaEstructuraInicial(NUMORDEN *pstNumOrden, int iCantOrdenes)
{
    int i;
    DETCELULAR_AGRUP  *stDetCelularTemp;

    for ( i=0; i < iCantOrdenes; i++ )
    {
        if ( pstNumOrden[i].iTipo_SubGrupo == 3 )
        {
            stDetCelular.stAgrupacion = (DETCELULAR_AGRUP*) realloc(stDetCelular.stAgrupacion, (int) (sizeof(DETCELULAR_AGRUP) * (stDetCelular.iCantEstructuras + 1)) );
            stDetCelularTemp = &(stDetCelular.stAgrupacion)[(stDetCelular.iCantEstructuras)];
            memset(stDetCelularTemp, 0, sizeof(DETCELULAR_AGRUP));

            stDetCelularTemp->iNum_OrdenGr      =  pstNumOrden[i].iNum_OrdenGr;
            stDetCelularTemp->iNum_OrdenSubGr   =  pstNumOrden[i].iNum_OrdenSubGr;
            stDetCelularTemp->iCodGrupo         =  pstNumOrden[i].iCodGrupo;
            stDetCelularTemp->iCodSubGrupo      =  pstNumOrden[i].iCodSubGrupo;
            stDetCelularTemp->iCriterio         =  pstNumOrden[i].iCodCriterio;
            stDetCelularTemp->iTipo_Llamada     =  pstNumOrden[i].iTipo_Llamada;
            strcpy(stDetCelularTemp->szCodRegistro,pstNumOrden[i].szCodRegistro);
            stDetCelular.iCantEstructuras++;
        }
    }
    return(TRUE);
}


/******************************************************************************************/
int OpenAbonado (long lCiclFact, long lIndOrden,DETALLEOPER *pst_MascaraOper)
{
    char szTablaAbon [40];
    char szQry       [2000];

    char *szModulo="OpenAbonado";

    vDTrazasLog(szModulo,"\t**Entrando a %s "
            "\n\t=> Ind.Ordentotal [%ld]"
            , LOG04, szModulo,lIndOrden);

    memset (szTablaAbon,0,sizeof(szTablaAbon));
    memset(szQry,0,sizeof(szQry));

		lhCodCilclFact= lCiclFact;

    if ( !lCiclFact )
    {
        sprintf(szTablaAbon,"FA_FACTABON_NOCICLO");
    }
    else
    {
        if ( !lNroJob )
        {
            sprintf(szTablaAbon,"FA_FACTABON_%ld",lCiclFact);
        }
        else
        {
            sprintf(szTablaAbon,"FA_FACTABON_%ld_%ld",lCiclFact, lNroJob);
        }
    }
    
    sprintf(szQry,
            "\n SELECT F.NUM_ABONADO ,"
            "\n        F.NUM_CELULAR ,"
            "\n        F.COD_DETFACT ,"
            "\n        F.COD_PRODUCTO,"
            "\n        NVL(REPLACE(F.NOM_USUARIO,'%%','N'),' '),"
            "\n        NVL(F.NOM_APELLIDO1,' '),"
            "\n        NVL(F.NOM_APELLIDO2,' '),"
            "\n        DECODE(F.NUM_ABONADO,0,0,F.COD_DETFACT) COD_DETFACT,"
            "\n        DECODE(F.COD_DETFACT,0,0,%d) IND_INTERZONA  ,"
            "\n        DECODE(F.COD_DETFACT,0,0,%d) IND_LDI        ,"
            "\n        DECODE(F.COD_DETFACT,0,0,%d) IND_ESPECIALES ,"
            "\n        DECODE(F.COD_DETFACT,0,0,%d) IND_CARRIER ,"
            "\n        DECODE(F.COD_DETFACT,0,0,%d) IND_LOCAL,"
            "\n        1 IND_ROAMING,"
            "\n        NVL (F.COD_DETFACT, 0)"
            "\n FROM    %s F "            
            "\n WHERE   F.IND_ORDENTOTAL = :lhIndOrdentotal"
            "\n AND     F.NUM_ABONADO    >= 0"
            "\n AND     F.NUM_CELULAR  IS NOT NULL"            
            "\n ORDER BY F.NUM_CELULAR" , pst_MascaraOper->iIndInterzona,
            pst_MascaraOper->iIndLDI,pst_MascaraOper->iIndEspeciales,
            pst_MascaraOper->iIndCarrier, pst_MascaraOper->iIndLocal,szTablaAbon);

    vDTrazasLog(szModulo,"\t\tQRY ABONADOS:[ %s ]",LOG05,szQry);

    EXEC SQL PREPARE sql_Cur_Abonado FROM :szQry;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-PREPARE sql_Abonados_DetLlam **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-PREPARE sql_Abonados_DetLlam **"
              "\t\tError : [%s] [%d]  [%s] ",LOG01,szQry,SQLCODE,SQLERRM);
        return(SQLCODE);
    }

    EXEC SQL DECLARE curAbonadoFact CURSOR FOR sql_Cur_Abonado;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-DECLARE curAbonadoFact **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-DECLARE curAbonadoFact **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return(SQLCODE);
    }

    lhIndOrdentotal = lIndOrden;

    EXEC SQL OPEN curAbonadoFact USING :lhIndOrdentotal;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo,"\n\t\tError en SQL-OPEN CURSOR curAbonadoFact **"
              "\n\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\n\t\tError en SQL-OPEN CURSOR curAbonadoFact **"
              "\n\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
    }

    return(SQLCODE);
}/*********************** Final de OpenAbonado ***********************/


/****************************************************************************/
/* Funcion: int FetchAbonado(ST_ABONADO *)                  */
/* Funcion que realiza Fetch en el cursor de curFactDoc             */
/****************************************************************************/
int FetchAbonado (ST_ABONADO *pstAbonadoFact)
{
    char *szModulo="FetchAbonado";

    vDTrazasLog(szModulo,"\t** Entrando en %s", LOG04,szModulo);
    EXEC SQL
    FETCH curAbonadoFact
    INTO :pstAbonadoFact->lNumAbonado    ,
    :pstAbonadoFact->lNumCelular    ,
    :pstAbonadoFact->iIndDetFact    ,
    :pstAbonadoFact->iCodProducto   ,
    :pstAbonadoFact->sznom_usuario  ,
    :pstAbonadoFact->sznom_apellido1,
    :pstAbonadoFact->sznom_apellido2,
    :pstAbonadoFact->iIndDetFact    ,
    :pstAbonadoFact->iIndInterzona  ,
    :pstAbonadoFact->iIndLdi        ,
    :pstAbonadoFact->iIndEspeciales ,
    :pstAbonadoFact->iIndCarrier    ,
    :pstAbonadoFact->iIndLocal      ,
    :pstAbonadoFact->iIndRoaming,
    :pstAbonadoFact->iIndDetLlam; /*P-ECU-10012 Se agrega ind_detalle*/

    if ( (SQLCODE != SQLOK) && (SQLCODE != SQLNOTFOUND) )
    {
        vDTrazasError(szModulo,"\t\tError en Fetch FetchAbonado : %s", LOG01, SQLERRM);
    }
    else
        pstAbonadoFact->CantidadAbonados = sqlca.sqlerrd[2];
    vDTrazasLog(szModulo,"\n\t\tCantidad Abonados  [%s]   : [%d]" ,LOG05, szModulo,pstAbonadoFact->CantidadAbonados);
    vDTrazasLog(szModulo,"\n\t\tCantidad Abonados  [%s]   : [%ld]",LOG05, szModulo,pstAbonadoFact->CantidadAbonados);

    return(SQLCODE);
}/*************************** Final de FetchAbonado ***************************/


/****************************************************************************/
/*  Funcion: int CloseAbonado(void)                          */
/*  Funcion que cierra el cursor de AbonadoFact                 */
/****************************************************************************/
int CloseAbonado(void)
{
    char *szModulo="CloseAbonado";

    vDTrazasLog(szModulo,"\t** Entrando en %s", LOG04,szModulo);
    EXEC SQL CLOSE curAbonadoFact;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasError(szModulo,"\tError al cerrar el Cursor FA_FACTABON_CICLO: %s",LOG01, SQLERRM);
        return(FALSE);
    }
    return(TRUE);
}/****************Final de bfnCloseFactTrafico *******************/


/*P-COL-05001 FC3  SCL - FACTURACIN - GAP IMPRESIN (2  1) 2005/05/17
Se agrega funcion iCargaFechaSuspension para rescatar la fecha de suspension de un cliente; este dato sera
imprimido en registro A1000.
*/
int iCargaFechaSuspension(long lCodCateg, char *sFVencim, char *sFecSuspen)
{
    int i;

    for ( i=0; i<stDias.iCantidadRegs ; i++ )
    {
        if ( lCodCateg == stDias.iDias[i] )
        {
            strcpy(sFecSuspen,stDias.szCategoria[i]);
            return(TRUE);
        }
    }

    return(FALSE);
}


/*********************************************************************************************/
/*P-COL-05001 FC3  SCL - FACTURACIN - GAP IMPRESIN (2  1) 2005/05/28
Se agrega funcion bfnCargaCodImptoFact para rescatar y poner estructura los datos de codigos de concepto*/
BOOL bfnCargaCodImptoFact(CODIMPTOSFACT *stImp_Fact)
{
    COD_IMPTOFACT *stImp_FactTemp;

    EXEC SQL BEGIN DECLARE SECTION;
    long lCod_Imp_fact;
    int  ihCodParametro = 207;
    EXEC SQL END DECLARE SECTION;

    strcpy(szModulo,"bfnCargaCodImptoFact");
    EXEC SQL DECLARE cImpFactura CURSOR FOR
    SELECT val_numerico
    FROM FAD_PARAMETROS
    WHERE COD_PARAMETRO = :ihCodParametro;

    EXEC SQL OPEN cImpFactura;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo, "\n\t**  Error : En Open Cursor cImpFactura \n%s\n",LOG01,SQLERRM);
        return(FALSE);
    }
    memset(stImp_Fact,0,sizeof(stImp_Fact));
    while ( SQLCODE != SQLNOTFOUND )
    {
        EXEC SQL FETCH cImpFactura INTO
        :lCod_Imp_fact;

        if ( SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK )
        {
            vDTrazasLog  (szModulo, "Error en Fetch de Cursor cImpFactura[%d]: %s",LOG01, SQLCODE, SQLERRM);
            return(FALSE);
        }
        if ( SQLCODE == SQLOK )
        {
            stImp_Fact->stCodImptosFact =(COD_IMPTOFACT *) realloc(stImp_Fact->stCodImptosFact,(int)((stImp_Fact->iNumReg + 1) * sizeof(COD_IMPTOFACT)));
            if ( stImp_Fact->stCodImptosFact == NULL )
            {
            iDError (szModulo,ERR000,vInsertarIncidencia,
             "Error bfnCargaCodImptoFact", "no se pudo reservar memoria");
            return (FALSE);
            }

            stImp_FactTemp = &(stImp_Fact->stCodImptosFact)[(stImp_Fact->iNumReg )];
            memset(stImp_FactTemp, 0, (int)(sizeof(COD_IMPTOFACT)));
            stImp_FactTemp->lCodImptoFact = lCod_Imp_fact;
            stImp_Fact->iNumReg ++ ;
        }
    }
    stImp_Fact->iNumReg= sqlca.sqlerrd[2];
    return(TRUE);
}/********************************************* bfnCargaCodImptoFact *********************************************/


BOOL bfnCargaGedPar()
{
    char szNomParam [21];
    char szValParam [21];
    char szCodModulo[3];

    memset(&stGedParametros,0,sizeof(stGedParametros));

    strcpy(szCodModulo, "FA");

    sprintf(szNomParam, "%20.20s\0", "TOL_COD_TDIA");
    if ( !bfnGetGedParam(szNomParam, szCodModulo, szValParam) )
    {
        return(FALSE);
    }
    strcpy (stGedParametros.szTolCodTDia,szValParam);


    sprintf(szNomParam, "%20.20s\0", "TOL_COD_LLAM");
    if ( !bfnGetGedParam(szNomParam, szCodModulo, szValParam) )
    {
        return(FALSE);
    }
    strcpy (stGedParametros.szTolCodLlam    ,szValParam    );


    sprintf(szNomParam, "%20.20s\0", "TOL_COD_TDIR");
    if ( !bfnGetGedParam(szNomParam, szCodModulo, szValParam) )
    {
        return(FALSE);
    }
    strcpy (stGedParametros.szTolCodTDir    ,szValParam    );

    sprintf(szNomParam, "%20.20s\0", "TOL_COD_THOR");
    if ( !bfnGetGedParam(szNomParam, szCodModulo, szValParam) )
    {
        return(FALSE);
    }
    strcpy (stGedParametros.szTolCodTHor    ,szValParam);

    sprintf(szNomParam, "%20.20s\0", "TOL_COD_THOR_ALTA");
    if ( !bfnGetGedParam(szNomParam, szCodModulo, szValParam) )
    {
        return(FALSE);
    }
    strcpy (stGedParametros.szTolCodTHorAlta,szValParam);

    sprintf(szNomParam, "%20.20s\0", "TOL_COD_THOR_BAJA");
    if ( !bfnGetGedParam(szNomParam, szCodModulo, szValParam) )
    {
        return(FALSE);
    }
    strcpy (stGedParametros.szTolCodTHorBaja,szValParam);

    sprintf(szNomParam, "%20.20s\0", "TOL_CON_CLIENTE");
    if ( !bfnGetGedParam(szNomParam, szCodModulo, szValParam) )
    {
        return(FALSE);
    }
    strcpy (stGedParametros.szTolConCliente ,szValParam );

    sprintf(szNomParam, "%20.20s\0", "TOL_COD_OPERADOR");
    if ( !bfnGetGedParam(szNomParam, szCodModulo, szValParam) )
    {
        return(FALSE);
    }
    strcpy (stGedParametros.szTolCodOperador,szValParam);

    sprintf(szNomParam, "%20.20s\0", "TOL_COD_SFRAN");
    if ( !bfnGetGedParam(szNomParam, szCodModulo, szValParam) )
    {
        return(FALSE);
    }
    strcpy (stGedParametros.szTolCodSFran   ,szValParam   );

    return(TRUE);
}/********************************************* bfnCargaGedPar *********************************************/


BOOL bfnGetGedParam(char * pszNomParam, char *pszCodModulo, char *pszValParam)
{

    EXEC SQL BEGIN DECLARE SECTION;
    char szhNomParametro[21];
    char szhValParametro[21];
    char szhCodModulo[3];
    int  ihCodProducto;
    EXEC SQL END DECLARE SECTION;
    char *szModulo="bfnGetGedParam";

    strcpy(szhNomParametro, alltrim(pszNomParam));
    strcpy(szhCodModulo, alltrim(pszCodModulo));
    ihCodProducto = 1;

    EXEC SQL
    SELECT VAL_PARAMETRO
    INTO :szhValParametro
    FROM GED_PARAMETROS
    WHERE NOM_PARAMETRO = :szhNomParametro
      AND COD_MODULO    = :szhCodModulo
      AND COD_PRODUCTO  = :ihCodProducto;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo, "\n\t**Error : En consulta parametro %s \n[%s]\n",LOG01,pszNomParam,SQLERRM);
        return(FALSE);
    }

    strcpy (pszValParam, szhValParametro);
    return(TRUE);

}/********************************************* bfnGetGedParam *********************************************/


BOOL bfnCargaCodImptoCateg(CATIMPUESTOS *st_catImpuestos)
{
    int j;
    CATIMPUES *stCatImpuestosTemp;
    EXEC SQL BEGIN DECLARE SECTION;
    long lcod_conc;
    int  icod_cat;
    int  iCodTipImpto;
    double dprc_imp;
    EXEC SQL END DECLARE SECTION;

    char *szModulo="bfnCargaCodImptoCateg";

    ihZero = 0;

    EXEC SQL DECLARE cCodImpCateg CURSOR FOR
    SELECT  DISTINCT (A.COD_CONCGENE),B.COD_CATEIMP, A.PRC_IMPUESTO, A.COD_TIPIMPUES
    FROM GE_IMPUESTOS A, GE_TIPIMPUES B
    WHERE A.COD_CATIMPOS >= :ihZero
    AND A.COD_ZONAIMPO >= :ihZero
    AND A.COD_ZONAABON >= :ihZero
    AND A.COD_TIPIMPUES = B.COD_TIPIMPUE
    AND A.COD_GRPSERVI >= :ihZero
    ORDER BY A.COD_CONCGENE ASC;

    EXEC SQL OPEN cCodImpCateg;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo, "\n\t**  Error : En Open Cursor cCodImpCateg \n%s\n",LOG01,SQLERRM);
        return(FALSE);
    }
    memset(st_catImpuestos,0,sizeof(st_catImpuestos));
    st_catImpuestos->iNumRegs= sqlca.sqlerrd[2];
    while ( SQLCODE != SQLNOTFOUND )
    {
        EXEC SQL FETCH cCodImpCateg INTO
        :lcod_conc,:icod_cat,:dprc_imp,:iCodTipImpto;

        if ( SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK )
        {
            vDTrazasLog  (szModulo, "Error en Fetch de Cursor cCodImpCateg[%ld]: %s",LOG01, SQLCODE, SQLERRM);
            return(FALSE);
        }

        st_catImpuestos->stCatImpuesto =(CATIMPUES *) realloc(st_catImpuestos->stCatImpuesto,((st_catImpuestos->iNumRegs + 1 ) * sizeof(CATIMPUES) ));

        if ( st_catImpuestos->stCatImpuesto == NULL )
        {
            iDError (szModulo,ERR000,vInsertarIncidencia,
             "Error bfnCargaCodImptoCateg", "no se pudo reservar memoria");
            return (FALSE);
        }
        stCatImpuestosTemp = &(st_catImpuestos->stCatImpuesto)[(st_catImpuestos->iNumRegs )];
        memset(stCatImpuestosTemp, 0, (int)(sizeof(CATIMPUES)));
        stCatImpuestosTemp->lCodConcepto    =lcod_conc;
        stCatImpuestosTemp->iCodCategoria   =icod_cat;
        stCatImpuestosTemp->dPrcImpuesto    =dprc_imp;
        stCatImpuestosTemp->iCodTipImpto    =iCodTipImpto;
        strcpy(stCatImpuestosTemp->szFlagImpto,"");
        st_catImpuestos->iNumRegs++;
    }

    vDTrazasLog(szModulo,"\n\tConjunto de Categorias Impositivas"
    					 "\n\t\tCONCEPTO|CATEGORIA|PORCENTAJE|TIPO IMPUESTO|FLAG",LOG05);
    for ( j=0;j<st_catImpuestos->iNumRegs;j++ )
    {
        vDTrazasLog(szModulo,"\t\t[%d] %ld|%d|%f|%d|%s|",LOG05,j
            ,st_catImpuestos->stCatImpuesto[j].lCodConcepto
            ,st_catImpuestos->stCatImpuesto[j].iCodCategoria
            ,st_catImpuestos->stCatImpuesto[j].dPrcImpuesto
            ,st_catImpuestos->stCatImpuesto[j].iCodTipImpto
            ,st_catImpuestos->stCatImpuesto[j].szFlagImpto);
    }
    return(TRUE);
}/********************************************* bfnCargaCodImptoCateg *********************************************/


/***********************************************************************************/
BOOL bfnTotImptosCateg(int iCodConcepto,int iColumna, double *pdTotalPrimeraCategoria, double *pdTotalSegundaCategoria )
{
    int i;
    char szLlaveBusqueda[10];
    char szLlaveDetConsumo[10];
    int iCategoria;
    double dAcumPrimeraCategoria=0;
    double dAcumSegundaCategoria=0;

    /*------------------------------------------------------------------------------------
     ACUMULA CONCEPTOS RELACIONADOS
    -------------------------------------------------------------------------------------*/
    char *szModulo="bfnTotImptosCateg";

    vDTrazasLog(szModulo, "\tEntro a %s ", LOG05, szModulo);
    sprintf(szLlaveBusqueda,"%04d|%06d",iCodConcepto,iColumna);
    vDTrazasLog(szModulo, "\t\t\tLlave de Busqueda [%s] ", LOG05, szLlaveBusqueda);

    for ( i=0; i < stFaDetCons.iNumReg; i++ )
    {
        sprintf(szLlaveDetConsumo,"%04d|%06d", stFaDetCons.stDetConsumo[i].iCodConcerel,stFaDetCons.stDetConsumo[i].iColumnaRel);

        if ( strcmp(szLlaveBusqueda,szLlaveDetConsumo)==0 && stFaDetCons.stDetConsumo[i].iCodTipConce ==1 && strcmp(szLlaveBusqueda,"0000|000000")!=0 )
        {
            if ( !bfnCategImpto(stFaDetCons.stDetConsumo[i].iCodConcepto,&iCategoria,stFaDetCons.stDetConsumo[i].dPrcImpuesto) )
            {
            vDTrazasLog(szModulo,"No pudo encontrar el concepto con su categoria [%d][%f]",LOG05,stFaDetCons.stDetConsumo[i].iCodConcepto, stFaDetCons.stDetConsumo[i].dPrcImpuesto);
            }
            else
            {
            vDTrazasLog(szModulo,"\n\tConcepto         [%d] Porcentaje       [%f]"
            					 "\n\tCategoria Actual [%d] Primera categoria [%d]"
            					 ,LOG05,stFaDetCons.stDetConsumo[i].iCodConcepto,stFaDetCons.stDetConsumo[i].dPrcImpuesto,iCategoria,iGPrimCateg);
            if ( iCategoria == iGPrimCateg )
            {
            dAcumPrimeraCategoria +=stFaDetCons.stDetConsumo[i].dTotalFacturableNet;
            }
            else
            {
            dAcumSegundaCategoria +=stFaDetCons.stDetConsumo[i].dTotalFacturableNet;
            }
            }
        }
    }
    *pdTotalPrimeraCategoria=dAcumPrimeraCategoria;
    *pdTotalSegundaCategoria=dAcumSegundaCategoria;

    return(TRUE);
}
/*********************************************************************************************/
BOOL bfnCategImpto(int iCodConcepto, int *iCodCategoria,double dPrcImpto)
{
    CATIMPUES  stkey;
    CATIMPUES *elementoPtr = (CATIMPUES *)NULL;
    char *szModulo="bfnCategImpto";

    vDTrazasLog (szModulo, "\n\t* Busca Categoria del Impuesto \n\t Cod. Concepto [%d] \n\t Porcentaje [%f]", LOG05,iCodConcepto,dPrcImpto);
    stkey.lCodConcepto=iCodConcepto;
    stkey.dPrcImpuesto=dPrcImpto;

    if ( pstCatImpues.iNumRegs > 0 )
    {
        if ( (elementoPtr = (CATIMPUES *)bsearch (&stkey, pstCatImpues.stCatImpuesto , pstCatImpues.iNumRegs,
                          sizeof (CATIMPUES),ifnCmpCodImptos )) == (CATIMPUES *)NULL )
        {
            return(FALSE);
        }
    }
    else
    {
        vDTrazasLog(szModulo, "No existen datos para buscar en estructura de Categorias de impuestos ...", LOG01);
        return(FALSE);
    }

    *iCodCategoria=elementoPtr->iCodCategoria;
    strcpy(elementoPtr->szFlagImpto,"S");            /* Marco el Impuesto para determinar que porcentajes  debo sumar */

    return(TRUE);
}
/***********************************************************************************/
int ifnCmpCodImptos (const void *cad1,const void *cad2)
{
    if ( ((CATIMPUES *)cad1)->lCodConcepto < ((CATIMPUES *)cad2)->lCodConcepto ) return (-1);
    else if ( ((CATIMPUES  *)cad1)->lCodConcepto > ((CATIMPUES  *)cad2)->lCodConcepto ) return (1);
    else if ( ((CATIMPUES  *)cad1)->dPrcImpuesto < ((CATIMPUES  *)cad2)->dPrcImpuesto ) return (-1);
    else if ( ((CATIMPUES  *)cad1)->dPrcImpuesto > ((CATIMPUES  *)cad2)->dPrcImpuesto ) return (1);
    return (0);

}
/***********************************************************************************/
BOOL bfnPorcenImptosCateg(double *pdTotalPorcenPrimeraCateg, double *pdTotalPorcenSegundaCateg )
{
    int i;
    double dPorcenPrimeraCategoria=0;
    double dPorcenSegundaCategoria=0;

    /*------------------------------------------------------------------------------------
     ACUMULA POCENTAJES DE IMPUESTOS
    -------------------------------------------------------------------------------------*/
    char *szModulo="bfnPorcenImptosCateg";

    vDTrazasLog(szModulo, "\tEntro a %s ", LOG05, szModulo);
    for ( i=0; i < pstCatImpues.iNumRegs; i++ )
    {
        if ( strcmp(pstCatImpues.stCatImpuesto[i].szFlagImpto,"S")==0 )
        {
            if ( pstCatImpues.stCatImpuesto[i].iCodCategoria == iGPrimCateg )
            {
            dPorcenPrimeraCategoria +=pstCatImpues.stCatImpuesto[i].dPrcImpuesto;
            }
            else
            {
            dPorcenSegundaCategoria +=pstCatImpues.stCatImpuesto[i].dPrcImpuesto;
            }
            strcpy(pstCatImpues.stCatImpuesto[i].szFlagImpto," ");
        }
    }
    *pdTotalPorcenPrimeraCateg=dPorcenPrimeraCategoria;
    *pdTotalPorcenSegundaCateg=dPorcenSegundaCategoria;
    return(TRUE);
}
/***********************************************************************************/
BOOL bfnTipoImpuesto(int iCodConcepto, int *iCodTipoImpuesto,double dPrcImpto)
{

    CATIMPUES  stkey;
    CATIMPUES *elementoPtr = (CATIMPUES *)NULL;
    char *szModulo="bfnTipoImpuesto";

    vDTrazasLog (szModulo, "\n\t\t* Busca Tipo Impuesto \n\t Cod. Concepto [%d]", LOG05,iCodConcepto);
    stkey.lCodConcepto=iCodConcepto;
    stkey.dPrcImpuesto=dPrcImpto;

    if ( pstCatImpues.iNumRegs > 0 )
    {
        if ( (elementoPtr = (CATIMPUES *)bsearch (&stkey, pstCatImpues.stCatImpuesto , pstCatImpues.iNumRegs,sizeof (CATIMPUES),ifnCmpCodImptos )) == (CATIMPUES *)NULL )
        {
            return(FALSE);
        }
    }
    else
    {
        vDTrazasLog(szModulo, "No existen datos para buscar en estructura de Tipos de impuestos ...", LOG01);
    }

    *iCodTipoImpuesto=elementoPtr->iCodTipImpto;

    return(TRUE);
}

/***********************************************************************************/
BOOL bfnBuscaCategImpto(int iCodConcepto, int *iCodCategoria, double dPrcImpto)
{

    CATIMPUES  stkey;
    CATIMPUES *elementoPtr = (CATIMPUES *)NULL;
    char *szModulo="bfnBuscaCategImpto";

    vDTrazasLog (szModulo, "Funcion bfnBuscaCategImpto * Busca Categoria del Impuesto \n\t Cod. Concepto [%d]", LOG05,iCodConcepto);
    stkey.lCodConcepto=iCodConcepto;
    stkey.dPrcImpuesto=dPrcImpto;

    if ( pstCatImpues.iNumRegs > 0 )
    {
        if ( (elementoPtr = (CATIMPUES *)bsearch (&stkey, pstCatImpues.stCatImpuesto , pstCatImpues.iNumRegs,
                          sizeof (CATIMPUES),ifnCmpCodImptos )) == (CATIMPUES *)NULL )
        {
            vDTrazasLog ("bfnBuscaCategImpto", "No encuentra categoria para  [%d]", LOG05,iCodConcepto);
            return(FALSE);
        }
    }
    else
    {
        vDTrazasLog(szModulo, "No existen datos para buscar en estructura de Categ. de impuestos ...", LOG01);
        return(FALSE);
    }

    *iCodCategoria=elementoPtr->iCodCategoria;
    return(TRUE);
}


BOOL bfnLimpiaFlag(CATIMPUESTOS *st_catImpuestos)
{
    int i;
    for ( i=0; i < st_catImpuestos->iNumRegs; i++ )
    {
        strcpy(st_catImpuestos->stCatImpuesto[i].szFlagImpto," ");
    }
    return(TRUE);
}

/***********************************************************************************/
BOOL bfnCargaUltsPagos (PAGO **pstPago, int *iNumRegs, long lCodCliente, long lCodCicloFact)
{
    int     rc = 0;
    int    iNumFilas;
    static  PAGO_HOSTS stPagoHost;
    PAGO    *pstPagoTemp;
    int    iCont;
    char *szModulo="bfnCargaUltsPagos";

    vDTrazasLog (szModulo,"\n\t* Carga Pagos ", LOG06);

    *iNumRegs = 0;
    *pstPago = (PAGO *)NULL;

    /* JHTO */
    if ( ifnOpenPagos(lCodCliente,lCodCicloFact) )
        return (FALSE);

    while ( rc != SQLNOTFOUND )
    {
        rc = bfnFetchPagos(&stPagoHost,&iNumFilas);
        if ( rc != SQLOK  && rc != SQLNOTFOUND )
            return (FALSE);

        if ( !iNumFilas )
            break;

        *pstPago =(PAGO*) realloc(*pstPago,(int)(((*iNumRegs)+iNumFilas)*sizeof(PAGO)));

        if ( !*pstPago )
        {
            iDError (szModulo,ERR000,vInsertarIncidencia,
             "Error bfnCargaUltsPagos", "no se pudo reservar memoria");
            return (FALSE);
        }

        pstPagoTemp = &(*pstPago)[(*iNumRegs)];
        memset(pstPagoTemp, 0, (int)(sizeof(PAGO)*iNumFilas));
        for ( iCont = 0 ; iCont < iNumFilas ; iCont++ )
        {
            pstPagoTemp[iCont].dMonto       = stPagoHost.dMonto[iCont];
            strcpy( pstPagoTemp[iCont].szFecha     , stPagoHost.szFecha[iCont]);
            strcpy( pstPagoTemp[iCont].szDecrip    , stPagoHost.szDecrip[iCont]);
            strcpy( pstPagoTemp[iCont].szModPago, stPagoHost.szModPago[iCont]);
            pstPagoTemp[iCont].iTipPago     =  stPagoHost.iTipPago[iCont];              /* P-ECU-05021 */
            strcpy( pstPagoTemp[iCont].szCodOperadora,  stPagoHost.szCodOperadora[iCont]);  /* P-ECU-05021 */
            pstPagoTemp[iCont].iCodTipDocum = stPagoHost.iCodTipDocum[iCont];               /* P-ECU-05021 */
        }
        (*iNumRegs) += iNumFilas;

    }/* fin while */

    vDTrazasLog (szModulo,"\n\t\t* Pagos del cliente cargados [%ld]", LOG06, *iNumRegs);

    rc = ifnClosePagos();
    if ( rc != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Error bfnCargaUltsPagos", szfnORAerror ());
        return (FALSE);
    }

    vfnPrintPagos (*pstPago, *iNumRegs);

    return(TRUE);
}
/***************************** Final bfnCargaUltsPagos *********************/

/****************************************************************************/
/*  Funcion: int ifnOpenPagos                           */
/****************************************************************************/
int ifnOpenPagos (long lCodCliente, long lCodCiclFact)
{
    char  szCadenaSQL  [16000]  ="";
    char  szTablaPagos [50]="";

    lhCodCliente = lCodCliente;
    strcpy(szhFormato_Fecha,"YYYYMMDD");
    strcpy(szhDesTipValor,"NO REGISTRADO");
    ihZero=0;

    strcpy (szModulo, "ifnOpenPagos");
    vDTrazasLog(szModulo,"\t** EN FUNCION ..(%s)", LOG06,szModulo);

    if (!lNroJob)
    {
         sprintf(szTablaPagos,"CO_ULTPAGO_TT_%ld", lCodCiclFact);
         vDTrazasLog (szModulo,"\n\t\t* Open=> CO_ULTPAGO_TT", LOG06);
    }
    else
    {
         sprintf(szTablaPagos,"CO_ULTPAGO_TT_%ld_%ld",lCodCiclFact,lNroJob);
         vDTrazasLog (szModulo,"\n\t\t* Open=> CO_ULTPAGO_TT_%ld_%ld", LOG06,lCodCiclFact,lNroJob);
    }

    memset(szCadenaSQL,'\0',sizeof(szCadenaSQL));

    sprintf(szCadenaSQL," SELECT"
            "\nMONTO, "
            "\nTO_CHAR(FECHA, 'YYYYMMDD'),"
            "\nDESCRIPCION,"
            "\nNVL(DES_TIPVALOR, 'NO REGISTRADO'), "
            "\nNVL(A.TIP_PAGO,%d), "
            "\nNVL(COD_OPERADORA,' '), "
            "\nNVL(COD_TIPDOCUM,%d) "
            "\nFROM %s A,"
            "\n     CO_TIPVALOR B"
            "\nWHERE B.TIP_VALOR (+) = A.COD_MODPAGO "
            "\n  AND COD_CLIENTE     = %ld"
            ,ihZero,ihZero,szTablaPagos,lhCodCliente);

    vDTrazasLog(szModulo,"\n\tQUERY PAGOS : [%s] ",LOG06,szCadenaSQL);

    EXEC SQL PREPARE curPagos FROM :szCadenaSQL;

    if (SQLCODE != SQLOK)
    {
        vDTrazasError(szModulo,"\t\tError en SQL-PREPARE curPagos.. **"
                    "\t\tError : [%s] [%d]  [%s] ",LOG01,szCadenaSQL,SQLCODE,SQLERRM);
        return  (SQLCODE);
    }

    EXEC SQL DECLARE curUltPagos CURSOR FOR curPagos;

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-DECLARE curUltPagos **"
                   "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-DECLARE curUltPagos **"
                   "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return  (SQLCODE);
    }

    EXEC SQL OPEN curUltPagos;

    if (SQLCODE !=  SQLOK)
    {
        vDTrazasLog  (szModulo,"\n\t**  Error en SQL-OPEN CURSOR curUltPagos **"
                   "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\n\t**  Error en SQL-OPEN CURSOR curUltPagos **"
                   "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return  (FALSE);
    }
	vDTrazasLog(szModulo,"\n\t\t retornando de funcion ifnOpenPagos: [%d] ",LOG05,SQLCODE);
    return (SQLCODE);
}/************************ Final de ifnOpenPagos ***********************/

/**************************************************************/
/*  FUNCION : bfnFetchPagos                       */
/**************************************************************/
static BOOL bfnFetchPagos (PAGO_HOSTS *pstHost,int *piNumFilas)
{
    char *szModulo="bfnFetchPagos";

    EXEC SQL FETCH curUltPagos
    INTO  :pstHost->dMonto   ,
    :pstHost->szFecha        ,
    :pstHost->szDecrip       ,
    :pstHost->szModPago      ,
    :pstHost->iTipPago       ,
    :pstHost->szCodOperadora ,
    :pstHost->iCodTipDocum   ;

    if ( SQLCODE==SQLOK )
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if ( SQLCODE==SQLNOTFOUND )
        *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
    else
        iDError (szModulo,ERR000,vInsertarIncidencia,"Fetch=> CO_ULTPAGO_TT", szfnORAerror ());
    return (SQLCODE);
}
/***************************** Final bfnFetchPagos ****************/
int ifnClosePagos(void)
{
    char *szModulo="ifnClosePagos";

    vDTrazasLog (szModulo,"\n\t\t* Open=> CO_ULTPAGO_TT", LOG06);

    EXEC SQL CLOSE curUltPagos;

    if ( SQLCODE != SQLOK )
        iDError (szModulo,ERR000,vInsertarIncidencia,"Close=> Cursor=> CO_ULTPAGO_TT",
             szfnORAerror ());

    return (SQLCODE);
}
/***************************** Final ifnClosePagos **********************/
void vfnPrintPagos (PAGO *pstPago, int iNumRegs)
{
    int i = 0;
    char *szModulo="vfnPrintPagos";

    if ( stStatus.LogNivel >= LOG06 )
    {
        vDTrazasLog (szModulo,"\n\t\t* Carga Tabla Pagos [%d]", LOG06, iNumRegs);

        for ( i=0;i<iNumRegs;i++ )
        {
            vDTrazasLog (szModulo,"\n\t\t=> [%d]: Monto Pago          [%f]"
                      "\n\t\t=> [%d]: Fecha Pago          [%s]"
                      "\n\t\t=> [%d]: Descripcion         [%s]"
                      "\n\t\t=> [%d]: Cod. Modalidad Pago [%s]"
                      "\n\t\t=> [%d]: Tipo de Pago        [%d]"
                      ,LOG06
                      ,i, pstPago[i].dMonto
                      ,i, pstPago[i].szFecha
                      ,i, pstPago[i].szDecrip
                      ,i, pstPago[i].szModPago
                      ,i, pstPago[i].iTipPago  );
        }
    }
}
/*************************** vfnPrintPagos *****************************/
BOOL bfnCargaMinutosPlanes (MINPLAN **pstMinPlan, int *iNumRegs)
{
    int     rc = 0;
    int     iNumFilas;
    static  MINPLAN_HOSTS stMinPlanHost;
    MINPLAN     *pstMinPlanTemp;
    int  iCont;
    char *szModulo="bfnCargaMinutosPlanes";

    vDTrazasLog (szModulo,"\n\t* Carga Valor de minutos por plan ", LOG06);

    *iNumRegs = 0;
    *pstMinPlan = (MINPLAN *)NULL;

    if ( ifnOpenMinPlanes() )
        return (FALSE);

/* rao: se elimina ya que no se entiende el uso
    rc == SQLNOTFOUND; */ /*Para que no cargue*/

    while ( rc != SQLNOTFOUND )
    {
        rc = bfnFetchMinPlanes(&stMinPlanHost,&iNumFilas);
        if ( rc != SQLOK  && rc != SQLNOTFOUND )
            return (FALSE);

        if ( !iNumFilas )
            break;

        *pstMinPlan =(MINPLAN*) realloc(*pstMinPlan,((*iNumRegs)+iNumFilas)*sizeof(MINPLAN));

        if ( !*pstMinPlan )
        {
            iDError (szModulo,ERR000,vInsertarIncidencia,
             "Error bfnCargaMinutosPlanes", "no se pudo reservar memoria");
            return (FALSE);
        }

        pstMinPlanTemp = &(*pstMinPlan)[(*iNumRegs)];
        memset(pstMinPlanTemp, 0, (int)(sizeof(MINPLAN)*iNumFilas));
        for ( iCont = 0 ; iCont < iNumFilas ; iCont++ )
        {
            strcpy( pstMinPlanTemp[iCont].szCod_Plan       , alltrim(stMinPlanHost.szCod_Plan[iCont]));
            strcpy( pstMinPlanTemp[iCont].szCod_Thor       , alltrim(stMinPlanHost.szCod_Thor[iCont]));
            pstMinPlanTemp[iCont].lSeg_Inic       = stMinPlanHost.lSeg_Inic[iCont];
            pstMinPlanTemp[iCont].lSeg_Adic       = stMinPlanHost.lSeg_Adic[iCont];
            pstMinPlanTemp[iCont].dMto_Inic       = stMinPlanHost.dMto_Inic[iCont];
            pstMinPlanTemp[iCont].dMto_Adic       = stMinPlanHost.dMto_Adic[iCont];
        }
        (*iNumRegs) += iNumFilas;

    }/* fin while */

    vDTrazasLog (szModulo,"\n\t\t* minutos por planes  [%d]", LOG06, *iNumRegs);

    rc = ifnCloseMinPlanes();
    if ( rc != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Error bfnCargaMinutosPlanes", szfnORAerror ());
        return (FALSE);
    }

    if ( *iNumRegs >0 )
    {
        qsort((void*)*pstMinPlan, *iNumRegs, sizeof(MINPLAN),ifnCmpMinPlanes);
        vfnPrintMinPlanes (*pstMinPlan, *iNumRegs);
    }

    return(TRUE);
}
/***************************** Final bfnCargaMinutosPlanes *********************/
static int ifnOpenMinPlanes( void )
{
    EXEC SQL BEGIN DECLARE SECTION  ;
    char szhTolCodLlam  [21];
    char szhTolCodTDir  [21];
    char szhTolCodTHor  [21];
    char szhTolCodTHorAlta  [21];
    char szhTolCodTHorBaja  [21];
    char szhTolConCliente[21];
    char szhTolCodOperador[21];
    char szhTolCodTDia  [21];
    char szhTolCodSFran [21];
    EXEC SQL END DECLARE SECTION  ;
    char *szModulo="ifnOpenMinPlanes";

    vDTrazasLog (szModulo,"\n\t\t* Open=> TOL_AGRULLAM / TOL_ESTCOBRO", LOG06);

    strcpy (szhTolCodLlam       ,alltrim(stGedParametros.szTolCodLlam)    );
    strcpy (szhTolCodTDir       ,alltrim(stGedParametros.szTolCodTDir)    );
    strcpy (szhTolCodTHor       ,alltrim(stGedParametros.szTolCodTHor)    );
    strcpy (szhTolCodTHorAlta   ,alltrim(stGedParametros.szTolCodTHorAlta) );
    strcpy (szhTolCodTHorBaja   ,alltrim(stGedParametros.szTolCodTHorBaja) );
    strcpy (szhTolConCliente    ,alltrim(stGedParametros.szTolConCliente ) );
    strcpy (szhTolCodOperador   ,alltrim(stGedParametros.szTolCodOperador) );
    strcpy (szhTolCodTDia       ,alltrim(stGedParametros.szTolCodTDia    ) );
    strcpy (szhTolCodSFran      ,alltrim(stGedParametros.szTolCodSFran   ) );

    vDTrazasLog (szModulo,"\n\t\t* Open=> [%s]", LOG06, szhTolCodLlam);
    vDTrazasLog (szModulo,"\n\t\t* Open=> [%s]", LOG06, szhTolCodTDir);
    vDTrazasLog (szModulo,"\n\t\t* Open=> [%s]", LOG06, szhTolCodTHor);
    vDTrazasLog (szModulo,"\n\t\t* Open=> [%s]", LOG06, szhTolCodTHorAlta);
    vDTrazasLog (szModulo,"\n\t\t* Open=> [%s]", LOG06, szhTolCodTHorBaja);
    vDTrazasLog (szModulo,"\n\t\t* Open=> [%s]", LOG06, szhTolConCliente);
    vDTrazasLog (szModulo,"\n\t\t* Open=> [%s]", LOG06, szhTolCodOperador);
    vDTrazasLog (szModulo,"\n\t\t* Open=> [%s]", LOG06, szhTolCodTDia);
    vDTrazasLog (szModulo,"\n\t\t* Open=> [%s]", LOG06, szhTolCodSFran);

    EXEC SQL DECLARE cCurMinPlan CURSOR FOR
    SELECT B.COD_PLAN, A.COD_THOR, B.SEG_INIC, B.SEG_ADIC, B.MTO_MIN, B.MTO_ADIC          /* RA-200512270421 */
    FROM TOL_AGRULLAM A, TOL_ESTCOBRO B
    WHERE A.COD_SENTIDO = 'S'
              AND A.COD_LLAM = :szhTolCodLlam
              AND A.COD_TDIR = :szhTolCodTDir
              AND A.COD_THOR IN (:szhTolCodTHor, :szhTolCodTHorAlta, :szhTolCodTHorBaja)
              AND A.CON_CLIENTE = :szhTolConCliente
                          AND A.FEC_INI_VIG <= SYSDATE
                          AND A.FEC_TER_VIG >= SYSDATE
                          AND B.COD_OPERADOR = :szhTolCodOperador
                          AND B.COD_PLAN <> ' '
                          AND B.COD_AGRULLAM = A.COD_AGRULLAM
                          AND B.COD_TDIA = :szhTolCodTDia
                          AND B.COD_SFRAN = :szhTolCodSFran
                          AND B.FEC_INI_VIG <= SYSDATE
                          AND B.FEC_TER_VIG >= SYSDATE;


    EXEC SQL OPEN cCurMinPlan;

    if ( SQLCODE != SQLOK )
        iDError (szModulo,ERR000,vInsertarIncidencia,"Open=> TOL_AGRULLAM/ TOL_ESTCOBRO",szfnORAerror ());

    return (SQLCODE);
}/***************************** Final ifnOpenMinPlanes **********************/

static BOOL bfnFetchMinPlanes(MINPLAN_HOSTS *pstHost,int *piNumFilas)
{
    char *szModulo="bfnFetchMinPlanes";

    EXEC SQL FETCH cCurMinPlan
    INTO  :pstHost->szCod_Plan,
    :pstHost->szCod_Thor,
    :pstHost->lSeg_Inic ,
    :pstHost->lSeg_Adic ,
    :pstHost->dMto_Inic ,
    :pstHost->dMto_Adic;

    if ( SQLCODE==SQLOK )
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if ( SQLCODE==SQLNOTFOUND )
        *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
    else
        iDError (szModulo,ERR000,vInsertarIncidencia,"Fetch=> TOL_AGRULLAM / TOL_ESTCOBRO", szfnORAerror ());
    return (SQLCODE);
}/***************************** Final bfnFetchMinPlanes ****************/


static int ifnCloseMinPlanes(void)
{
    char *szModulo="ifnCloseMinPlanes";

    vDTrazasLog (szModulo,"\n\t\t* Close => TOL_AGRULLAM / TOL_ESTCOBRO", LOG06);

    EXEC SQL CLOSE cCurMinPlan;

    if ( SQLCODE != SQLOK )
        iDError (szModulo,ERR000,vInsertarIncidencia,"Close=> Cursor=> TOL_AGRULLAM / TOL_ESTCOBRO",
             szfnORAerror ());

    return (SQLCODE);
}/***************************** Final ifnCloseMinPlanes **********************/

void vfnPrintMinPlanes (MINPLAN *pstMinPlan, int iNumRegs)
{
    int i = 0;
    char *szModulo="vfnPrintMinPlanes";

    if ( stStatus.LogNivel >= LOG06 )
    {
        vDTrazasLog (szModulo,"\n\t\t* Carga Minutos Planes [%d]", LOG06, iNumRegs);

        for ( i=0;i<iNumRegs;i++ )
        {
            vDTrazasLog (szModulo,"\n\t\t=> [%d]: Cod Plan    [%s]"
             "\n\t\t=> [%d]: Cod THor    [%s]"
             "\n\t\t=> [%d]: Seg Inic    [%ld]"
             "\n\t\t=> [%d]: Seg Adic    [%ld]"
             "\n\t\t=> [%d]: Mto Inic    [%f]"
             "\n\t\t=> [%d]: Mto Adic    [%f]"
             ,LOG06
             ,i, pstMinPlan[i].szCod_Plan
             ,i, pstMinPlan[i].szCod_Thor
             ,i, pstMinPlan[i].lSeg_Inic
             ,i, pstMinPlan[i].lSeg_Adic
             ,i, pstMinPlan[i].dMto_Inic
             ,i, pstMinPlan[i].dMto_Adic );


        }
    }
}/*************************** vfnPrintMinPlanes *****************************/

int ifnCmpMinPlanes(const void *cad1,const void *cad2)
{
    int rc;
    return( (rc = strcmp  (((MINPLAN *)cad1)->szCod_Plan,
               ((MINPLAN *)cad2)->szCod_Plan)) != 0)?rc:
    ( (rc = strcmp  (((MINPLAN *)cad1)->szCod_Thor,
             ((MINPLAN *)cad2)->szCod_Thor)) != 0)?rc:0;
}/*************************** ifnCmpCod_PlanTarif *****************************/

BOOL  bfnFindMinPlan (char *szCodPlanTarif, char *szCodThor, MINPLAN *pstMinPlan)
{
    char *szModulo="bfnFindMinPlan";
    MINPLAN  stkey;
    MINPLAN  *pstAux = (MINPLAN *)NULL;

    vDTrazasLog (szModulo, "\n\t\t* Busca Minutos de Plan Tarifario "
             "\n\t\t=> Cod. Plan Tarifario   [%s]"
             "\n\t\t=> Cod. T Hor            [%s]"
             , LOG05,szCodPlanTarif
             , szCodThor);

    strcpy(stkey.szCod_Plan, szCodPlanTarif);
    strcpy(stkey.szCod_Thor, szCodThor);

    if ( stMinutosPlanes.iNumRegs > 0 )
    {
        if ( (pstAux = (MINPLAN *)bsearch (&stkey, stMinutosPlanes.stMinPlan , stMinutosPlanes.iNumRegs,
                       sizeof (MINPLAN), ifnCmpMinPlanes ))== (MINPLAN *)NULL )
        {

            vDTrazasLog(szModulo, "Codigo de Plan Tarifario [%s] no encontrado ...", LOG01, szCodPlanTarif);
            return(FALSE);
        }
        memcpy (pstMinPlan, pstAux, sizeof(MINPLAN));
    }
    else
    {
        vDTrazasLog(szModulo, "No existen datos para buscar en estructura de Minutos Planes ...", LOG01);
    }

    return(TRUE);
}


BOOL bfnCargaPrimCateg (void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int     ihCodCateg =0 ;
    EXEC SQL END DECLARE SECTION;

    char *szModulo="bfnCargaPrimCateg";

    EXEC SQL
    SELECT MIN(COD_CATEIMP)
    INTO :ihCodCateg
    FROM GE_TIPIMPUES;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog(szModulo, "Error en SELECT de bfnCargaPrimCateg [%d]\n[%s]", LOG02, SQLCODE,SQLERRM);
        return(FALSE);
    }

    iGPrimCateg=ihCodCateg;
    vDTrazasLog(szModulo, "Primera Categoria [%d]", LOG05, iGPrimCateg);

    return(TRUE);

}/************************************ Final bfnCargaPrimCateg **********************************************/

int ifnCmpOperadores(const void *cad1,const void *cad2)
{
    int rc = 0;

    return
    ( (rc = ((CODOPER *)cad1)->iCodOperador-
       ((CODOPER *)cad2)->iCodOperador) != 0)?rc:0;

}

BOOL bfnCargaOperadores (CODOPER **pstOper, int *iNumOperadores)
{
    int     rc = 0;
    int     iNumFilas;
    static  CODOPER_HOSTS stOperHost;
    CODOPER *pstOperTemp;
    int     iCont;
    char *szModulo="bfnCargaOperadores";

    vDTrazasLog (szModulo,"\n\t* Carga Operadores ", LOG06);

    *iNumOperadores = 0;
    *pstOper = NULL;

    if ( ifnOpenOperadores() )
        return (FALSE);

    while ( rc != SQLNOTFOUND )
    {
        rc = bfnFetchOperadores(&stOperHost,&iNumFilas);
        if ( rc != SQLOK  && rc != SQLNOTFOUND )
            return (FALSE);

        if ( !iNumFilas )
            break;

        *pstOper =(CODOPER*) realloc(*pstOper,(int)(((*iNumOperadores)+iNumFilas)*sizeof(CODOPER)));

        if ( !*pstOper )
        {
            iDError (szModulo,ERR000,vInsertarIncidencia,
             "Error bfnCargaOperadores", "no se pudo reservar memoria");
            return (FALSE);
        }

        pstOperTemp = &(*pstOper)[(*iNumOperadores)];
        memset(pstOperTemp, 0, (int)(sizeof(CODOPER)*iNumFilas));
        for ( iCont = 0 ; iCont < iNumFilas ; iCont++ )
        {
            pstOperTemp[iCont].iCodOperador       = stOperHost.iCodOperador[iCont];
            strcpy( pstOperTemp[iCont].szDesOperador    ,stOperHost.szDesOperador[iCont]);
        }
        (*iNumOperadores) += iNumFilas;

    }/* fin while */

    vDTrazasLog (szModulo,"\n\t\t* Codigos de Operadores cargados [%d]", LOG06, *iNumOperadores);

    rc = ifnCloseOperadores();
    if ( rc != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Error bfnCargaOperadores", szfnORAerror ());
        return (FALSE);
    }

    qsort((void*)*pstOper, *iNumOperadores, sizeof(CODOPER),ifnCmpOperadores);

    /*vfnPrintOperadores (*pstOper, *iNumOperadores);*/
    vDTrazasLog (szModulo,"\n\t\t* (bfnCargaOperadores) Saliendo de la funcion...", LOG06);

    return(TRUE);
}/***************************** Final bfnCargaOperadores *********************/

static int ifnOpenOperadores(void)
{
    char *szModulo="ifnOpenOperadores";

    vDTrazasLog (szModulo,"\n\t\t* En la funcion ifnOpenOperadores", LOG06);

/*EXEC SQL DECLARE Cur_Operadores CURSOR for
SELECT COD_OPERADOR, DES_OPERADOR
FROM  TA_OPERADORES;*//*AFGS - 38935*/

    ihZero = 0;

    EXEC SQL DECLARE Cur_Operadores CURSOR for
        SELECT COD_OPERADOR, DES_OPERADOR
        FROM  TA_OPERADORES
        WHERE COD_OPERADOR >= :ihZero;

    EXEC SQL OPEN Cur_Operadores;

    if ( SQLCODE != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Open=> TA_OPERADORES",szfnORAerror ());
    }

    return (SQLCODE);
}/***************************** Final ifnOpenOperadores **********************/

static BOOL bfnFetchOperadores (CODOPER_HOSTS *pstHost,int *piNumFilas)
{
    char *szModulo="bfnFetchOperadores";

    vDTrazasLog (szModulo,"\n\t\t* En la funcion bfnFetchOperadores", LOG06);

    EXEC SQL FETCH Cur_Operadores
    INTO :pstHost->iCodOperador ,
    :pstHost->szDesOperador;

    if ( SQLCODE==SQLOK )
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if ( SQLCODE==SQLNOTFOUND )
        *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
    else
        iDError (szModulo,ERR000,vInsertarIncidencia,"Fetch=> TA_OPERADORES", szfnORAerror ());
    return (SQLCODE);
}/***************************** Final bfnFetchOperadores ****************/


static int ifnCloseOperadores(void)
{
    char *szModulo="ifnCloseOperadores";

    vDTrazasLog (szModulo,"\n\t\t* En la funcion ifnCloseOperadores", LOG06);

    EXEC SQL CLOSE Cur_Operadores;

    if ( SQLCODE != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Close=> Cursor=> TA_OPERADORES",szfnORAerror ());
    }

    return (SQLCODE);
}/***************************** Final ifnCloseOperadores **********************/

void vfnPrintOperadores (CODOPER *pstCodOper, int iNumFilas)
{
    int i = 0;
    char *szModulo="vfnPrintOperadores";

    if ( stStatus.LogNivel >= LOG06 )
    {
        vDTrazasLog (szModulo,"\n\t\t* Carga Tabla Operadores [%d]", LOG06, iNumFilas);

        for ( i=0;i<iNumFilas;i++ )
        {
            vDTrazasLog (szModulo,"\n\t\t=> [%d]: Codigo de Operador [%d]"
                      "\n\t\t=> [%d]: Desc. Operador     [%s]"
             ,LOG06
             ,i, pstCodOper[i].iCodOperador
             ,i, pstCodOper[i].szDesOperador);
        }

    }
}/*************************** vfnPrintOperadores *****************************/


BOOL bfnFindCod_Operador (int iCodOperador, CODOPER *pstOper)
{
    CODOPER  stkey;
    CODOPER  *pstAux = (CODOPER *)NULL;
    char *szModulo="bfnFindCod_Operador";

    vDTrazasLog (szModulo, "\n\t\t* Busca Operador "
               "\n\t\t=> Cod. Operador   [%d]"
             , LOG05,iCodOperador );

    stkey.iCodOperador = iCodOperador;

    if ( stOperadores.iNumRegs )
    {
        if ( (pstAux = (CODOPER *)bsearch (&stkey, stOperadores.stOper , stOperadores.iNumRegs,
                       sizeof (CODOPER),ifnCmpOperadores ))== (CODOPER *)NULL )
        {

            vDTrazasLog(szModulo, "Codigo Operador [%d] no encontrado ...", LOG01, iCodOperador);
            return(FALSE);
        }
        memcpy (pstOper, pstAux, sizeof(CODOPER));
    }
    else
    {
        vDTrazasLog(szModulo, "No existen datos para buscar en estructura de Operadores...", LOG01);
    }

    return(TRUE);
}

/* Funciones relacionadas con documentos del periodo */
BOOL bfnCargarDocsPeriodo (DOCPERIODO **pstDocPeriodo, int *iNumRegs, long lCodCliente, char *pszFecDesde, char *pszFecHasta)
{
    int     rc = 0;
    int    iNumFilas;
    static  DOCPERIODO_HOSTS stDocPeriodoHost;
    DOCPERIODO      *pstDocPeriodoTemp;
    int    iCont;
    char *szModulo="bfnCargarDocsPeriodo";

    vDTrazasLog (szModulo,"\n\t* Carga Pagos ", LOG06);

    *iNumRegs = 0;
    *pstDocPeriodo = (DOCPERIODO *)NULL;

    if ( ifnOpenDocsPeriodo(lCodCliente,pszFecDesde,pszFecHasta) )
        return (FALSE);

    while ( rc != SQLNOTFOUND )
    {
        rc = bfnFetchDocsPeriodo(&stDocPeriodoHost,&iNumFilas);
        if ( rc != SQLOK  && rc != SQLNOTFOUND )
            return (FALSE);

        if ( !iNumFilas )
            break;

        *pstDocPeriodo =(DOCPERIODO*) realloc(*pstDocPeriodo,(int)(((*iNumRegs)+iNumFilas)*sizeof(DOCPERIODO)));

        if ( !*pstDocPeriodo )
        {
            iDError (szModulo,ERR000,vInsertarIncidencia,
             "Error bfnCargarDocsPeriodo()", "no se pudo reservar memoria");
            return (FALSE);
        }

        pstDocPeriodoTemp = &(*pstDocPeriodo)[(*iNumRegs)];
        memset(pstDocPeriodoTemp, 0, (int)(sizeof(DOCPERIODO)*iNumFilas));
        for ( iCont = 0 ; iCont < iNumFilas ; iCont++ )
        {
            pstDocPeriodoTemp[iCont].iCodTipDocum       = stDocPeriodoHost.iCodTipDocum[iCont];
            pstDocPeriodoTemp[iCont].lNumFolio          = stDocPeriodoHost.lNumFolio[iCont];
            pstDocPeriodoTemp[iCont].dTotFactura       = stDocPeriodoHost.dTotFactura[iCont];

            strcpy( pstDocPeriodoTemp[iCont].szCodOperadora  , stDocPeriodoHost.szCodOperadora[iCont]);
            strcpy( pstDocPeriodoTemp[iCont].szCodOficina    , stDocPeriodoHost.szCodOficina[iCont]);
            strcpy( pstDocPeriodoTemp[iCont].szDesTipDocum   , stDocPeriodoHost.szDesTipDocum[iCont]);
            strcpy( pstDocPeriodoTemp[iCont].szPrefPlaza     , stDocPeriodoHost.szPrefPlaza[iCont]);
            strcpy( pstDocPeriodoTemp[iCont].szFecEmision    , stDocPeriodoHost.szFecEmision[iCont]);
        }
        (*iNumRegs) += iNumFilas;

    }/* fin while */

    vDTrazasLog (szModulo,"\n\t\t* Documentos del periodo cargados: [%ld]", LOG05, *iNumRegs);

    rc = ifnCloseDocsPeriodo();
    if ( rc != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Error bfnCargarDocsPeriodo", szfnORAerror ());
        return (FALSE);
    }

    /*vfnPrintPagos (*pstPago, *iNumRegs);*/

    return(TRUE);
}/***************************** Final bfnCargarDocsPeriodo *********************/

static int ifnOpenDocsPeriodo(long lCodCliente, char *pszFecDesde, char *pszFecHasta)
{
    char *szModulo="ifnOpenDocsPeriodo";

    lhCodCliente = lCodCliente;
    strcpy(szhFecDesde,pszFecDesde);
    strcpy(szhFecHasta,pszFecHasta);
    strcpy(szhFormato_Fecha,"YYYYMMDD");

    vDTrazasLog (szModulo,"\n\t\t* Open=> FA_HISTDOCU, GE_TIPDOCUMEN", LOG06);

    EXEC SQL OPEN curDocsPeriodo;

    if ( SQLCODE != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Open=> FA_HISTDOCU, GE_TIPDOCUMEN",szfnORAerror ());
    }

    return (SQLCODE);
}/***************************** Final ifnOpenDocsPeriodo **********************/

static BOOL bfnFetchDocsPeriodo(DOCPERIODO_HOSTS *pstHost,int *piNumFilas)
{
    char *szModulo="bfnFetchDocsPeriodo";

    EXEC SQL FETCH curDocsPeriodo
    INTO  :pstHost->szCodOperadora  ,
    :pstHost->szCodOficina    ,
    :pstHost->iCodTipDocum    ,
    :pstHost->szDesTipDocum   ,
    :pstHost->szPrefPlaza     ,
    :pstHost->lNumFolio       ,
    :pstHost->szFecEmision    ,
    :pstHost->dTotFactura    ;



    if ( SQLCODE==SQLOK )
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if ( SQLCODE==SQLNOTFOUND )
        *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
    else
        iDError (szModulo,ERR000,vInsertarIncidencia,"Fetch=> FA_HISTDOCU, GE_TIPDOCUMEN", szfnORAerror ());
    return (SQLCODE);
}/***************************** Final bfnFetchPagos ****************/


static int ifnCloseDocsPeriodo(void)
{
    char *szModulo="ifnCloseDocsPeriodo";

    vDTrazasLog (szModulo,"\n\t\t* Open=> FA_HISTDOCU, GE_TIPDOCUMEN", LOG06);

    EXEC SQL CLOSE curDocsPeriodo;

    if ( SQLCODE != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Close=> Cursor=> FA_HISTDOCU, GE_TIPDOCUMEN", szfnORAerror ());
    }

    return (SQLCODE);
}/***************************** Final ifnClosePagos **********************/



/* FUNCION QUE RESCATA DATOS PARA EL REGISTRO A2600 (VENTAS) */
/*---------------------------------------------------------------------------*/
/* Funcion: ifnLlenarSeriesDeVenta y Notas de Crdito            */
/*---------------------------------------------------------------------------*/
/*int ifnLlenarSeriesDeVenta ( reg_entrada *pstEntrada ) INICIO 76441 CJG*/
int ifnLlenarSeriesDeVenta ( reg_entrada *pstEntrada, int iCodConcepto )
{
    EXEC SQL BEGIN DECLARE SECTION;
    static char       szTip_Docu[1+1]     ;
    static long       lhNum_venta         ;
    static long       lhCod_cliente       ;
    static long       lhNum_proceso       ;
    static int        ihTipoVenta         ;

    struct
    {
        char       szhNumSerie[25+1]   ;
        long       lhNumAbonado        ;
        long       lhCodConcepto       ;
        char       szhDesConcepto[60+1];
        long       lhNumCelular        ;
    } est_series;

    struct
    {
        short      i_szhNumSerie       ;
        short      i_lhNumAbonado      ;
        short      i_szhDesConcepto    ;
        short      i_lhNumCelular      ;
    } i_est_series;

    static SQL_CURSOR cursor_series       ;
    static short      i_cursor_series     ;
    static char       szMensError[1026+1] ;
    static short      i_szMensError       ;

    static char szFecVenta   [9]   ; EXEC SQL VAR szFecVenta IS STRING (9);
    static char szIndVenta   [2]   ; EXEC SQL VAR szIndVenta IS STRING (2);
    static char szhNumSerie[25+1]  ; EXEC SQL VAR szhNumSerie    IS STRING(25+1);
    static long lhNumAbonado        ;
    static long lhCodConcepto       ;
    static char szhDesConcepto[60+1]; EXEC SQL VAR szhDesConcepto IS STRING(60+1);
    static char chString1[1+1]     ; EXEC SQL VAR chString1 IS STRING (1+1);
    static long lhNumCelular = 0L   ;

    EXEC SQL END DECLARE SECTION;

    char *modulo="ifnLlenarSeriesDeVenta";
    stSalida * paux;
    long lContador = 0l;
    /* INICIO 76441 CJG */
    int ihCodConcepto = 0;
    /* int ihCountKit = 0; */
    /* FIN 76441 CJG */

    paux = NULL;

/*INICIO 71757 CJG*/
    int     i;
    char    szNum_Celular[21];
    memset(szNum_Celular,0,sizeof(szNum_Celular));
/*FIN 71757 CJG*/

    /* INICIO 76441 CJG */
    ihCodConcepto = iCodConcepto;
    /* FIN 76441 CJG */

    lhNum_venta   = pstEntrada->lNumVenta;
    lhCod_cliente = pstEntrada->lCodCliente;
    lhNum_proceso = pstEntrada->lNumProceso;
    strcpy(szTip_Docu,pstEntrada->szTipoDocum);

    memset(szMensError,0,sizeof(szMensError));

    vDTrazasLog (modulo,"\tCONCEPTO         [%ld]"
						"\n\tPROCESO        [%ld]"
            "\n\tTIPO DOCUMENTO [%s]"
            "\n\tVENTA          [%ld]" ,LOG05,ihCodConcepto,lhNum_proceso,szTip_Docu,lhNum_venta);

    EXEC SQL ALLOCATE :cursor_series;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-ALLOCATE Cursor de Series **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-ALLOCATE Cursor de Series **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        EXEC SQL CLOSE :cursor_series;
        EXEC SQL FREE :cursor_series;
        return(SQLCODE);
    }

    EXEC SQL EXECUTE
    BEGIN
    NP_TRANSACCIONES_WEB_PG.NP_INFORMA_SERIES_NPW_PR(:lhNum_proceso,
                             :szTip_Docu,
                             :lhNum_venta,
                             :cursor_series :i_cursor_series,
                             :szMensError :i_szMensError);
    END;
    END-EXEC;
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-EXECUTE NP_TRANSACCIONES_WEB_PG **"
              "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-EXECUTE NP_TRANSACCIONES_WEB_PG **"
              "\t\tError : [%s] [%d]  [%s] ",LOG01,"NP_TRANSACCIONES_WEB_PG",SQLCODE,SQLERRM);
        EXEC SQL CLOSE :cursor_series;
        EXEC SQL FREE :cursor_series;
        return(SQLCODE);
    }

    vDTrazasLog(szModulo,"\tResultado de NP_TRANSACCIONES_WEB_PG.NP_INFORMA_SERIES_NPW_PR [%d : %s] Cursor [%d]",LOG04, i_szMensError,alltrim(szMensError),i_cursor_series);

    if ( strcmp(alltrim(szMensError),"No facturado por NPW")!=0 )
    {
        for ( ;; )
        {
            EXEC SQL FETCH :cursor_series INTO  :est_series.szhNumSerie    :i_est_series.i_szhNumSerie
            ,:est_series.lhNumAbonado   :i_est_series.i_lhNumAbonado
            ,:est_series.lhCodConcepto
            ,:est_series.szhDesConcepto :i_est_series.i_szhDesConcepto
            ,:est_series.lhNumCelular   :i_est_series.i_lhNumCelular;

            if ( SQLCODE == SQLNOTFOUND )
            break;
            else
            if ( SQLCODE != SQLOK )
            {
            vDTrazasLog  (szModulo,"\t\tError en SQL-FETCH Cursor de Series **"
                  "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
            vDTrazasError(szModulo,"\t\tError en SQL-FETCH Cursor de Series **"
                  "\t\tError : [%s] [%d]  [%s] ",LOG01,"CURSOR DE SERIES",SQLCODE,SQLERRM);
            EXEC SQL CLOSE :cursor_series;
            EXEC SQL FREE :cursor_series;
            return(SQLCODE);
            }

            vDTrazasLog (modulo,"\tNUMERO SERIE    [%s]"
                    "\tNUMERO ABONADO  [%ld]"
                    "\tCODIGO CONCEPTO [%ld]"
                    "\tDESCRIPCION     [%s]"
                    "\tNUMERO CELULAR  [%ld]"
                   ,LOG05,alltrim(est_series.szhNumSerie)
                   ,est_series.lhNumAbonado
                   ,est_series.lhCodConcepto
                   ,alltrim(est_series.szhDesConcepto),est_series.lhNumCelular);

            paux = (stSalida *) malloc(sizeof(stSalida));

            if ( paux == NULL )
            {
            vDTrazasLog (modulo,"\n\nERROR:1:(%s): En asignacion de memoria a paux.", LOG05,modulo );
            vDTrazasError (modulo,"\n\nERROR:1:(%s): En asignacion de memoria a paux.", LOG05,modulo );
            return(FALSE);
            }

            if ( i_est_series.i_szhNumSerie!=ORA_NULL )
            sprintf(paux->szNumSerie,"%s",alltrim(est_series.szhNumSerie));

            if ( i_est_series.i_lhNumAbonado!=ORA_NULL )
            paux->lNumAbonado = est_series.lhNumAbonado;

            paux->lCodConcepto = est_series.lhCodConcepto;

            if ( i_est_series.i_szhDesConcepto!=ORA_NULL )
            sprintf(paux->szDesConcepto,"%s",alltrim(est_series.szhDesConcepto));


            if ( i_est_series.i_lhNumCelular!=ORA_NULL )
            paux->lNumCelular  = est_series.lhNumCelular;
            else
            paux->lNumCelular = 0;

            paux->sgte  = lstSalida;
            lstSalida   = paux;
            lContador++;
        }
        /* Cerrar cursor */
        EXEC SQL CLOSE :cursor_series;
        EXEC SQL FREE :cursor_series;
    }
    else
    {
        strcpy(chString1,"I");

        lhNum_venta   = pstEntrada->lNumVenta;
        lhCod_cliente = pstEntrada->lCodCliente;

        /* ----------------------------------------------*/
        /* Verificamos si la venta es prepago o postpago */
        /* ----------------------------------------------*/
        ihTipoVenta = 0;

        EXEC SQL
        SELECT TO_CHAR (FEC_VENTA, 'DDMMYYYY'), IND_VENTA
        INTO :szFecVenta, :szIndVenta
        FROM GA_VENTAS C
        WHERE C.NUM_VENTA   = :lhNum_venta
          AND C.COD_CLIENTE = :lhCod_cliente;

        if ( SQLCODE != SQLOK )
        {
            vDTrazasLog (modulo,"\n\tERROR, al obtener procedencia de la venta. SQLCODE [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
            return (FALSE);
        }

        vDTrazasLog (modulo,"\tIND_VENTA     [%s]",LOG05,szIndVenta);
        /*if ( strcmp (szIndVenta,"E")==0 )venta por OOSS / INICIO 71757 CJG*/
        if (( strcmp (szIndVenta,"E")==0 )||( strcmp (szIndVenta,"B")==0 ))
           {
           /* Inc 140733 PPV 23/07/2010 */
           if (strcmp(szTip_Docu,"N")!=0)
           {
           	vDTrazasLog (modulo,"\n\t Se fue por distinto de NC \n", LOG05);
            EXEC SQL DECLARE cursorCargosOOSS_1 CURSOR FOR
            SELECT  A.NUM_SERIE,
            A.NUM_ABONADO,
            A.COD_CONCEPTO,
            B.DES_CONCEPTO
            FROM GE_CARGOS A,
            FA_CONCEPTOS B
            WHERE A.NUM_VENTA = :lhNum_venta
              AND A.COD_CLIENTE = :lhCod_cliente
              AND A.COD_CONCEPTO=B.COD_CONCEPTO
              AND A.NUM_SERIE IS NOT NULL;
           }
           else /* Inc 140733 PPV 23/07/2010  se agrega consulta para NC ya que no esta el dato en la ge_cargos */
           {
            vDTrazasLog (modulo,"\n\t Se fue por NC: lhNum_venta[%ld] lhCod_cliente[%ld] \n", LOG05,lhNum_venta,lhCod_cliente);
            EXEC SQL DECLARE cursorCargosOOSS_2 CURSOR FOR
            SELECT  A.NUM_SERIE,
            A.NUM_ABONADO,
            A.COD_CONCEPTO,
            B.DES_CONCEPTO
            FROM FA_HISTCARGOS A,
            FA_CONCEPTOS B
            WHERE A.NUM_VENTA = :lhNum_venta
              AND A.COD_CLIENTE = :lhCod_cliente
              AND A.COD_CONCEPTO=B.COD_CONCEPTO
              AND A.NUM_SERIE IS NOT NULL;
           }
           
           
           if (strcmp(szTip_Docu,"N")!=0)
           {            /* Abrir cursor */
            EXEC SQL OPEN cursorCargosOOSS_1;
            }
           else
           	{
           		EXEC SQL OPEN cursorCargosOOSS_2;
           	}
            lContador = 0;

            while ( 1 )
            {
				if (strcmp(szTip_Docu,"N")!=0)
			   {
					EXEC SQL
					FETCH cursorCargosOOSS_1
					INTO :szhNumSerie,
					:lhNumAbonado,
					:lhCodConcepto,
					:szhDesConcepto;
				}
				else
            	{
            EXEC SQL
            FETCH cursorCargosOOSS_2
            INTO :szhNumSerie,
            :lhNumAbonado,
            :lhCodConcepto,
            :szhDesConcepto;            		
            	}    

            if ( SQLCODE == SQLNOTFOUND )
            break;
            else if ( SQLCODE !=  SQLOK )
            {
            vDTrazasLog (modulo,"\n\tERROR, al leer cursor CARGOS OOSS .SQLCODE [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
            return (FALSE);
            }

            paux = (stSalida *) malloc(sizeof(stSalida));
            if ( paux == NULL )
            {
            vDTrazasLog (modulo,"\n\nERROR:1:(%s): En asignacion de memoria a paux.", LOG05,modulo );
            vDTrazasError (modulo,"\n\nERROR:1:(%s): En asignacion de memoria a paux.", LOG05,modulo );
            return(FALSE);
            }

            strcpy(paux->szNumSerie,szhNumSerie);
            paux->lNumAbonado = lhNumAbonado;
            paux->lCodConcepto = lhCodConcepto;
            strcpy(paux->szDesConcepto,szhDesConcepto);
/*INICIO 71757 CJG*/
            if ( strcmp (szIndVenta,"E")==0 )
            {
            for ( i=0;i < stFaDetCons.iNumReg ;i++ )
            {
            if ( strcmp(fnQuitaBlancos(stFaDetCons.stDetConsumo[i].szNum_Celular),"0") )
            {
                strcpy(szNum_Celular, stFaDetCons.stDetConsumo[i].szNum_Celular);
                break;
            }
            }
             }
             else if ( strcmp (szIndVenta,"B")==0 )
             {
            /* Inc 140733 PPV 23/07/2010 */
					if (strcmp(szTip_Docu,"N")!=0)
					{
              vDTrazasLog (modulo,"\n\t Se fue por distinto de NC \n", LOG05);				 
              EXEC SQL
             SELECT NUM_TERMINAL
             INTO   :szNum_Celular
             FROM GE_CARGOS
             WHERE NUM_VENTA = :lhNum_venta
             AND COD_CLIENTE = :lhCod_cliente
             AND NUM_ABONADO = :lhNumAbonado
             AND ROWNUM=1; /*modificado a peticion de Mario Torres*/
             }
             else /* Inc 140733 PPV 23/07/2010  se agrega consulta para NC ya que no esta el dato en la ge_cargos */
             {
             	 vDTrazasLog (modulo,"\n\t Se fue por NC \n", LOG05);
             	 EXEC SQL  
             	   SELECT NUM_TERMINAL
             INTO   :szNum_Celular
             FROM FA_HISTCARGOS
             WHERE NUM_VENTA = :lhNum_venta
             AND COD_CLIENTE = :lhCod_cliente
             AND NUM_ABONADO = :lhNumAbonado;
             }
					 
              if(SQLCODE != SQLOK)
              {
             vDTrazasLog(modulo ,"\n\t**  En Select de NUM_TERMINAL  [%s] **"
            ,LOG01,sqlca.sqlerrm.sqlerrmc);
             vDTrazasError(modulo ,"\n\t**  En Select de NUM_TERMINAL  [%s] **"
            ,LOG01,sqlca.sqlerrm.sqlerrmc);
             return FALSE;
              }

             }
            paux->lNumCelular  =atol(szNum_Celular);
            vDTrazasLog (modulo,"\tCELULAR VTA OOSS       [%ld]",LOG05,paux->lNumCelular);

/*FIN 71757 CJG*/
            paux->sgte  = lstSalida;
            lstSalida   = paux;
            lContador++;

            }    /* while (1) */

     		if (strcmp(szTip_Docu,"N")!=0)
           	{
            		/* Cerrar cursor */
            	EXEC SQL CLOSE cursorCargosOOSS_1;
            }
            else
			{
				EXEC SQL CLOSE cursorCargosOOSS_2;
			}

        }/*(szIndVenta,"E")(szIndVenta,"B")*/
        else
        {
            EXEC SQL
            SELECT COUNT(1)
            INTO :ihTipoVenta
            FROM GA_EQUIPABOSER A
            WHERE A.NUM_ABONADO IN (  SELECT B.NUM_ABONADO
                          FROM GA_ABOAMIST B
                          WHERE B.NUM_VENTA   = :lhNum_venta
                          AND B.COD_CLIENTE = :lhCod_cliente
                          AND TRUNC(B.FEC_ALTA) IN ( SELECT TRUNC(C.FEC_VENTA)
                                 FROM GA_VENTAS C
                                 WHERE C.NUM_VENTA    = :lhNum_venta
                                 AND C.COD_CLIENTE = :lhCod_cliente))
            AND A.IND_PROCEQUI = :chString1;

            if ( SQLCODE != SQLOK )
            {
            vDTrazasLog (modulo,"\n\tERROR, al obtener procedencia de la venta. SQLCODE [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
            return (FALSE);
            }

            if ( ihTipoVenta > 0 )
            {
            /* ----------------------------------------------*/
            /* VENTA PREPAGO                     */
            /* ----------------------------------------------*/
            vDTrazasLog (modulo,"\n\tProcedencia es prepago KIT...", LOG05);

            /* INICIO 76441 CJG */
/* PGG SOPORTE VOLVIENDO ATRAS (COMENYANDO DESDE)- 76441 - 09-02-2009 */
/*            EXEC SQL
            SELECT COUNT(1)
            INTO :ihCountKit
            FROM AL_COMPONENTE_KIT A, AL_ARTICULOS B, GA_ABOAMIST C
            WHERE A.NUM_SERIE = C.NUM_SERIE
            AND A.COD_KIT = B.COD_ARTICULO
            AND B.COD_CONCEPTOART = :ihCodConcepto
            AND C.NUM_VENTA       = :lhNum_venta
            AND C.COD_CLIENTE     = :lhCod_cliente;

            vDTrazasLog (modulo,"\n\t prepago KIT ihCountKit==>[%ld]", LOG05,ihCountKit);
            if (ihCountKit==0)
            {
               return (FALSE);
            }
*/
/* PGG SOPORTE VOLVIENDO ATRAS (COMENTANDO HASTA)- 76441 - 09-02-2009 */
            /* FIN 76441 CJG */


            /* Declaramos cursor */

/* PGG SOPORTE COMENTADO DESDE ACA - INC. 60409 1-1 14-12-2007  */
/* PGG SOPORTE VOLVIENDO ATRAS (DESCOMENTANDO DESDE)- 76441 - 09-02-2009 */
            EXEC SQL DECLARE cursorAbonadoPrePagoKIT CURSOR FOR
            SELECT
            A.NUM_KIT,
            D.NUM_ABONADO,
            B.COD_CONCEPTO,
            B.DES_CONCEPTO,
            NVL(A.NUM_TELEFONO,0)
            FROM
            AL_COMPONENTE_KIT A,
            FA_CONCEPTOS B,
            AL_ARTICULOS C,
            GA_EQUIPABOSER D
            WHERE
            C.COD_ARTICULO  = A.COD_KIT
            AND A.NUM_SERIE = D.NUM_SERIE
            AND D.TIP_TERMINAL IN ( SELECT
                            E.VAL_PARAMETRO
                        FROM
                            GED_PARAMETROS E
                        WHERE
                            E.NOM_PARAMETRO IN ('TIP_DIGITAL', 'COD_SIMCARD_GSM'))
            AND D.NUM_ABONADO IN (  SELECT
                            F.NUM_ABONADO
                        FROM
                            GA_ABOAMIST F
                        WHERE
                            F.NUM_VENTA       = :lhNum_venta
                            AND F.COD_CLIENTE = :lhCod_cliente
                            AND TRUNC(F.FEC_ALTA) IN (  SELECT
                                        TRUNC(G.FEC_VENTA)
                                    FROM
                                        GA_VENTAS G
                                    WHERE
                                        G.NUM_VENTA       = :lhNum_venta
                                        AND G.COD_CLIENTE = :lhCod_cliente))
            AND C.COD_CONCEPTOART = B.COD_CONCEPTO
            AND D.IND_PROCEQUI    = :chString1;


            EXEC SQL OPEN cursorAbonadoPrePagoKIT;
            lContador = 0;

            while (1)
            {
            EXEC SQL
            FETCH cursorAbonadoPrePagoKIT
             INTO :szhNumSerie,
                  :lhNumAbonado,
                  :lhCodConcepto,
                  :szhDesConcepto,
                  :lhNumCelular;

            if (SQLCODE == SQLNOTFOUND)
            break;
            else if (SQLCODE != SQLOK)
            {
            vDTrazasLog (modulo,"\n\tERROR, al leer cursor Abonado PrePago KIT.SQLCODE [%d]", LOG01,SQLCODE);
            return FALSE;
            }

            paux = (stSalida *) malloc(sizeof(stSalida));
            if(paux == NULL)
            {
            vDTrazasLog (modulo,"\n\nERROR:1:(%s): En asignacion de memoria a paux.", LOG05,modulo );
            vDTrazasError (modulo,"\n\nERROR:1:(%s): En asignacion de memoria a paux.", LOG05,modulo );
            return (FALSE);
            }


            strcpy(paux->szNumSerie,szhNumSerie);
            paux->lNumAbonado = lhNumAbonado;
            paux->lCodConcepto = lhCodConcepto;
            strcpy(paux->szDesConcepto,szhDesConcepto);
            paux->lNumCelular  = lhNumCelular;

            paux->sgte  = lstSalida;
            lstSalida   = paux;
            lContador++;

            }

            EXEC SQL CLOSE cursorAbonadoPrePagoKIT;

            if (lContador == 0)
            {

            /* PGG SOPORTE VOLVIENDO ATRAS (DESCOMENTANDO HASTA)- 76441 - 09-02-2009 */
            /* PGG SOPORTE COMENTADO HASTA ACA - INC. 60409 1-1 14-12-2007  */

                vDTrazasLog (modulo,"\n\tProcedencia es prepago...", LOG05);

                /* Declaramos cursor */
                EXEC SQL DECLARE cursorAbonadoPrePago CURSOR FOR
                SELECT
                A.NUM_SERIE,
                A.NUM_ABONADO,
                B.COD_CONCEPTO,
                B.DES_CONCEPTO,
                D.NUM_CELULAR             /* P-ECU-05021 */
                FROM
                GA_EQUIPABOSER A,
                FA_CONCEPTOS   B,
                AL_ARTICULOS   C,
                GA_ABOAMIST    D          /* P-ECU-05021 */
                WHERE
                A.NUM_ABONADO IN (SELECT
                          D.NUM_ABONADO
                          FROM
                          GA_ABOAMIST D
                          WHERE
                          D.NUM_VENTA       = :lhNum_venta
                          AND D.COD_CLIENTE = :lhCod_cliente
                          AND TRUNC(D.FEC_ALTA) IN (SELECT
                                    TRUNC(E.FEC_VENTA)
                                    FROM
                                    GA_VENTAS E
                                    WHERE
                                    E.NUM_VENTA       = :lhNum_venta
                                    AND E.COD_CLIENTE = :lhCod_cliente))
                AND C.COD_ARTICULO    = A.COD_ARTICULO
                AND C.COD_CONCEPTOART = B.COD_CONCEPTO
                AND A.NUM_ABONADO     = D.NUM_ABONADO  /* P-ECU-05021 */
                AND A.IND_PROCEQUI    = :chString1
                GROUP BY A.NUM_SERIE,
                A.NUM_ABONADO,               /*FPH 38244 SE AGRUPA PARA EVITAR SERIES REPETIDAS ASOCIADAS A VENTAS*/
                B.COD_CONCEPTO,              /*FPH 38244 SE AGRUPA PARA EVITAR SERIES REPETIDAS ASOCIADAS A VENTAS*/
                B.DES_CONCEPTO,              /*FPH 38244 SE AGRUPA PARA EVITAR SERIES REPETIDAS ASOCIADAS A VENTAS*/
                D.NUM_CELULAR  ;             /*FPH 38244 SE AGRUPA PARA EVITAR SERIES REPETIDAS ASOCIADAS A VENTAS*/

                /* Abrir cursor */
                EXEC SQL OPEN cursorAbonadoPrePago;


                while ( 1 )
                {
                    EXEC SQL
                    FETCH cursorAbonadoPrePago
                    INTO :szhNumSerie,
                    :lhNumAbonado,
                    :lhCodConcepto,
                    :szhDesConcepto,
                    :lhNumCelular;

                    if ( SQLCODE == SQLNOTFOUND )
                        break;
                    else if ( SQLCODE != SQLOK )
                    {
                        vDTrazasLog (modulo,"\n\tERROR, Al leer cursor Abonado PrePago. SQLCODE [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
                        return (FALSE);
                    }

                    paux = (stSalida *) malloc(sizeof(stSalida));
                    if ( paux == NULL )
                    {
                        vDTrazasLog (modulo,"\n\nERROR:2:(%s): En asignacion de memoria a paux.", LOG05,modulo );
                        vDTrazasError (modulo,"\n\nERROR:2:(%s): En asignacion de memoria a paux.", LOG05,modulo );
                        return(FALSE);
                    }


                    strcpy(paux->szNumSerie,szhNumSerie);
                    paux->lNumAbonado = lhNumAbonado;
                    paux->lCodConcepto = lhCodConcepto;
                    strcpy(paux->szDesConcepto,szhDesConcepto);
                    paux->lNumCelular  = lhNumCelular;     /* P-ECU-05021 */

                    paux->sgte  = lstSalida;
                    lstSalida   = paux;


                }    /* while (1) */

                /* Cerrar cursor */
                EXEC SQL CLOSE cursorAbonadoPrePago;
            } /* if (lContador = 0) */ /* PGG SOPORTE SE ELIMINA EL CIERRE DEL IF. INC. 60409 1-1 14-12-2007 */ /* PGG SOPORTE VOLVIENDO ATRAS - 76441 - 09-02-2009 */
            }
            else
            {
            /* ----------------------------------------------*/
            /* VENTA POSTPAGO                    */
            /* ----------------------------------------------*/
            vDTrazasLog (modulo,"\n\tProcedencia es postpago...", LOG05);

            /* Inc 140733 PPV 23/07/2010 */
           		if (strcmp(szTip_Docu,"N")!=0)
           		{
					vDTrazasLog (modulo,"\n\t Se fue por distinto de NC \n", LOG05);
					/* Declaramos cursor */
					EXEC SQL DECLARE cursorAbonadoPostPago_1 CURSOR FOR
					
					SELECT
					A.NUM_SERIE
					,A.NUM_ABONADO
					,B.COD_CONCEPTO
					,B.DES_CONCEPTO
					,D.NUM_CELULAR             /* P-ECU-05021 */
					FROM
					GA_EQUIPABOSER A
					,FA_CONCEPTOS B
					,AL_ARTICULOS C
					,GA_ABOCEL     D           /* P-ECU-05021 */
					WHERE
					A.NUM_ABONADO IN (SELECT
									  D.NUM_ABONADO
									  FROM
									  GA_ABOCEL D
									  WHERE
									  D.NUM_VENTA       = :lhNum_venta
									  AND D.COD_CLIENTE = :lhCod_cliente
									  AND TRUNC(D.FEC_ALTA) IN (SELECT
																TRUNC(E.FEC_VENTA)
																FROM
																GA_VENTAS E
																WHERE
																E.NUM_VENTA       = :lhNum_venta
																AND E.COD_CLIENTE = :lhCod_cliente))
					AND C.COD_ARTICULO    = A.COD_ARTICULO
											AND C.COD_CONCEPTOART = B.COD_CONCEPTO
											AND A.NUM_ABONADO     = D.NUM_ABONADO  /* P-ECU-05021 */
											AND A.IND_PROCEQUI    = :chString1
											GROUP BY A.NUM_SERIE,
					A.NUM_ABONADO,               /*FPH 38244 SE AGRUPA PARA EVITAR SERIES REPETIDAS ASOCIADAS A VENTAS*/
					B.COD_CONCEPTO,              /*FPH 38244 SE AGRUPA PARA EVITAR SERIES REPETIDAS ASOCIADAS A VENTAS*/
					B.DES_CONCEPTO,              /*FPH 38244 SE AGRUPA PARA EVITAR SERIES REPETIDAS ASOCIADAS A VENTAS*/
					D.NUM_CELULAR  ;             /*FPH 38244 SE AGRUPA PARA EVITAR SERIES REPETIDAS ASOCIADAS A VENTAS*/
				}
				else
				{
				   vDTrazasLog (modulo,"\n\t Se fue por NC \n", LOG05);
					/* Declaramos cursor */
					EXEC SQL DECLARE cursorAbonadoPostPago_2 CURSOR FOR
									SELECT  A.NUM_SERIE,A.NUM_ABONADO,A.COD_CONCEPTO,B.DES_CONCEPTO, D.NUM_CELULAR
									FROM FA_HISTCARGOS A,FA_CONCEPTOS B, GA_ABOCEL D
									WHERE A.NUM_VENTA = :lhNum_venta
									AND A.COD_CLIENTE = :lhCod_cliente
									AND A.COD_CONCEPTO=B.COD_CONCEPTO
									AND A.NUM_ABONADO     = D.NUM_ABONADO
									AND A.NUM_SERIE IS NOT NULL;
				}

            /* Abrir cursor */
            if (strcmp(szTip_Docu,"N")!=0)
           		{
					EXEC SQL OPEN cursorAbonadoPostPago_1;
				}
				else
				{
					EXEC SQL OPEN cursorAbonadoPostPago_2;
				}

            while ( 1 )
            {
				  if (strcmp(szTip_Docu,"N")!=0)
				  {
					EXEC SQL
					FETCH cursorAbonadoPostPago_1
					INTO :szhNumSerie
					,:lhNumAbonado
					,:lhCodConcepto
					,:szhDesConcepto
					,:lhNumCelular;
				   }
				   else
				   {
					EXEC SQL
					FETCH cursorAbonadoPostPago_2
					INTO :szhNumSerie
					,:lhNumAbonado
					,:lhCodConcepto
					,:szhDesConcepto
					,:lhNumCelular;               	
				   }

            if ( SQLCODE == SQLNOTFOUND )
            break;
            else if ( SQLCODE != SQLOK )
            {
            vDTrazasLog (modulo,"\n\tERROR, al leer cursor Abonado PostPago. SQLCODE[%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
            return (FALSE);
            }

            paux = (stSalida *) malloc(sizeof(stSalida));
            if ( paux == NULL )
            {
            vDTrazasLog (modulo,"\n\nERROR:3:(%s): En asignacion de memoria a paux.", LOG05,modulo );
            vDTrazasError (modulo,"\n\nERROR:3:(%s): En asignacion de memoria a paux.", LOG05,modulo );
            return(FALSE);
            }

            strcpy(paux->szNumSerie,szhNumSerie);
            paux->lNumAbonado = lhNumAbonado;
            paux->lCodConcepto = lhCodConcepto;
            strcpy(paux->szDesConcepto,szhDesConcepto);
            paux->lNumCelular  = lhNumCelular; /* P-ECU-05021 */

            paux->sgte  = lstSalida;
            lstSalida   = paux;

            }/* while (1) */

            /* Cerrar cursor */
				if (strcmp(szTip_Docu,"N")!=0)
				{
					EXEC SQL CLOSE cursorAbonadoPostPago_1;
				}
				else
				{
					EXEC SQL CLOSE cursorAbonadoPostPago_2;
				}

            }/* if (ihTipoVenta > 0) */
        } /* if OOSS */

    }

    return (TRUE);
} /* ifnLlenarSeriesDeVenta */


int ifnObtenerSeriesFactMiscela(reg_entrada *pstEntrada)
{
    EXEC SQL BEGIN DECLARE SECTION;
    long    lhNumProceso     = 0L;
    long    lhCodConcepto    = 0L;
    long    lhColumna        = 0L;
    char    szhNumSerieResp  [30];   EXEC SQL VAR szhNumSerieResp IS STRING(30);
    long    lhNumProcesoResp = 0L;
    long    lhCodConceptoResp= 0L;
    long    lhColumnaResp    = 0L;
    EXEC SQL END   DECLARE SECTION;

    char    szhDesConcepto[60+1];

    char *pszModulo="ifnObtenerSeriesFactMiscela";

    stSalida *paux;

    lhNumProceso     = pstEntrada->lNumProceso;
    lhCodConcepto    = pstEntrada->lCodConcepto;
    lhColumna        = pstEntrada->iColumna;
    strcpy(szhDesConcepto,pstEntrada->szDesConcepto);

    paux = NULL;

    vDTrazasLog (pszModulo,"\n\tProceso: [%ld]", LOG05,lhNumProceso);
    vDTrazasLog (pszModulo,"\n\tConcepto: [%ld]", LOG05,lhCodConcepto);
    vDTrazasLog (pszModulo,"\n\tColumna: [%ld]", LOG05,lhColumna);


    EXEC SQL DECLARE curSeriesMiscelaneas CURSOR FOR
    SELECT
    A.NUM_SERIE,
    A.NUM_PROCESO,
    A.COD_CONCEPTO,
    A.COLUMNA
    FROM
    FA_SERIES_TO A
    WHERE
    A.NUM_PROCESO      = :lhNumProceso
             AND A.COD_CONCEPTO = :lhCodConcepto
             AND A.COLUMNA      = :lhColumna;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (pszModulo,"\n\tERROR, En DECLARE de cursor curSeriesMiscelaneas, sqlcode: [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
        return (FALSE);
    }

    /* Apertura del cursor */
    EXEC SQL OPEN curSeriesMiscelaneas;

    for ( ;; )
    {

        EXEC SQL
        FETCH
        curSeriesMiscelaneas
        INTO
        :szhNumSerieResp,
        :lhNumProcesoResp,
        :lhCodConceptoResp,
        :lhColumnaResp;

        if ( SQLCODE == SQLNOTFOUND )
            break;

        if ( SQLCODE !=SQLOK )
        {
            vDTrazasLog (pszModulo,"\n\tERROR, En FETCH de cursor curSeriesMiscelaneas, sqlcode: [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
            return (FALSE);
        }


        paux = (stSalida *) malloc(sizeof(stSalida));
        if ( paux == NULL )
        {
            vDTrazasLog (pszModulo,"\n\nERROR:(%s): En asignacion de memoria a paux.", LOG05,pszModulo );
            vDTrazasError (pszModulo,"\n\nERROR:(%s): En asignacion de memoria a paux.", LOG05,pszModulo );
            return(FALSE);
        }

        strcpy(paux->szNumSerie,szhNumSerieResp);
        paux->lNumAbonado  = 0L;
        paux->lCodConcepto = lhCodConceptoResp;
        strcpy(paux->szDesConcepto,szhDesConcepto);
        paux->lNumCelular  = 0L;

        paux->sgte  = lstSalida;
        lstSalida   = paux;

    }    /* for(;;) */

    /* Cierre del cursor */
    EXEC SQL CLOSE curSeriesMiscelaneas;


    return (TRUE);
}

/*
 * Obtener Valor total de la deuda financiada y saldo pendiente para la cuota ingresada
 * por parametro.
 */

int ifnObtenerMontosTotalesCuota( rg_cuotas pstCuota, double *pdMtoTotDeuda, double *pdMtoSaldoPend)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int    ihCodCliente        = 0;
    int    ihValorUno          = 1;
    long   lhNumFolio          = 0L;
    double dhMtoDeudaCartera   = 0.0;
    double dhMtoPagadoCartera  = 0.0;
    double dhTotalCancelado    = 0.0;
    double dhMtoInformado      = 0.0;
    char   szhPrefPlaza[11]    = "" ; EXEC SQL VAR szhPrefPlaza IS STRING(11);
    EXEC SQL END   DECLARE SECTION;

    double dMontoTotalDeuda = 0.0;
    double dSaldoPendiente  = 0.0;

    char *pszModulo="ifnObtenerMontosTotalesCuota";

    vDTrazasLog (pszModulo,"\tDentro de la funcion(%s):  \n"
             "\t\tCodigo de Cliente : [%d] \n"
             "\t\tNumero de folio   : [%ld]"
             "\t\tPrefijo plaza     : [%s]"
             , LOG05
             , pszModulo
             , pstCuota.iCodCliente
             , pstCuota.lNum_Folio
             , pstCuota.szPrefPlaza);


    ihCodCliente  = pstCuota.iCodCliente;
    lhNumFolio    = pstCuota.lNum_Folio;
    strcpy(szhPrefPlaza, pstCuota.szPrefPlaza);

    /* Consultar Monto Total y pagado a la fecha en CO_CARTERA */
    EXEC SQL
    SELECT
    SUM(A.IMPORTE_DEBE),
    SUM(A.IMPORTE_HABER)
    INTO
    :dhMtoDeudaCartera,
    :dhMtoPagadoCartera
    FROM
    CO_CARTERA A
    WHERE
    A.COD_CLIENTE      = :ihCodCliente
             AND A.NUM_FOLIO    = :lhNumFolio
             AND A.PREF_PLAZA   = :szhPrefPlaza
             GROUP BY
             A.COD_CLIENTE,
    A.NUM_FOLIO,
    A.PREF_PLAZA;

    if ( SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND )
    {
        vDTrazasLog (pszModulo,"\n\nERROR:(%s): En SELECT A CO_CARTERA, SQLCODE: [%d]\n[%s].", LOG01,pszModulo,SQLCODE,SQLERRM);
        return (FALSE);
    }

    if ( SQLCODE == SQLNOTFOUND )
    {
        vDTrazasLog (pszModulo,"\n\nATENCION:(%s): No se encuentran datos en CO_CARTERA, Numero de registros: [%d].", LOG05,pszModulo,sqlca.sqlerrd[2]);

        dhMtoDeudaCartera  = 0.0;
        dhMtoPagadoCartera = 0.0;
    }

    /* Obtencion de Monto de cuotas existentes en CO_CANCELADAS */
    EXEC SQL
    SELECT
    SUM(A.IMPORTE_HABER)
    INTO
    :dhTotalCancelado
    FROM
    CO_CANCELADOS A
    WHERE
    A.COD_CLIENTE      = :ihCodCliente
             AND A.NUM_FOLIO    = :lhNumFolio
             AND A.PREF_PLAZA   = :szhPrefPlaza
             GROUP BY
             A.COD_CLIENTE,
    A.NUM_FOLIO,
    A.PREF_PLAZA;

    if ( SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND )
    {
        vDTrazasLog (pszModulo,"\n\nERROR:(%s): En SELECT A CO_CANCELADOS, SQLCODE: [%d]\n[%s].", LOG01,pszModulo,SQLCODE,SQLERRM);
        return (FALSE);
    }

    if ( SQLCODE == SQLNOTFOUND )
    {
        vDTrazasLog (pszModulo,"\n\nATENCION:(%s): No se encuentran datos en CO_CANCELADOS, Numero de registros: [%d].", LOG05,pszModulo,sqlca.sqlerrd[2]);
        dhTotalCancelado = 0.0;
    }

    /* 20060705: Obtencion de la suma de coutas informadas desde CO_CARTERA */
    EXEC SQL
    SELECT
    SUM(A.IMPORTE_DEBE - A.IMPORTE_HABER)
    INTO
    :dhMtoInformado
    FROM
    CO_CARTERA A
    WHERE
    A.COD_CLIENTE       = :ihCodCliente
              AND A.NUM_FOLIO     = :lhNumFolio
              AND A.PREF_PLAZA    = :szhPrefPlaza
              AND A.IND_FACTURADO = :ihValorUno
              GROUP BY
              A.COD_CLIENTE,
    A.NUM_FOLIO,
    A.PREF_PLAZA;

    if ( SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND )
    {
        vDTrazasLog (pszModulo,"\n\nERROR:(%s): En SELECT de cuotas informadas CO_CARTERA, SQLCODE: [%d]\n[%s].", LOG01,pszModulo,SQLCODE,SQLERRM);
        return (FALSE);
    }

    if ( SQLCODE == SQLNOTFOUND )
    {
        vDTrazasLog (pszModulo,"\n\nATENCION:(%s): No se encuentran datos de cuotas informadas en CO_CARTERA, Numero de registros: [%d].", LOG05,pszModulo,sqlca.sqlerrd[2]);
        dhMtoInformado = 0.0;
    }

    vDTrazasLog (pszModulo,"\n\nINFO:(%s): dhMtoInformado: [%015.4f].", LOG06,pszModulo,SQLCODE);

    /* Calculo del Monto Total y del saldo pendiente */
    dMontoTotalDeuda = dhMtoDeudaCartera + dhTotalCancelado;
    /*dSaldoPendiente  = dMontoTotalDeuda - (dhMtoPagadoCartera + dhTotalCancelado + dhMtoInformado);    */ /* PGG SOPORTE 7-07-2006 CUOTAS MALAS */
    dSaldoPendiente  = dMontoTotalDeuda - (dhMtoPagadoCartera + dhTotalCancelado + pstCuota.dMtoCuota);     /* PGG SOPORTE 7-07-2006 CUOTAS MALAS */


    vDTrazasLog("ifnObtenerMontosTotalesCuota", "\t(ifnObtenerMontosTotalesCuota): Monto Total deuda : [%015.4f]\n"
            "\t(ifnObtenerMontosTotalesCuota): Saldo Pendiente   : [%015.4f]"
            , LOG06, dMontoTotalDeuda, dSaldoPendiente);


    /* Traspaso a las variables por referencia */
    *pdMtoTotDeuda = dMontoTotalDeuda;
    *pdMtoSaldoPend= dSaldoPendiente;

    return (TRUE);
}



/* FUNCION QUE RESCATA EL PLAN TARIFARIO DEL ABONADO DE LA GA_INFACCEL*/
/*---------------------------------------------------------------------------*/
/* Funcion: bfnGetPlanTarifAbo                        */
/*---------------------------------------------------------------------------*/
BOOL bfnGetPlanTarifAbo(long lNumAbonado, long lCodcliente, char *szCodPlanTarifAbo)
{

    EXEC SQL BEGIN DECLARE SECTION;
    char szhCodPlanTarif[4]; EXEC SQL VAR szhCodPlanTarif IS STRING(4);
    long lhNumAbonado;
    EXEC SQL END   DECLARE SECTION;

    lhCodCliente = lCodcliente;
    lhNumAbonado = lNumAbonado;

    EXEC SQL
    SELECT COD_PLANTARIF
    INTO :szhCodPlanTarif
    FROM GA_INTARCEL
    WHERE COD_CLIENTE  = :lhCodCliente
      AND NUM_ABONADO  = :lhNumAbonado
      AND ROWNUM < 2;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog ("bfnGetPlanTarifAbo","\n\t\t* En sentenia SELECT, Codigo: [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
        return (FALSE);
    }
    strcpy (szCodPlanTarifAbo, szhCodPlanTarif);
    return(TRUE);
}
/***********************************************************************************/
/**
 * Funcion      : bfnEsMovMiscelaneo
 * Descripcion  : Verfica que el documento pasado por parametro sea un movmiento miscelaneo.
 * Parametros   : iCodTipDocum      Codigo de tipo de documento.
 *            iCodMiscela       Codigo de documento miscelaneo almacenado en FA_DATOSGENER
 * Retorna      : TRUE              Es movimiento miscelaneo.
 *              : FALSE             No es movimiento miscelaneo.
 */
BOOL bfnEsMovMiscelaneo(int iCodTipDocum, int iCodMiscela)
{

    EXEC SQL BEGIN DECLARE SECTION;
    int ihCodMiscela  = 0;
    int ihContador    = 0;
    EXEC SQL END   DECLARE SECTION;
    char *szModulo="bfnEsMovMiscelaneo";


    vDTrazasLog (szModulo,"\n\t\t* Dentro de la funcion bfnEsMovMiscelaneo()", LOG05);

    /* Asignacion de los parametros a las variables Host */
    gihCodTipDocum = iCodTipDocum;
    ihCodMiscela  = iCodMiscela;

    EXEC SQL
    SELECT COUNT(1)
    INTO   :ihContador
    FROM   FA_TIPMOVIMIEN A
    WHERE  A.COD_TIPMOVIMIEN  = :ihCodMiscela
      AND  A.COD_TIPDOCUM = :gihCodTipDocum;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo,"\n\t\t* En sentenia SELECT, Codigo: [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
        return (FALSE);
    }

    vDTrazasLog (szModulo,"\n\t\t* (bfnEsMovMiscelaneo) Valor devuelto por SELECT, ihContador :[%d]", LOG05, ihContador);

    /* Si existe movimiento miscelaneo para el documento, se retorna TRUE */
    if ( ihContador > 0 )
        return (TRUE);
    else
        return (FALSE);
}

/***********************************************************************************/
/**
 * Funcion      : ifnAgruparCuotas
 * Descripcion  : Verfica que el documento pasado por parametro sea un movmiento miscelaneo.
 * Parametros   : stCuotasNoAgrup   Registro de cuotas no agrupadas.
 *            iNumCuotasNoAgrup Numero de cuotas no agrupadas.
 *            stCuotasAgrup     Estructura de cuotas agrupadas.
 * Retorna      : El numero de cuotas agrupadas.
 */
int ifnAgruparCuotas(rg_cuotas *stCuotasNoAgrup, int iNumCuotasNoAgrup, rg_cuotas *stCuotasAgrup)
{
    register int i = 0;
    register int iInd = 0;
    register int j = 0;
    int iFlagAcum;
    char *szModulo="ifnAgruparCuotas";
    char sz_IndAcelerada[2];

    /* Comienzo de agrupacion de cuotas */

    vDTrazasLog (szModulo,"\n\t\t* Dentro de la funcion ifnAgruparCuotas()", LOG05);
    
    for ( i=0; i<iNumCuotasNoAgrup ; i++ )/*FPH se saca el -1al control del icon la variable EC-218*/
    {
        /* Si es el primero, se copia */
        if ( i==0 )
        {
            memcpy(&stCuotasAgrup[iInd], &stCuotasNoAgrup[i], sizeof(stCuotasNoAgrup[i]));
            iInd++;
		}else{
	        iFlagAcum = FALSE;
	        for(j = 0; j < iInd; j++)
	        {
		        if ( (stCuotasAgrup[j].lNum_Folio           == stCuotasNoAgrup[i].lNum_Folio)          &&
              strcmp(stCuotasAgrup[j].szPrefPlaza ,    stCuotasNoAgrup[i].szPrefPlaza     )==0 &&
             (stCuotasAgrup[j].iSecCuota            == stCuotasNoAgrup[i].iSecCuota       )    &&
             (stCuotasAgrup[j].iNumCuota            == stCuotasNoAgrup[i].iNumCuota       )    &&
              strcmp(stCuotasAgrup[j].szFechaEfectiva, stCuotasNoAgrup[i].szFechaEfectiva )==0 &&
             (stCuotasAgrup[j].iInd_Facturado       == stCuotasNoAgrup[i].iInd_Facturado  )    &&
             strcmp(stCuotasAgrup[j].sz_IndAcelerada , stCuotasNoAgrup[i].sz_IndAcelerada) == 0
		           )
		        {
            stCuotasAgrup[j].dMtoCuota += stCuotasNoAgrup[i].dMtoCuota;
            iFlagAcum = TRUE;
            break;
		        }
	        }
	        
	        if(!iFlagAcum)
	        {
	            memcpy(&stCuotasAgrup[iInd], &stCuotasNoAgrup[i], sizeof(stCuotasNoAgrup[i]));
	            iInd++;
	        }
    	}
    }

    vDTrazasLog (szModulo,"\n\t\t* (ifnAgruparCuotas) Se devuelve de la funcion j: [%d]", LOG05, iInd);

    /* Se devuelve el numero de cuotas agrupadas */
    return(iInd);
}


/***********************************************************************************/
int ifnCmpOrden(const void *cad1,const void *cad2)
{
    return( strcmp (((ST_ORDEN  *)cad1)->szKey,((ST_ORDEN  *)cad2)->szKey) );
}


/***********************************************************************************/
int ifnLiberaDetCons (void)
{
    free(stFaDetCons.stDetConsumo);
    memset (&stFaDetCons,0,sizeof(stFaDetCons));

    /* estructura de indice de orden alterno */
    free(stOrden2DetConsumo.stOrden);
    memset(&stOrden2DetConsumo, 0, sizeof (stOrden2DetConsumo));

    /* estructura de indice de orden alterno de Cargos*/
    free(stOrden2DetConsumo_Cargos.stOrden);
    memset(&stOrden2DetConsumo_Cargos, 0, sizeof (stOrden2DetConsumo_Cargos));
    
    /* estructura de Promociones de Trafico*/
	if(pstPromTrafClie.iNumPromClie > 0)
	{
    	free(pstPromTrafClie.stPromocionesClie);
    	memset(&pstPromTrafClie, 0, sizeof (pstPromTrafClie));
    }
    
    return (1);
}


/**
 * Funcion      : bfnObtieneVentaRelacionada
 * Descripcion  : Obtiene Venta relacionada con un documentos Nota de Crdito
 * Parametros   : lNumSecuRel       Numero de Secuencia relacionada
              szLetraRel        Letra relacionada
              iCodTipDocumRel   Tipo de Documento relacionado
              lCodVendedorAgRel Vendedor relacionado
              lCodCentrRel      Centro Emisor relacionado
              lNumVenta         Numero de Venta entregado
 * Retorna      : TRUE o FALSE segn corresponda
 */
BOOL bfnObtieneVentaRelacionada(long lNumSecuRel,char szLetraRel[2],int iCodTipDocumRel,long lCodVendedorAgRel,long lCodCentrRel,long *lNumVenta)
{
    EXEC SQL BEGIN DECLARE SECTION;
    long     lhNumSecuRel       ;
    char     szhLetraRel[2]     ;
    int      ihCodTipDocumRel   ;
    long     lhCodVendedorAgRel ;
    long     lhCodCentrRel      ;
    long     lhNumVenta         ;
    EXEC SQL END   DECLARE SECTION;
    char *szModulo="bfnObtieneVentaRelacionada";


    lhNumSecuRel       = lNumSecuRel      ;
    strcpy(szhLetraRel , szLetraRel)      ;
    ihCodTipDocumRel   = iCodTipDocumRel  ;
    lhCodVendedorAgRel = lCodVendedorAgRel;
    lhCodCentrRel      = lCodCentrRel     ;
    ihZero             = 0;

    EXEC SQL
    SELECT NVL(NUM_VENTA,:ihZero)
    INTO :lhNumVenta
    FROM (
         SELECT NUM_VENTA FROM FA_FACTDOCU_NOCICLO
         WHERE NUM_SECUENCI = :lhNumSecuRel
         AND COD_TIPDOCUM = :ihCodTipDocumRel
         AND COD_VENDEDOR_AGENTE = :lhCodVendedorAgRel
         AND LETRA = :szhLetraRel
         AND COD_CENTREMI = :lhCodCentrRel
         UNION
         SELECT NUM_VENTA FROM FA_HISTDOCU
         WHERE NUM_SECUENCI = :lhNumSecuRel
         AND COD_TIPDOCUM = :ihCodTipDocumRel
         AND COD_VENDEDOR_AGENTE = :lhCodVendedorAgRel
         AND LETRA = :szhLetraRel
         AND COD_CENTREMI = :lhCodCentrRel);

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo,"\n\t\t* En sentenia SELECT, Codigo: [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
        return (FALSE);
    }

    *lNumVenta = lhNumVenta;
    return (TRUE);
}

/**
 * Funcion      : bfnFolioRelacionado
 * Descripcion  : Obtiene Folio y Prefijo Plaza Relaciado
 * Parametros   : iCodCliente       Codigo de Cliente
              lNumFolio         Numero de Folio
              szPrefPlaza       Prefijo Plaza
              lNumFolioRel      Numero de Folio Relacionado
              szPrefPlazaRel    Prefijo Plaza Relacionado
 * Retorna      : TRUE o FALSE segn corresponda
 */
BOOL bfnFolioRelacionado(int iCodCliente,long lNumFolio,char *szPrefPlaza,long *lNumFolioRel,char *szPrefPlazaRel)
{
    char *modulo="bfnFolioRelacionado";

    EXEC SQL BEGIN DECLARE SECTION;
    int  ihCodCliente;
    long lhNumFolio;
    char szhPrefPlaza[11];
    long lhNumFolioRel;
    char szhPrefPlazaRel[11];
    long lCodCiclFact;
    int iNotaCred;
    int iValorCero;
    char szCadenaVacia[2];
    EXEC SQL END   DECLARE SECTION;

    vDTrazasLog (modulo,"\n\t* Entra en Funcion %s", LOG06,modulo);

    lCodCiclFact  = 19010102;
    iNotaCred     = stDatosGener.iCodNotaCre;
    iValorCero    = 0;
    strcpy(szCadenaVacia," ");

    ihCodCliente = iCodCliente;
    lhNumFolio   = lNumFolio;
    strcpy(szhPrefPlaza,alltrim(szPrefPlaza));

    vDTrazasLog (modulo,"\n\t* Cliente      [%d] \n"
              "\t* Folio        [%ld]\n"
              "\t* Pref Plaza   [%s] \n"
              "\t* Ciclo        [%ld]\n"
              "\t* Nota Credito [%d] \n"
              "\t* Pref Plaza   [%s] \n"
              "\t* Valor Cero   [%d] \n"
              "\t* Cadena Vacia [%s] \n" , LOG06,
              ihCodCliente
              , lNumFolio
              , szhPrefPlaza
              , lCodCiclFact
              , iNotaCred
              , szhPrefPlaza
              , iValorCero
              , szCadenaVacia);

    EXEC SQL
    SELECT NUM_FOLIO,
           PREF_PLAZA
      INTO :lhNumFolioRel,
           :szhPrefPlazaRel
      FROM ( SELECT B.NUM_FOLIO  NUM_FOLIO,
            B.PREF_PLAZA PREF_PLAZA
               FROM FA_FACTDOCU_NOCICLO A,
            FA_FACTDOCU_NOCICLO B
              WHERE A.COD_TIPDOCUM = :iNotaCred
            AND B.NUM_SECUENCI = A.NUM_SECUREL
            AND B.COD_TIPDOCUM = A.COD_TIPDOCUMREL
            AND B.COD_VENDEDOR_AGENTE = A.COD_VENDEDOR_AGENTEREL
            AND B.LETRA = A.LETRAREL
            AND B.COD_CENTREMI = A.COD_CENTRREL
            AND A.NUM_SECUENCI > :iValorCero
            AND A.COD_TIPDOCUM > :iValorCero
            AND A.COD_VENDEDOR_AGENTE > :iValorCero
            AND A.LETRA > : szCadenaVacia
            AND A.COD_CENTREMI > :iValorCero
            AND A.COD_CLIENTE = :ihCodCliente
            AND A.NUM_FOLIO = :lhNumFolio
            AND A.PREF_PLAZA = :szhPrefPlaza
            UNION
             SELECT B.NUM_FOLIO  NUM_FOLIO,
            B.PREF_PLAZA PREF_PLAZA
               FROM FA_FACTDOCU_NOCICLO A,
            FA_HISTDOCU         B
              WHERE A.COD_TIPDOCUM = :iNotaCred
            AND B.NUM_SECUENCI = A.NUM_SECUREL
            AND B.COD_TIPDOCUM = A.COD_TIPDOCUMREL
            AND B.COD_VENDEDOR_AGENTE = A.COD_VENDEDOR_AGENTEREL
            AND B.LETRA = A.LETRAREL
            AND B.COD_CENTREMI = A.COD_CENTRREL
            AND A.COD_CICLFACT = :lCodCiclFact
            AND A.NUM_SECUENCI > :iValorCero
            AND A.COD_TIPDOCUM > :iValorCero
            AND A.COD_VENDEDOR_AGENTE > :iValorCero
            AND A.LETRA > :szCadenaVacia
            AND A.COD_CENTREMI > :iValorCero
            AND A.COD_CLIENTE = :ihCodCliente
            AND A.NUM_FOLIO = :lhNumFolio
            AND A.PREF_PLAZA = :szhPrefPlaza
            UNION
             SELECT B.NUM_FOLIO  NUM_FOLIO,
            B.PREF_PLAZA PREF_PLAZA
               FROM FA_HISTDOCU  A,
            FA_HISTDOCU  B
              WHERE A.COD_TIPDOCUM = :iNotaCred
            AND B.NUM_SECUENCI = A.NUM_SECUREL
            AND B.COD_TIPDOCUM = A.COD_TIPDOCUMREL
            AND B.COD_VENDEDOR_AGENTE = A.COD_VENDEDOR_AGENTEREL
            AND B.LETRA = A.LETRAREL
            AND B.COD_CENTREMI = A.COD_CENTRREL
            AND A.COD_CICLFACT = :lCodCiclFact
            AND A.NUM_SECUENCI > :iValorCero
            AND A.COD_TIPDOCUM > :iValorCero
            AND A.COD_VENDEDOR_AGENTE > :iValorCero
            AND A.LETRA > :szCadenaVacia
            AND A.COD_CENTREMI > :iValorCero
            AND A.COD_CLIENTE = :ihCodCliente
            AND A.NUM_FOLIO = :lhNumFolio
            AND A.PREF_PLAZA = :szhPrefPlaza);

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (modulo,"\n\t\t* En sentenia SELECT, Codigo: [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
        return (FALSE);
    }

    *lNumFolioRel = lhNumFolioRel;
    strcpy(szPrefPlazaRel,szhPrefPlazaRel);
    return (TRUE);
} /* Fin Funcion bfnFolioRelacionado */


BOOL fnGrabaAnoProceso (long lCod_Cliente, long lCod_CiclFact, int iCod_Anomalia, char *szObs_Anomalia)
{
    static int  iTitulo;
    static long lsCod_Cliente;
    char modulo[]   ="fnGrabaAnomaliaImpresion";

    char    szhDes_Proceso  [41];
    char    szhObs_Anomalia[101];

    strncpy(szhDes_Proceso,"ImpresionScl",40);
    strncpy(szhObs_Anomalia,szObs_Anomalia,100);

    vDTrazasLog (modulo,"\tDentro de la funcion(%s):  ",LOG03,modulo);
    vDTrazasLog (modulo,"\n\t\t* Valores de Anomalia:"
             "\n\t\t* Proceso        [%ld]"
             "\n\t\t* Cliente        [%ld]"
             "\n\t\t* Ciclo de Fact. [%ld]"
             "\n\t\t* Desc. Proceso  [%s]"
             "\n\t\t* Cod. Anomalia  [%d]"
             "\n\t\t* Desc. Anomalia [%s]"
             , LOG04,lgNum_Proceso
             , lCod_Cliente
             , lCod_CiclFact
             , szhDes_Proceso
             , iCod_Anomalia
             , szhObs_Anomalia);

    if ( iTitulo != 1 )
    {
        fprintf(fpAnomalias,"PROCESO ANOMALIA|CLIENTE|CICLO DE FACT|DESC PROCESO|COD ANOMALIA|DESC ANOMALIA|\n");
        fprintf(fpAnomalias,"----------------|-------|-------------|------------|------------|-------------|\n");
        iTitulo = 1;
    }

    if ( lsCod_Cliente != lCod_Cliente )
    {
        fprintf(fpAnomalias,"%ld|%ld|%ld|%s|%d|%s|\n"
            ,lgNum_Proceso
            ,lCod_Cliente
            ,lCod_CiclFact
            ,szhDes_Proceso
            ,iCod_Anomalia
            ,szhObs_Anomalia);
        lsCod_Cliente = lCod_Cliente;
    }
    return(TRUE);
}


BOOL bfnObtieneRegsImpresion(DETALLEOPER *pstMascaraOper,int iTipDoc)
{
	int iIndTipReg, iTotal, i;

    EXEC SQL BEGIN DECLARE SECTION;
    char  szCodRegistro [1000][6]; /* max registros estimados */
    char  szCodTipDocum [1000][6]; /* max registros estimados */
    EXEC SQL END   DECLARE SECTION;

    char *szModulo="bfnObtieneRegsImpresion";

    gihCodTipDocum = iTipDoc;
	vDTrazasLog  ("","\n\t** Entrada en [%s][%d] **" ,LOG06,szModulo, gihCodTipDocum);

    EXEC SQL OPEN cRegImpre ;

    if (SQLCODE != SQLOK )
    {
        vDTrazasLog  (szModulo,"\n\t**  Error en SQL-OPEN Cursor_DetalleOper **"
                        "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\n\t**  Error en SQL-OPEN Cursor_DetalleOper **"
                        "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return  (FALSE);
    }

    EXEC SQL
    	FETCH cRegImpre
    	 INTO :szCodRegistro,
              :szCodTipDocum;

    if (SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND )
    {
        vDTrazasLog  (szModulo,"\n\t**  Error en SQL-FETCH Cursor_DetalleOper **"
                        "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\n\t**  Error en SQL-FETCH Cursor_DetalleOper **"
                        "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return  (FALSE);
    }

    iTotal =  sqlca.sqlerrd[2];
    EXEC SQL CLOSE cRegImpre ;

	pstMascaraOper->iMaxRegImp [0] = 0;
	pstMascaraOper->iMaxRegImp [2] = 0;
	pstMascaraOper->iMaxRegImp [3] = 0;

    vDTrazasLog  ("","\n\t** Total registros %d **" ,LOG06,iTotal);

    for ( i=0; i < iTotal ; i++ )
    {
    	vDTrazasLog  ("","\n\t** Carga registro [%s][%c] **" ,LOG06,szCodRegistro[i], szCodRegistro[i][0]);
        switch(szCodRegistro[i][0]) /* primer caracter del codigo de registro */
        {
			case 'A':
            iIndTipReg = 0;
            	break;
	        case 'B':
	            iIndTipReg = 1;
	            break;
	        case 'D':
	            iIndTipReg = 2;
	            break;
	    }

        strcpy (pstMascaraOper->szCodRegistro [iIndTipReg][pstMascaraOper->iMaxRegImp[iIndTipReg]], szCodRegistro[i]);
    	vDTrazasLog  ("","\t** iMaxRegImp [%d] **" ,LOG06,pstMascaraOper->iMaxRegImp[iIndTipReg]);
    	vDTrazasLog  ("","\t** Registro cargado [%s] **" ,LOG06
            ,pstMascaraOper->szCodRegistro [iIndTipReg][pstMascaraOper->iMaxRegImp[iIndTipReg]]);

        strcpy (pstMascaraOper->szCodTipDocum [iIndTipReg][pstMascaraOper->iMaxRegImp[iIndTipReg]], szCodTipDocum[i]);
        pstMascaraOper->iMaxRegImp    [iIndTipReg]++;
    }

    return (TRUE);
}


/**************************************************************************************/
/*  Funcion que obtiene Mascara de impresion de detalle de llamados por Operadora     */
/**************************************************************************************/
BOOL bCargaMascaraOperadora(DETALLEOPER *pst_MascaraOper,int iTipDoc)
{
int  i, x;
int  iExisteMascara = 0;

    strcpy (szModulo, "bCargaMascaraOperadora");
    vDTrazasLog  ("","\n\t** Entrando a %s **" ,LOG04,szModulo);

    sprintf(pst_MascaraOper->szWhere_Local,"%*.*s\0",sthFadParametros.val_numerico[COD_MASK_WHERE_LOCALES],
    sthFadParametros.val_numerico[COD_MASK_WHERE_LOCALES],sthFadParametros.val_caracter[COD_MASK_WHERE_LOCALES]);

    sprintf(pst_MascaraOper->szWhere_Interzona,"%*.*s\0",sthFadParametros.val_numerico[COD_MASK_WHERE_INTERZONA],
    sthFadParametros.val_numerico[COD_MASK_WHERE_INTERZONA],sthFadParametros.val_caracter[COD_MASK_WHERE_INTERZONA]);

    sprintf(pst_MascaraOper->szWhere_LDI,"%*.*s\0",sthFadParametros.val_numerico[COD_MASK_WHERE_LDI],
    sthFadParametros.val_numerico[COD_MASK_WHERE_LDI],sthFadParametros.val_caracter[COD_MASK_WHERE_LDI]);

    sprintf(pst_MascaraOper->szWhere_Especiales,"%*.*s\0",sthFadParametros.val_numerico[COD_MASK_WHERE_ESPECIALES],
    sthFadParametros.val_numerico[COD_MASK_WHERE_ESPECIALES],sthFadParametros.val_caracter[COD_MASK_WHERE_ESPECIALES]);

    sprintf(pst_MascaraOper->szWhere_Especiales_data,"%*.*s\0",sthFadParametros.val_numerico[COD_MASK_WHERE_ESPECIALESDATA],
    sthFadParametros.val_numerico[COD_MASK_WHERE_ESPECIALESDATA],sthFadParametros.val_caracter[COD_MASK_WHERE_ESPECIALESDATA]);

    sprintf(pst_MascaraOper->szIndFacturado,"%1.1s\0", sthFadParametros.val_caracter[COD_MASK_INDFACTURADO]);
    sprintf(pst_MascaraOper->szServicio,"%-3.3s\0", sthFadParametros.val_caracter[COD_MASK_SERVICIO]);

    pst_MascaraOper->iCodFormulario  = sthFadParametros.val_numerico[COD_MASK_FORMULARIO];
    pst_MascaraOper->iCtesXArchivo   = sthFadParametros.val_numerico[COD_MASK_CLIENTESXFILE];
    pst_MascaraOper->iIndLocal       = sthFadParametros.val_numerico[COD_MASK_LOCAL];
    pst_MascaraOper->iIndEspeciales  = sthFadParametros.val_numerico[COD_MASK_ESPECIALES];
    pst_MascaraOper->iIndInterzona   = sthFadParametros.val_numerico[COD_MASK_INTERZONA];
    pst_MascaraOper->iIndRoaming     = sthFadParametros.val_numerico[COD_MASK_ROAMING];
    pst_MascaraOper->iIndCarrier     = sthFadParametros.val_numerico[COD_MASK_CARRIER];
    pst_MascaraOper->iIndLDI         = sthFadParametros.val_numerico[COD_MASK_LDI];
    pst_MascaraOper->iInd_Agrupacion = sthFadParametros.val_numerico[COD_MASK_INDAGRUPACION];

    vDTrazasLog  (szModulo,"\n\t\t MascaraOperadora :\n"
               "\n\t\t Locales          [%s]"
               "\n\t\t Interzona        [%s]"
               "\n\t\t Ldi              [%s]"
               "\n\t\t Especiales       [%s]"
               "\n\t\t Data             [%s]"
               "\n\t\t Formulario       [%d]"
               "\n\t\t ClientesXArchivo [%d]"
               "\n\t\t IndFacturado     [%s]"
               "\n\t\t iIndLocal        [%d]"
               "\n\t\t iIndInterzona    [%d]"
               "\n\t\t iIndRoaming      [%d]"
               "\n\t\t iIndCarrier      [%d]"
               "\n\t\t iIndEspeciales   [%d]"
               "\n\t\t iIndLDI          [%d]"
               "\n\t\t iTipdoc          [%d]"
               ,LOG04
               ,pst_MascaraOper->szWhere_Local
               ,pst_MascaraOper->szWhere_Interzona
               ,pst_MascaraOper->szWhere_LDI
               ,pst_MascaraOper->szWhere_Especiales
               ,pst_MascaraOper->szWhere_Especiales_data
               ,pst_MascaraOper->iCodFormulario
               ,pst_MascaraOper->iCtesXArchivo
               ,pst_MascaraOper->szIndFacturado
               ,pst_MascaraOper->iIndLocal
               ,pst_MascaraOper->iIndInterzona
               ,pst_MascaraOper->iIndRoaming
               ,pst_MascaraOper->iIndCarrier
               ,pst_MascaraOper->iIndEspeciales
               ,pst_MascaraOper->iIndLDI
               ,iTipDoc);

	/* se agrega carga y clasificacion de registros de impresion */
	if (!bfnObtieneRegsImpresion(pst_MascaraOper,iTipDoc))
	{
        vDTrazasLog  (szModulo,"\t\t MascaraOperadora: Error al cargar tipos de registros de impresion"
        			 ,LOG01);
        return (FALSE);
	}

    for ( i=0; i < MAX_TIPOS_REGISTROS ; i++ ) /* A, B y D */
    {
        if ( stStatus.LogNivel >= LOG06 )
        {
		    for ( x=0; x < pst_MascaraOper->iMaxRegImp[i] ; x++ )
		    {
		        vDTrazasLog  (szModulo,"\t\t MascaraOperadora: [%s] [%s]",LOG06
                          ,pst_MascaraOper->szCodRegistro[i][x]
                          ,pst_MascaraOper->szCodTipDocum[i][x]);
		    }
		}
        iExisteMascara+=pst_MascaraOper->iMaxRegImp[i];
	}
    if(!iExisteMascara)
    {
        vDTrazasLog  (szModulo,"\t\t MascaraOperadora: No Configurada",LOG01);
        return (FALSE);
    }
    return TRUE;

}/* bCargaMascaraOperadora */

/***************************************************************************************/
int GetCiclFact(ST_CICLOFACT * pstCicFact,long lCodCiclFact)
{
    char szFormato_Fecha_Corto[7];

    strcpy (szModulo, "GetCiclFact");
    vDTrazasLog(szModulo,"\t** Entrando en %s"
             "\t*** Inicio de Ciclo de Facturacion (%ld)***"
             ,LOG04,szModulo,lCodCiclFact);
    strcpy(szhFormato_Fecha,"YYYYMMDD");
    strcpy(szFormato_Fecha_Corto,"YYYYMM");

       EXEC SQL
       SELECT COD_CICLO,
              TO_CHAR(FEC_DESDELLAM,:szhFormato_Fecha)            ,
              TO_CHAR(FEC_HASTALLAM,:szhFormato_Fecha)            ,
              TO_CHAR(FEC_EMISION,:szhFormato_Fecha)            ,
              TO_CHAR(ADD_MONTHS(FEC_EMISION,-1),:szFormato_Fecha_Corto)   ,
              TO_CHAR(ADD_MONTHS(FEC_EMISION,-2),:szFormato_Fecha_Corto)   ,
              TO_CHAR(ADD_MONTHS(FEC_EMISION,-3),:szFormato_Fecha_Corto)   ,
              TO_CHAR(ADD_MONTHS(FEC_EMISION,-4),:szFormato_Fecha_Corto)   ,
              TO_CHAR(ADD_MONTHS(FEC_EMISION,-5),:szFormato_Fecha_Corto)   ,
              TO_CHAR(ADD_MONTHS(FEC_EMISION,-6),:szFormato_Fecha_Corto)   ,
              IND_TASADOR,
              TO_CHAR(FEC_DESDECFIJOS,:szhFormato_Fecha)            ,
              TO_CHAR(FEC_HASTACFIJOS,:szhFormato_Fecha)
         INTO :pstCicFact
         FROM FA_CICLFACT
        WHERE COD_CICLFACT = :lCodCiclFact;

    /*if((SQLCODE != SQLOK) && (SQLCODE != SQLNOTFOUND))    */
    if(SQLCODE != SQLOK)
    {
      vDTrazasError(szModulo,"\t\tError en Ciclo Facturacion : %s", LOG01, SQLERRM);
      return(FALSE);
    }
    strcpy(szFec_Desde,pstCicFact->szFec_Desde);
    strcpy(szFec_Hasta,pstCicFact->szFec_Hasta);

    return(TRUE);
}

int ManejoArchImp(LINEACOMANDO         *ParEntrada,
              ST_INFGENERAL        *sthFa_InfGeneral,
              DETALLEOPER          *stMascaraOper,
              FILE             **Fd_ArchImp ,
              ST_ACUMMTO           *AcumMto,
              char             *szNombreArchivo)
{
char szCodIdioma[6];

    strcpy (szModulo, "ManejoArchImp");
    vDTrazasLog(szModulo,"\n\t** Entrada en %s"
             "\n\t->iSecuencial [%d]"
             "\n\t->szPathDir   [%s]"
             ,LOG04, szModulo, sthFa_InfGeneral->iSecuencial, sthFa_InfGeneral->szPathDir);

   if (sthFa_InfGeneral->iSecuencial == 0 )
   {
        sthFa_InfGeneral->iSecuencial = 1;
        strcpy(szCodIdioma,ParEntrada->szCodIdioma); FillCodIdioma(szCodIdioma);
        if(!ParEntrada->iTipoCiclo)
        {
            sprintf(szNombreArchivo,"%s/ImprScl_%02d_%d_%s_%ld_%s.dat"
                       ,sthFa_InfGeneral->szPathDir
                       ,sthFa_InfGeneral->iSecuencial
                       ,ParEntrada->iCodTipDocum
                       ,ParEntrada->szCodDespacho
                       ,ParEntrada->lCodCiclFact
                       ,(strcmp(szgHostId,"-1")==0)?"_":szgHostId);
        }
        else
        {
            sprintf(szNombreArchivo,"%s/00_%015ld.dat"
                       ,sthFa_InfGeneral->szPathDir
                       ,ParEntrada->lProceso);
        }
        printf("\tManejoArchImp-> entro por 1era vez [%s]\n",szNombreArchivo);
        vDTrazasLog(szModulo,"NMFILE: OPEN1|%d|%d|%s|",LOG06
                , sthFa_InfGeneral->iContClientesProcesados
                , sthFa_InfGeneral->iSecuencial,szNombreArchivo);
        if((*Fd_ArchImp = fopen(szNombreArchivo, "w")) == (FILE *)NULL)
        {
            vDTrazasLog(szModulo,"\n\t\tError al abrir archivo-> [%s]\n" ,LOG01,szNombreArchivo);
            vDTrazasError(szModulo,"\n\t\tError al abrir archivo-> [%s]\n" ,LOG01,szNombreArchivo);
            return FALSE;
        }

        return TRUE;
    }

    vDTrazasLog(szModulo,"\t\tsthFa_InfGeneral->iContClientesProcesados [%d]"
             "\t\tstMascaraOper->iCtesXArchivo [%d]"
             ,LOG05, sthFa_InfGeneral->iContClientesProcesados
             ,stMascaraOper->iCtesXArchivo);

    if ( sthFa_InfGeneral->iContClientesProcesados >= stMascaraOper->iCtesXArchivo)
    {
        /* Cerrar archivo y crear otro */
        vDTrazasLog(szModulo,"NMFILE: CLOSE|%d|%d|%s|"
                ,LOG06, sthFa_InfGeneral->iContClientesProcesados
                ,sthFa_InfGeneral->iSecuencial,szNombreArchivo);
        fclose(*Fd_ArchImp);
        if(!ParEntrada->iTipoCiclo)
        {
            if (!bfnInsertar_FadCTLImpres(AcumMto, ParEntrada, sthFa_InfGeneral, szNombreArchivo))
            {
            vDTrazasLog(szModulo,"Error en ejecucion de bfnInsertar_FadCTLImpres ",LOG01);
            return (FALSE);
            }
        }
        sthFa_InfGeneral->iContClientesProcesados = 0;
        sthFa_InfGeneral->iSecuencial++;

        strcpy(szCodIdioma,ParEntrada->szCodIdioma); FillCodIdioma(szCodIdioma);
        if(!ParEntrada->iTipoCiclo)
        {
            sprintf(szNombreArchivo,"%s/ImprScl_%02d_%d_%s_%ld_%s.dat"
                       ,sthFa_InfGeneral->szPathDir
                       ,sthFa_InfGeneral->iSecuencial
                       ,ParEntrada->iCodTipDocum
                       ,ParEntrada->szCodDespacho
                       ,ParEntrada->lCodCiclFact
                       ,(strcmp(szgHostId,"-1")==0)?"_":szgHostId);
        }
        else
        {
            sprintf(szNombreArchivo,"%s/00_%015ld.dat",sthFa_InfGeneral->szPathDir,ParEntrada->lProceso);
        }
        vDTrazasLog(szModulo,"NMFILE: OPEN2|%d|%d|%s|"
                ,LOG06, sthFa_InfGeneral->iContClientesProcesados,sthFa_InfGeneral->iSecuencial,szNombreArchivo);
        if( (*Fd_ArchImp = fopen(szNombreArchivo, "w")) == (FILE *)NULL)
        {
            vDTrazasLog(szModulo,  "\n\t\tError al abrir archivo-> [%s]\n",LOG01,szNombreArchivo);
            vDTrazasError(szModulo,"\n\t\tError al abrir archivo-> [%s]\n",LOG01,szNombreArchivo);

            return FALSE;
        }
    }

    return TRUE;
}


BOOL bfnValidaDespHostID (long lCodCiclFact, char *szCodDespacho, char *szHostId)
{
    char *szModulo="bfnValidaDespHostID";

    EXEC SQL BEGIN DECLARE SECTION;
    int ihContador  = 0;
    long lhCodCiclFact = 0;
    char szhCodDespacho [6];
    char szhHostId [21];
    EXEC SQL END   DECLARE SECTION;

    vDTrazasLog (szModulo,"\n\t\t* Dentro de la funcion %s", LOG05, szModulo);

    /* Asignacion de los parametros a las variables Host */
	strcpy (szhCodDespacho, szCodDespacho);
	strcpy (szhHostId, szHostId);
    lhCodCiclFact = lCodCiclFact;

    EXEC SQL
    SELECT COUNT(1)
      INTO :ihContador
      FROM FA_RANGOSDESPHOST_TO
     WHERE COD_CICLOFACT = :lhCodCiclFact
       AND COD_DESPACHO = :szhCodDespacho
       AND HOST_ID      = :szhHostId;

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo,"\n\t\t* En sentenia SELECT, Codigo: [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
        return (FALSE);
    }

    vDTrazasLog (szModulo,"\n\t\t* %s: Valor devuelto por SELECT, ihContador :[%d]", LOG05, szModulo, ihContador);

    /* Si existe Codigo de despacho para el Host_ID, se retorna TRUE */
    if ( ihContador > 0 )
        return (TRUE);

    return (FALSE);
}


/**************************************************************************/
/* Funcion que genera mascara de impresion de detalle de llamado          */
/**************************************************************************/
BOOL bObtieneMascara(ST_ABONADO     *pst_Abonados
             ,CONCEPTOS_TAR  *stConceptosTar
             ,DETALLEOPER    *pst_MascaraOper)
{
long i,j,k;

    strcpy (szModulo, "bObtieneMascara");

    vDTrazasLog(szModulo,"\n\t Entrada en %s "
             "\n\t\tCantidad Abonados     : [%d]"
             "\n\t\tCantidad de Conceptos : [%d]"
            ,LOG05, szModulo
            ,pst_Abonados->CantidadAbonados
            ,stFaDetCons.iNumReg);

    if (pst_Abonados->CantidadAbonados > 0 && stConceptosTar->iNumConceptos > 0 && stFaDetCons.iNumReg > 0){/*AFGS - 38935*/
        for (i = 0; i < stFaDetCons.iNumReg; i++)
        {
            vDTrazasLog(szModulo,"\t\t Cod Concepto[%d] : [%d]", LOG05,i,stFaDetCons.stDetConsumo[i].iCodConcepto);

            for (j = 0 ; j < stConceptosTar->iNumConceptos ; j++)
            {
            if (stFaDetCons.stDetConsumo[i].iCodConcepto == stConceptosTar->iCodConcepto[j])
            {
            /* Busca abonado y activa flag de impresion */
            for (k = 0; k < pst_Abonados->CantidadAbonados; k++)
            if (pst_Abonados->lNumAbonado[k] == stFaDetCons.stDetConsumo[i].lNumAbonado)
                break; /* Termina el for */

            if (pst_Abonados->iIndDetFact[k] == 1)
            {
            switch (stConceptosTar->iIndTabla[j])
            {
                case    iIND_TABLA_INTERZONA_ESPECIAL :
                        if(pst_MascaraOper->iIndInterzona)
                        {
                    pst_Abonados->iIndInterzona[k]  = iIND_IMPRIME_TRAFICO_SI;
                        }
                        if(pst_MascaraOper->iIndLDI)
                        {
                    pst_Abonados->iIndLdi[k]  = iIND_IMPRIME_TRAFICO_SI;
                        }
                        if ( pst_MascaraOper->iIndEspeciales)
                        {
                    pst_Abonados->iIndEspeciales[k] = iIND_IMPRIME_TRAFICO_SI;
                        }

                    break;
                case    iIND_TABLA_CARRIER :
                    if ( pst_MascaraOper->iIndCarrier)
                        pst_Abonados->iIndCarrier[k]    = iIND_IMPRIME_TRAFICO_SI;
                    break;
                default :
                    break;
            }
            }
            }
            }/* For conceptos de tarificacion */
        }/* For conceptos facturados */
	}
    return TRUE;
}/* End bObtieneMascara */

/**************************************************************************/
/* Funcion que consulta el ultimo ciclo facturado del cliente             */
/**************************************************************************/
BOOL bfnValidaCiclFactClie (long lCodCliente, long *lCodCiclFact)
{
    char *szModulo="bfnValidaCiclFactClie";

    EXEC SQL BEGIN DECLARE SECTION;
    long lhCodCiclFact = 0L;
    long lhCodCliente  = 0L;
    EXEC SQL END   DECLARE SECTION;

    vDTrazasLog (szModulo,"\n\t\t* Dentro de la funcion %s", LOG05, szModulo);

    /* Asignacion de los parametros a las variables Host */
	lhCodCliente = lCodCliente;

    EXEC SQL
    	SELECT COD_CICLFACT  
    	  INTO :lhCodCiclFact
    	  FROM FA_CICLFACT 
    	 WHERE FEC_EMISION IN ( SELECT MAX(FEC_EMISION) 
 								  FROM FA_CICLFACT A
 								 WHERE EXISTS ( SELECT 1 
            						  FROM GA_INFACCEL B 
            					     WHERE B.COD_CLIENTE = :lhCodCliente
                           AND A.COD_CICLFACT = B.COD_CICLFACT )
                       AND EXISTS  ( SELECT 1 
				                       FROM FA_CICLOCLI B 
				                      WHERE B.COD_CLIENTE = :lhCodCliente
				                        AND A.COD_CICLO = B.COD_CICLO )
							       AND IND_FACTURACION > 0 );

	if (SQLCODE == SQLNOTFOUND)
	{
        vDTrazasLog (szModulo,"\n\t\t* No se encontro ciclo facturado para el cliente : [%ld]", LOG03,lhCodCliente);
        return (FALSE);
	}

    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo,"\n\t\t* En sentenia SELECT, Codigo: [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
        return (FALSE);
    }

    vDTrazasLog (szModulo,"\n\t\t* Ciclo encontrado para el cliente :[%ld]", LOG05, lhCodCiclFact);

	*lCodCiclFact = lhCodCiclFact;
	
    return (TRUE);
}

BOOL bfnValidaVentaConcVarios(long lNumVenta)
{
    EXEC SQL BEGIN DECLARE SECTION;
	    long lhNumVenta;
	    char szhNomUsuario [31];
	    int  ihIndicador;
    EXEC SQL END   DECLARE SECTION;
    char *szModulo="bfnValidaVentaConcVarios";

    vDTrazasLog (szModulo,"\n\t\t* Entrada en %s [%ld]", LOG05, szModulo,lNumVenta);
    
    lhNumVenta = lNumVenta;
	strcpy (szhNomUsuario, "FACOVA"); /* validar si es configurable */
    EXEC SQL
    	SELECT 1 
    	  INTO :ihIndicador
    	  FROM GA_VENTAS 
    	 WHERE NUM_VENTA = :lhNumVenta
           AND NOM_USUAR_RECPROV = :szhNomUsuario;

	if (SQLCODE == SQLNOTFOUND)
	{
        vDTrazasLog (szModulo,"\n\t\t* No se encontro venta asociada a conceptos varios [%ld]", LOG03,lhNumVenta);
        return (FALSE);
	}
    if ( SQLCODE != SQLOK )
    {
        vDTrazasLog (szModulo,"\n\t\t* En sentenia SELECT, Codigo: [%d]\n[%s]", LOG01,SQLCODE,SQLERRM);
        return (FALSE);
    }

    return (TRUE);
}


/******************************************************************************************/
/** Informacin de Versionado *************************************************************/
/******************************************************************************************/
/** Pieza                           : */
/**  %ARCHIVE% */
/** Identificador en PVCS                   : */
/**  %PID% */
/** Producto                        : */
/**  %PP% */
/** Revisin                        : */
/**  %PR% */
/** Autor de la Revisin                    : */
/**  %AUTHOR% */
/** Estado de la Revisin ($TO_BE_DEFINED es Check-Out) : */
/**  %PS% */
/** Fecha de Creacin de la Revisin            : */
/**  %DATE% */
/** Worksets ******************************************************************************/
/** %PIRW% */
/** Historia ******************************************************************************/
/** %PL% */
/******************************************************************************************/
